/* Project and source code (c) Copyright by Joona Palaste */
/* Licenced under GNU GPL 3.0                             */

/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : JIPsoft (Joona I Palaste)
 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <libraries/asl.h>
#include <libraries/dos.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <math.h>

#include "SeaTrade.h"

extern UBYTE labels[15][32];
extern UBYTE *Sct;
extern struct Node List1Nodes[];
extern struct Node Cargo3Nodes[];
extern UBYTE InfoWdt[];

struct class class[57] = {
    {"Spider", 200, 30, 1, 350, 0, 0, 20300},
    {"Butterfly", 200, 50, 1, 250, 0, 0, 24500},
    {"Scorpion", 250, 50, 1, 500, 0, 0, 26500},
    {"Sparrow", 350, 40, 1, 1050, 0, 0, 28400},
    {"Tarantula", 200, 70, 1, 150, 0, 0, 28700},
    {"Hornet", 250, 70, 1, 400, 0, 0, 30700},
    {"Dragonfly", 200, 90, 1, 50, 0, 0, 32900},
    {"Kingfisher", 250, 90, 1, 300, 0, 0, 34900},
    {"Raven", 350, 80, 1, 850, 0, 0, 36800},
    {"Hawk", 350, 70, 2, 400, 0, 0, 40700},
    {"Crow", 350, 100, 1, 750, 0, 0, 41000},
    {"Hummingbird", 250, 120, 1, 150, 0, 0, 41200},
    {"Eagle", 350, 80, 2, 350, 0, 0, 42800},
    {"Falcon", 400, 100, 2, 500, 0, 0, 49000},
    {"Viper", 600, 70, 2, 1650, 0, 0, 50700},
    {"Boa", 600, 50, 3, 1250, 0, 0, 52500},
    {"Albatross", 400, 150, 1, 750, 0, 0, 53500},
    {"Cobra", 600, 120, 1, 1900, 0, 0, 55200},
    {"Asp", 500, 100, 2, 1500, 0, 0, 57000},
    {"Wolf", 650, 80, 3, 1350, 0, 0, 60800},
    {"Dingo", 600, 120, 2, 1400, 0, 0, 61200},
    {"Mamba", 600, 150, 1, 1750, 0, 0, 61500},
    {"Cougar", 700, 90, 3, 1550, 0, 0, 64900},
    {"Cheetah", 650, 150, 2, 1500, 0, 0, 69500},
    {"Tiger", 1000, 120, 3, 2500, 1, 250, 96500},
    {"Lion", 1100, 130, 3, 2950, 1, 250, 102600},
    {"Lynx", 1100, 120, 3, 3000, 1, 300, 103000},
    {"Basilisk", 1200, 150, 4, 2850, 1, 300, 119300},
    {"Manticore", 1500, 100, 5, 4100, 1, 300, 126800},
    {"Centaur", 1600, 90, 5, 4650, 1, 320, 129700},
    {"Unicorn", 1600, 100, 5, 4600, 1, 300, 130800},
    {"Griffin", 1600, 100, 5, 4500, 1, 320, 131800},
    {"Sphinx", 1600, 120, 5, 4500, 1, 320, 136000},
    {"Chimaera", 1700, 160, 5, 4800, 1, 320, 148400},
    {"Wyvern", 2000, 160, 7, 5300, 1, 350, 173900},
    {"Dragon", 2000, 200, 8, 4600, 1, 350, 188300},
    {"Supporter", 2200, 200, 8, 5600, 1, 360, 196800},
    {"Navigator", 2200, 220, 8, 5500, 1, 360, 201000},
    {"Courier", 2500, 250, 8, 6450, 2, 250, 227100},
    {"Clipper", 2500, 280, 8, 6300, 2, 250, 233400},
    {"Expeditor", 2700, 250, 10, 6450, 2, 280, 250100},
    {"Cruiser", 2700, 280, 10, 6300, 2, 280, 256400},
    {"Trader", 3000, 250, 10, 7950, 2, 300, 264100},
    {"Merchantman", 3200, 300, 10, 8700, 2, 320, 284600},
    {"Carrier", 3300, 320, 12, 8100, 2, 320, 304800},
    {"Voyager", 3400, 350, 10, 9450, 2, 360, 307100},
    {"Enterprise", 3400, 320, 12, 8600, 2, 350, 311800},
    {"Pluto", 4000, 300, 12, 11300, 3, 300, 342400},
    {"Mercury", 4100, 320, 12, 11700, 3, 320, 353600},
    {"Mars", 4100, 360, 12, 11500, 3, 320, 362000},
    {"Venus", 4200, 360, 12, 12000, 3, 350, 370500},
    {"Neptune", 4500, 320, 14, 12700, 3, 360, 387600},
    {"Uranus", 4800, 320, 12, 15200, 3, 400, 393600},
    {"Saturn", 4500, 360, 14, 12500, 3, 360, 396000},
    {"Jupiter", 4800, 360, 12, 15000, 3, 400, 402000},
    {"Solaris", 4800, 360, 14, 14000, 3, 400, 414000},
    {"", 0, 0, 255, 65535, 0, 0, 0} /* Store - not a real ship class! */
};
struct city city[64] = {
    {"Umacka", {0, 209, 160}, 0, {20, 16, 54, 67, 17, 37, 64, 66, 11, 14, 5, 20}, {5, 9, 14, 21, 22, 25, 28, 32, 36, 41, 42, 44, 46, 49}},
    {"Serfrod", {3, 210, 108}, 0, {21, 16, 67, 64, 20, 34, 76, 57, 10, 13, 5, 20}, {1, 15, 19, 21, 31, 33, 35, 36, 43, 44, 46, 48, 49, 51}},
    {"Ialer", {7, 152, 18}, 0, {21, 19, 55, 68, 19, 38, 63, 64, 9, 14, 5, 20}, {0, 10, 14, 16, 18, 20, 23, 27, 30, 36, 44, 46, 47, 48}},
    {"Tornild", {8, 186, 203}, 3, {23, 24, 28, 101, 27, 35, 74, 37, 15, 15, 5, 20}, {0, 15, 22, 27, 30, 34, 37, 38, 42, 43, 47, 48, 49, 51}},
    {"Undiq", {5, 245, 109}, 0, {19, 18, 65, 75, 18, 38, 64, 57, 10, 13, 5, 20}, {11, 12, 16, 17, 20, 21, 22, 26, 28, 30, 32, 34, 39, 40}},
    {"Ineeng", {7, 99, 26}, 0, {19, 19, 61, 74, 17, 36, 72, 56, 10, 14, 5, 20}, {9, 15, 18, 19, 25, 30, 33, 35, 37, 38, 45, 46, 50, 53}},
    {"Aldily", {7, 83, 151}, 0, {18, 19, 61, 68, 17, 37, 78, 68, 10, 14, 5, 20}, {2, 7, 12, 14, 15, 18, 20, 24, 27, 29, 40, 47, 48, 51}},
    {"Aldtory", {9, 2, 216}, 3, {26, 24, 25, 101, 26, 40, 66, 33, 15, 13, 5, 20}, {3, 4, 5, 8, 10, 11, 18, 19, 22, 32, 39, 43, 46, 55}},
    {"Ageold", {5, 164, 105}, 0, {18, 16, 59, 63, 17, 40, 75, 66, 9, 13, 5, 20}, {6, 11, 12, 13, 15, 18, 21, 23, 34, 35, 47, 49, 50, 55}},
    {"Nyenn", {8, 224, 139}, 3, {27, 22, 26, 85, 28, 33, 68, 38, 15, 14, 5, 20}, {0, 5, 7, 18, 20, 26, 32, 33, 38, 41, 43, 45, 47, 54}},
    {"Warem", {5, 183, 67}, 0, {19, 16, 60, 74, 20, 33, 75, 67, 9, 14, 5, 20}, {0, 2, 6, 7, 9, 17, 18, 21, 30, 31, 32, 38, 44, 47}},
    {"Quanas", {9, 49, 233}, 3, {23, 24, 26, 97, 30, 34, 69, 33, 15, 14, 5, 20}, {12, 14, 15, 19, 22, 25, 26, 31, 33, 40, 42, 44, 50, 55}},
    {"Ackunn", {8, 105, 248}, 3, {27, 25, 24, 95, 30, 37, 72, 33, 15, 14, 5, 20}, {1, 5, 7, 10, 14, 22, 23, 25, 43, 44, 46, 50, 51, 55}},
    {"Esslet", {5, 58, 94}, 2, {19, 18, 43, 103, 43, 25, 47, 49, 10, 19, 5, 20}, {0, 6, 11, 13, 14, 15, 22, 23, 24, 33, 39, 46, 48, 49}},
    {"Veslere", {8, 109, 43}, 3, {25, 25, 28, 84, 26, 35, 71, 37, 14, 15, 5, 20}, {6, 13, 16, 24, 25, 29, 37, 39, 40, 41, 43, 49, 53, 55}},
    {"Schyim", {3, 29, 204}, 0, {19, 19, 55, 63, 18, 38, 65, 64, 10, 12, 5, 20}, {3, 5, 8, 21, 27, 29, 36, 38, 40, 46, 50, 52, 54, 55}},
    {"Swolar", {5, 52, 65}, 2, {18, 18, 38, 94, 38, 24, 51, 47, 9, 16, 5, 20}, {0, 4, 6, 7, 10, 14, 22, 24, 29, 37, 41, 42, 48, 49}},
    {"Aughpol", {7, 80, 225}, 3, {24, 26, 26, 95, 27, 35, 71, 33, 16, 14, 5, 20}, {0, 3, 4, 11, 12, 14, 25, 31, 32, 34, 37, 41, 45, 52}},
    {"Essran", {3, 179, 232}, 0, {19, 18, 65, 66, 18, 40, 68, 58, 10, 14, 5, 20}, {3, 5, 6, 16, 18, 20, 30, 33, 35, 39, 41, 43, 49, 55}},
    {"Ineray", {8, 37, 104}, 3, {25, 23, 28, 85, 29, 40, 71, 31, 14, 14, 5, 20}, {0, 4, 5, 16, 25, 35, 36, 38, 39, 41, 46, 49, 51, 52}},
    {"Yaenth", {5, 17, 236}, 2, {19, 18, 38, 91, 39, 22, 55, 45, 9, 16, 5, 20}, {5, 8, 9, 11, 14, 17, 20, 21, 22, 28, 31, 37, 47, 50}},
    {"Emano", {2, 182, 222}, 0, {18, 18, 54, 73, 19, 40, 73, 56, 9, 14, 5, 20}, {3, 5, 16, 18, 28, 29, 31, 35, 40, 41, 44, 52, 53, 54}},
    {"Hatcdar", {2, 236, 0}, 0, {19, 18, 67, 74, 18, 35, 65, 64, 9, 15, 5, 20}, {0, 1, 2, 5, 6, 12, 22, 25, 27, 32, 39, 44, 52, 55}},
    {"Raystai", {3, 123, 192}, 0, {21, 19, 61, 63, 20, 40, 74, 63, 9, 13, 5, 20}, {2, 3, 4, 10, 12, 13, 16, 19, 20, 21, 23, 24, 33, 51}},
    {"Morhat", {5, 33, 161}, 2, {20, 18, 41, 92, 42, 24, 49, 43, 9, 19, 5, 20}, {1, 7, 9, 10, 29, 33, 34, 35, 37, 43, 44, 46, 47, 49}},
    {"Etqua", {8, 50, 81}, 3, {26, 22, 25, 84, 29, 34, 63, 34, 16, 12, 5, 20}, {5, 7, 12, 18, 21, 31, 34, 36, 39, 40, 41, 42, 46, 53}},
    {"Atque", {5, 112, 20}, 2, {22, 17, 37, 89, 43, 21, 48, 45, 10, 17, 5, 20}, {1, 7, 8, 9, 18, 19, 22, 27, 29, 31, 36, 39, 48, 49}},
    {"Hatina", {6, 218, 156}, 2, {21, 18, 41, 102, 45, 21, 58, 50, 9, 18, 5, 20}, {3, 5, 11, 15, 16, 25, 29, 32, 35, 37, 38, 51, 53, 54}},
    {"Queageo", {8, 75, 100}, 4, {18, 31, 43, 72, 43, 45, 47, 42, 10, 14, 5, 20}, {1, 2, 6, 9, 14, 16, 18, 24, 25, 34, 36, 38, 41, 44}},
    {"Daruk", {9, 66, 73}, 3, {26, 24, 29, 88, 29, 38, 67, 31, 13, 14, 5, 20}, {2, 5, 11, 21, 22, 23, 25, 29, 30, 31, 40, 41, 46, 53}},
    {"Ardale", {9, 119, 118}, 3, {24, 23, 28, 102, 31, 40, 68, 33, 13, 13, 5, 20}, {8, 11, 14, 15, 20, 23, 25, 30, 34, 35, 37, 39, 40, 53}},
    {"Alehas", {8, 97, 87}, 4, {18, 31, 41, 77, 46, 50, 51, 43, 10, 14, 5, 20}, {0, 12, 18, 19, 21, 22, 34, 36, 39, 42, 46, 47, 50, 51}},
    {"Tiagar", {5, 12, 56}, 2, {21, 16, 41, 90, 40, 26, 48, 45, 9, 19, 5, 20}, {0, 2, 5, 8, 10, 17, 18, 33, 35, 36, 39, 44, 46, 47}},
    {"Nyray", {5, 193, 136}, 2, {20, 17, 41, 85, 43, 25, 47, 43, 10, 16, 5, 20}, {3, 8, 15, 18, 25, 26, 29, 32, 41, 45, 47, 48, 49, 50}},
    {"Tusam", {1, 173, 209}, 0, {21, 19, 60, 69, 17, 34, 75, 60, 10, 15, 5, 20}, {3, 7, 8, 9, 11, 15, 19, 22, 29, 35, 40, 44, 45, 53}},
    {"Shyaldy", {5, 21, 181}, 2, {20, 17, 43, 95, 44, 21, 56, 51, 9, 16, 5, 20}, {4, 5, 6, 10, 12, 13, 17, 20, 26, 32, 35, 37, 40, 48}},
    {"Teaugh", {3, 252, 124}, 1, {15, 25, 37, 131, 26, 34, 85, 42, 5, 10, 5, 20}, {1, 2, 10, 14, 16, 17, 24, 29, 37, 40, 41, 42, 49, 53}},
    {"Kellye", {1, 105, 31}, 0, {19, 19, 67, 68, 18, 38, 64, 63, 10, 13, 5, 20}, {2, 3, 4, 6, 8, 10, 15, 17, 20, 29, 33, 36, 42, 55}},
    {"Urnaugh", {5, 106, 34}, 2, {20, 17, 37, 94, 44, 21, 49, 51, 9, 19, 5, 20}, {1, 10, 11, 12, 13, 15, 20, 25, 27, 33, 34, 41, 48, 52}},
    {"Joer", {6, 87, 165}, 2, {19, 18, 36, 85, 42, 24, 47, 51, 11, 17, 5, 20}, {5, 12, 18, 25, 27, 28, 30, 31, 32, 36, 46, 49, 51, 55}},
    {"Aughys", {4, 37, 38}, 1, {14, 26, 43, 149, 29, 35, 94, 48, 6, 9, 5, 20}, {4, 10, 18, 23, 27, 28, 32, 33, 35, 36, 37, 40, 49, 55}},
    {"Nysback", {8, 100, 173}, 4, {18, 31, 37, 76, 44, 48, 51, 42, 9, 14, 5, 20}, {3, 9, 15, 16, 20, 22, 24, 27, 28, 43, 46, 51, 54, 55}},
    {"Oughwar", {5, 15, 143}, 2, {20, 17, 43, 92, 41, 23, 55, 46, 10, 19, 5, 20}, {1, 3, 6, 10, 14, 16, 18, 22, 25, 30, 35, 37, 43, 47}},
    {"Ildceri", {4, 49, 194}, 1, {15, 22, 38, 141, 31, 34, 103, 51, 5, 10, 5, 20}, {3, 4, 7, 11, 14, 18, 27, 29, 34, 39, 40, 42, 46, 53}},
    {"Danech", {6, 72, 43}, 2, {20, 16, 45, 103, 38, 26, 50, 44, 9, 17, 5, 20}, {4, 5, 6, 7, 8, 9, 21, 23, 24, 33, 39, 41, 49, 50}},
    {"Lorarr", {5, 37, 158}, 2, {20, 19, 37, 98, 46, 24, 50, 48, 9, 19, 5, 20}, {3, 7, 8, 10, 12, 16, 21, 22, 29, 31, 33, 42, 54, 55}},
    {"Umelma", {4, 6, 59}, 1, {14, 22, 40, 142, 26, 35, 103, 48, 5, 10, 5, 20}, {2, 7, 12, 13, 14, 18, 27, 31, 35, 44, 45, 47, 48, 51}},
    {"Essrald", {3, 90, 106}, 1, {15, 26, 44, 141, 26, 34, 87, 50, 5, 10, 5, 20}, {6, 7, 8, 11, 16, 18, 19, 24, 27, 29, 31, 42, 50, 52}},
    {"Lyehler", {7, 50, 218}, 4, {21, 35, 42, 65, 45, 46, 47, 47, 10, 13, 5, 20}, {5, 14, 17, 18, 20, 23, 28, 33, 38, 39, 47, 49, 52, 53}},
    {"Asrady", {6, 244, 93}, 4, {21, 32, 39, 65, 39, 48, 48, 49, 10, 13, 5, 20}, {0, 3, 6, 9, 12, 15, 16, 19, 20, 25, 33, 39, 49, 51}},
    {"Tanceri", {6, 110, 9}, 4, {20, 30, 39, 73, 42, 47, 45, 49, 10, 12, 5, 20}, {3, 7, 8, 11, 13, 20, 21, 25, 31, 32, 34, 41, 42, 45}},
    {"Nalart", {8, 207, 138}, 4, {19, 29, 40, 72, 38, 47, 51, 43, 9, 13, 5, 20}, {0, 4, 6, 9, 12, 13, 17, 18, 21, 24, 26, 45, 48, 50}},
    {"Darak", {7, 213, 147}, 4, {21, 30, 40, 74, 38, 48, 42, 47, 10, 14, 5, 20}, {0, 3, 14, 17, 19, 22, 27, 28, 29, 31, 42, 44, 46, 48}},
    {"Sulnala", {8, 35, 182}, 4, {21, 30, 38, 71, 42, 49, 46, 47, 10, 14, 5, 20}, {1, 6, 7, 10, 16, 20, 22, 29, 35, 38, 40, 47, 49, 50}},
    {"Esthelm", {7, 157, 95}, 4, {21, 30, 39, 70, 41, 47, 47, 47, 10, 15, 5, 20}, {3, 4, 9, 13, 21, 25, 27, 29, 32, 38, 44, 49, 50, 51}},
    {"Endryn", {7, 160, 144}, 4, {19, 35, 43, 65, 46, 47, 49, 42, 10, 13, 5, 20}, {3, 7, 11, 14, 19, 20, 29, 33, 34, 36, 37, 40, 51, 55}},
    {"Turet", {1, 159, 32}, 1, {14, 24, 40, 136, 29, 35, 99, 43, 6, 9, 5, 20}, {0, 4, 9, 18, 20, 26, 31, 34, 36, 42, 43, 46, 49, 50}},
    {"Worsaye", {7, 160, 162}, 4, {21, 35, 43, 74, 47, 46, 50, 45, 9, 14, 5, 20}, {3, 5, 6, 9, 11, 12, 13, 17, 28, 30, 35, 47, 52, 55}},
    {"Beldhat", {4, 75, 134}, 1, {13, 26, 37, 135, 28, 35, 96, 43, 5, 9, 5, 20}, {3, 4, 10, 16, 21, 23, 27, 29, 33, 35, 37, 40, 48, 53}},
    {"Ackvrod", {1, 206, 12}, 1, {16, 22, 38, 146, 30, 39, 92, 45, 5, 9, 5, 20}, {2, 7, 10, 12, 25, 27, 32, 36, 38, 39, 40, 48, 51, 53}},
    {"Sulinau", {3, 112, 215}, 1, {14, 24, 42, 136, 31, 39, 100, 51, 5, 9, 5, 20}, {3, 8, 10, 11, 24, 28, 31, 34, 39, 41, 43, 47, 48, 55}},
    {"Hinar", {7, 13, 220}, 4, {19, 35, 41, 63, 39, 47, 47, 45, 10, 13, 5, 20}, {2, 15, 16, 17, 22, 25, 29, 33, 35, 41, 45, 46, 47, 52}},
    {"Muyer", {5, 144, 174}, 1, {15, 26, 43, 141, 26, 37, 102, 47, 5, 10, 5, 20}, {0, 1, 8, 11, 20, 21, 22, 27, 31, 37, 38, 41, 46, 48}},
    {"Omtskel", {6, 4, 88}, 1, {15, 25, 40, 133, 31, 37, 90, 50, 5, 10, 5, 20}, {0, 3, 23, 25, 29, 30, 35, 36, 40, 42, 48, 49, 51, 52}}
};
STRPTR months[12]={
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
    "Dec"
};
STRPTR firstnames[80]={
    "Al", "Alice", "Andy", "Angus", "Anna", "Anni", "Betty", "Bill", "Bob",
    "Bruce", "Carly", "Chloe", "Chuck", "Clara", "Cybil", "Dana", "David",
    "Dora", "Ed", "Emma", "Ethan", "Fred", "Gary", "Greg", "Hanna", "Harry",
    "Hugh", "Iggy", "Ike", "Jake", "James", "Jane", "Jason", "Jeff", "Jenny",
    "Joe", "John", "Julia", "Kate", "Kim", "Lara", "Larry", "Lars", "Linda",
    "Lisa", "Lois", "Louis", "Lucy", "Maria", "Marge", "Mary", "Mia", "Mike",
    "Mona", "Nancy", "Neil", "Nick", "Nora", "Pat", "Paul", "Peter", "Phil",
    "Pia", "Rob", "Roger", "Ron", "Ruth", "Sarah", "Selma", "Simon", "Spike",
    "Steve", "Susan", "Tanya", "Tim", "Tom", "Vera", "Wendy", "Zack", "Zoe"
};
STRPTR lastnames[80]={
    "Andrews", "Baker", "Barker", "Baube", "Bemis", "Blofeld", "Bond",
    "Braben", "Brogden", "Bush", "Carter", "Clinton", "Cokes", "Cullen",
    "Dalton", "Davies", "Delbo", "Drake", "Drougge", "Edwards", "Ferree",
    "Fillis", "Flynt", "Ford", "Froholt", "Furman", "Galan", "Gates", "Gordon",
    "Gore", "Grayson", "Green", "Guerra", "Haddock", "Hare", "Hefner",
    "Hickman", "Hill", "Hunt", "Jameson", "Johnson", "Jung", "Jurasik", "Lane",
    "Larsson", "Lennon", "Leno", "Lovejoy", "Loving", "Lowe", "Major", "Matz",
    "Miner", "Monroe", "Moore", "Morency", "Mulder", "Nash", "Nixon", "Peake",
    "Pilato", "Powers", "Quayle", "Ramshaw", "Reagan", "Rue", "Sawkins",
    "Schwarz", "Scully", "Sellers", "Senior", "Sepelak", "Smith", "Stanz",
    "Tennant", "Turner", "Venkman", "Wayne", "Welker", "Wildman"
};
STRPTR types[4]={"Crew", "Pass", "Pass", "Fail"};
STRPTR error="Error", proceed="Proceed", information="Information";
struct Image *image[407], *shipimage[8];
struct Image *panelimage, *citypanelimage, *shipviewimage, *classimage;
struct RastPort hidden_rp;
struct BitMap *hidden_bm=NULL;
struct Node *nodelist=NULL;
struct Node dockednodes[3];
struct Node freecabinsnode;
struct ship *shiplist, *ship, *currentship, *first, *second, *shipa, *shipb;
struct person *personlist, *person, *currentperson;
struct city *currentcity=NULL;
ULONG gametime, money, hour=1;
UWORD namesavailable[6400];
UWORD ships=0, howmuch, shipnum, selected, shipclass, namesleft=6400, persons=0;
WORD citydiff[64][12];
UBYTE text[4][36];
BYTE cargotype[5][12]={
    {0, -1, 2, -1, -2, 0, 0, 1, 0, 0, 0, 0},
    {-1, 0, 0, 2, 0, 0, 1, 0, -2, -1, 0, 0},
    {0, -1, 0, 0, 2, -2, -1, 0, 0, 1, 0, 0},
    {1, 0, -2, 0, 0, 0, 0, -1, 2, 0, 0, 0},
    {0, 1, 0, -1, 2, 1, -2, 0, 0, 0, 0, 0}
};
UBYTE latitude[8], longitude[8], datestr[21], shipnums[256], dockstring[11],
    freecabinstext[15];
UBYTE price[12] = {20, 25, 41, 94, 29, 37, 71, 47, 10, 14, 5, 20};
UBYTE *map;
WORD mapleft, maptop;
UBYTE autocenter=2, cargonum, transfermode=0, transfernum, peoplemode, textx,
    texty, shippeople, cityn, shipturn=0, infomode=0, skipflag=TRUE;
BYTE currentdockedship;
double increment, slowest;
APTR logfile=NULL;

struct Image *readimage(BPTR, UWORD, UWORD, UBYTE);
void freeimage(struct Image *);
void cleanup();
void freeships();
UWORD weight(struct ship *);
void coordinatestrings(STRPTR, STRPTR, UWORD, UWORD);
void showcargostatus(UWORD, UWORD, UBYTE, UWORD, UWORD);
void moveship(BYTE, BYTE);
void setshipmoves(double);
void setshipfuel(UWORD);
void setshipfood(UWORD);
void makecargolist();
void showcargolist();
void showtransfervalues(UBYTE);
void hourly();
void cleartext();
void addtext(STRPTR);
void showtext();
void freepersons();
void datestring(STRPTR, ULONG);
void coordinatestrings(STRPTR, STRPTR, UWORD, UWORD);
void selectfirstperson();
void setmoney(ULONG);
UWORD getpay(struct ship *);

/* Loads the graphics in the accompanying data files into struct Images. */
int loadgraphics()
{
    BPTR file;
    UWORD i;
    for (i=0; i<407; i++)
        image[i]=NULL;
    file=Open("SeaTrade.gfx", MODE_OLDFILE);
    if (!file)
        return NULL;
    for (i=0; i<407; i++)
        if (!(image[i]=readimage(file, 16, 16, 8)))
        {
            Close(file);
            cleanup();
            return NULL;
        }
    if (!(panelimage=readimage(file, 320, 256, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    if (!(citypanelimage=readimage(file, 320, 256, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    if (!(shipviewimage=readimage(file, 64, 64, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    for (i=0; i<8; i++)
        if (!(shipimage[i]=readimage(file, 32, 32, 8)))
        {
            Close(file);
            cleanup();
            return NULL;
        }
    if (!(classimage=readimage(file, 64, 112, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    Close(file);
    InitRastPort(&hidden_rp);
    hidden_bm=AllocBitMap(320, 256, 8, BMF_CLEAR, NULL);
    hidden_rp.BitMap=hidden_bm;
    return TRUE;
}

/* Loads the palette in the accompanying data files into the screen's ViewPort.
*/
int loadpalette()
{
    BPTR file;
    UBYTE *data=NULL;
    if (!(data=AllocVec(3080, MEMF_CLEAR)))
        return NULL;
    file=Open("SeaTrade.pal", MODE_OLDFILE);
    if (!file)
    {
        FreeVec(data);
        return NULL;
    }
    if (Read(file, data, 3080)<3080)
    {
        Close(file);
        FreeVec(data);
        return NULL;
    }
    LoadRGB32(&(Scr->ViewPort), data);
    Close(file);
    FreeVec(data);
    return TRUE;
}

int allocstuff()
{
    BPTR file;
    map=NULL;
    if (!(map=AllocVec(720000, MEMF_CLEAR)))
        return FALSE;
    if (!(file=Open("IslandMap.dat", MODE_OLDFILE)))
    {
        FreeVec(map); map=NULL;
        return FALSE;
    }
    Read(file, map, 720000);
    Close(file);
    return TRUE;
}

void cleanup()
{
    UWORD i;
    for (i=0; i<407; i++)
        freeimage(image[i]);
    freeimage(panelimage);
    freeimage(citypanelimage);
    freeimage(shipviewimage);
    for (i=0; i<8; i++)
        freeimage(shipimage[i]);
    freeimage(classimage);
    if (map)
        FreeVec(map);
    freeships();
    freepersons();
    if (hidden_bm)
    {
        FreeBitMap(hidden_bm);
        hidden_bm=NULL;
    }
}

/* Reads a fully usable struct Image from the specified filehandle. Specify
   image dimensions and depth. After use, first FreeVec(image->ImageData),
   then FreeVec(image). */
struct Image *readimage(BPTR file, UWORD width, UWORD height, UBYTE depth)
{
    struct Image *image;
    UWORD *imagedata;
    ULONG size;
    if (!(image=AllocVec((ULONG)sizeof(struct Image), MEMF_CHIP)))
        return NULL;
    if ((width&15)==0)
        size=width*height*depth/8;
    else
        size=((width&1008)+16)*height*depth/8;
    if (!(imagedata=AllocVec(size, MEMF_CHIP)))
    {
        FreeVec(image);
        return NULL;
    }
    if (!Read(file, imagedata, size))
    {
        FreeVec(image); FreeVec(imagedata);
        return NULL;
    }
    image->LeftEdge=0; image->TopEdge=0; image->Width=width;
    image->Height=height;
    image->Depth=depth; image->ImageData=(UWORD *)imagedata;
    image->PlanePick=(1<<depth)-1; image->PlaneOnOff=0; image->NextImage=NULL;
    return image;
}

/* Safely frees the given struct Image. If called with a nonexistent image
   (NULL pointer), does nothing. */
void freeimage(struct Image *image)
{
    if (image)
    {
        FreeVec(image->ImageData); image->ImageData=NULL;
        FreeVec(image);
    }
}

/* Displays any given request with Intution EasyRequesters. */
UBYTE request(struct Window *window, STRPTR title, STRPTR text, STRPTR buttons,
    APTR arg)
{
    struct EasyStruct req;
    req.es_StructSize=sizeof(struct EasyStruct);
    req.es_Flags=0; req.es_Title=title;
    req.es_TextFormat=text; req.es_GadgetFormat=buttons;
    return EasyRequest(window, &req, NULL, arg);
}

/* Allocates and shows an ASL request, and allows the user to choose a file.
   Returns the chosen filename in the UBYTE * buffer supplied in the second
   parameter. */
int aslreq(UBYTE savemode, UBYTE *namebuffer)
{
    STRPTR blurb, label;
    UBYTE *p;
    UBYTE result, c=0;
    struct FileRequester *fr=NULL;
    switch (savemode)
    {
        case FALSE:
        blurb="Choose a file to save:"; label="Save";
        break;
        case TRUE:
        blurb="Choose a file to load:"; label="Load";
        break;
        case 2:
        blurb="Choose a log file:"; label="OK";
        break;
    }
    if (fr=AllocAslRequestTags(ASL_FileRequest,
        ASLFR_Window, SeaTradeWnd,
        ASLFR_TitleText, blurb,
        ASLFR_PositiveText, label,
        ASLFR_NegativeText, (STRPTR)"Cancel",
        ASLFR_InitialHeight, 224,
        ASLFR_InitialWidth, 240,
        ASLFR_InitialLeftEdge, 40,
        ASLFR_InitialTopEdge, 20,
        ASLFR_DoSaveMode, (BOOL)!!savemode,
        TAG_DONE))
    {
        if (result=AslRequest(fr, NULL))
        {
            for (p=fr->rf_Dir; *p; p++);
                if (p>fr->rf_Dir)
                    c=*(p-1);
                if (c==':' || !c)
                    sprintf(namebuffer,"%s%s", fr->rf_Dir, fr->rf_File);
                else
                    sprintf(namebuffer,"%s/%s", fr->rf_Dir, fr->rf_File);
        }
        FreeAslRequest(fr);
    }
    return result;
}

/* Finds out the size of the file associated with the given handle. Uses an
   AmigaDOS FileInfoBlock as a measuring device. */
ULONG sizeoffile(BPTR file)
{
    struct FileInfoBlock fib;
    ULONG size=0L;
    ExamineFH(file, &fib);
    size=(ULONG)fib.fib_Size;
    return size;
}

/* Changes the state of a menuitem. Supply the index numbers of the menu and the
   item (NOT the actual pointers!) and a boolean state (disabled/enabled). */
void menuonoff(UBYTE menu, UBYTE item, UBYTE state)
{
    if (state)
        OnMenu(SeaTradeWnd, FULLMENUNUM(menu, item, NOSUB));
    else
        OffMenu(SeaTradeWnd,FULLMENUNUM(menu, item, NOSUB));
}

/* Changes the state of a submenuitem. Supply the index number of the menu, the
   item and the subitem (NOT the actual pointers!) and a boolean state
   (disabled/enabled). */
void submenuonoff(UBYTE menu, UBYTE item, UBYTE sub, UBYTE state)
{
    if (state)
        OnMenu(SeaTradeWnd, FULLMENUNUM(menu, item, sub));
    else
        OffMenu(SeaTradeWnd, FULLMENUNUM(menu, item, sub));
}

/* Returns a pseudo-random number from 0 to (maxvalue-1). */
long rnd(long maxvalue)
{
    static int seed=0;
    if (!seed)
    {
        seed=(int)time(NULL);
        srand(seed);
    }
    return rand()%maxvalue;
}

UWORD getblocktype(UWORD x, UWORD y)
{
    struct ship *ship;
    ULONG lsb, msb;
    UWORD result;
    UBYTE bit;
    for (ship=shiplist; ship; ship=ship->next);
    lsb=x+800*y; msb=640000+x/8+100*y;
    result=*(map+lsb);
    bit=!!(*(map+msb) & 1<<(x&7));
    result+=256*bit;
    return result;
}

/* Draws the given Image to the given RastPort. Supply RastPort, index number of
   Image, and block (not pixel) coordinates. */
void drawimage(struct RastPort *rp, UWORD num, UBYTE px, UBYTE py)
{
    DrawImage(rp, image[num], 8+px*16, 8+py*16);
}

/* Superimposes the given Image onto the one currently ready to be copied at
   hidden_rp. First ANDs the block with the given Image's "mask", then ORs the
   block with the Image itself. */
void superimpose(struct RastPort *rp, UWORD num, UBYTE px, UBYTE py)
{
    UWORD mask;
    if (num>=375 && num<379) /* facing right, lights on */
        mask=num+16;
    if (num>=379 && num<387) /* facing right, lights off or facing left, lights
                                on */
        mask=num+12;
    if (num>=387 && num<395) /* facing left, lights off or facing right, lights
                                on, selected */
        mask=num+8;
    if (num>=395 && num<403) /* facing right, lights off, selected or facing
                                left, lights on, selected */
        mask=num+4;
    if (num>=403 && num<407) /* facing left, lights off, selected */
        mask=num;
    if (num>=391) /* if ship is selected, it uses same image as non-selected
                     ship */
        num-=16;
    drawimage(&hidden_rp, mask, 0, 11);
    ClipBlit(&hidden_rp, 8, 184, rp, 8+px*16, 8+py*16, 16, 16, 0x80);
    drawimage(&hidden_rp, num, 0, 11);
    ClipBlit(&hidden_rp, 8, 184, rp, 8+px*16, 8+py*16, 16, 16, 0xE0);
}

void writelog(STRPTR text)
{
    if (!logfile)
        return;
    Write(logfile, text, strlen(text));
}

void writelogdate()
{
    UBYTE logdatestr[21];
    datestring(logdatestr, gametime);
    writelog(logdatestr);
}

void setshiplocation(struct ship *s, UWORD x, UWORD y)
{
    ULONG loc;
    loc=x+800*y;
    s->location[0]=loc>>16;
    s->location[1]=loc>>8&255;
    s->location[2]=loc&255;
}

void getshiplocation(struct ship *s, UWORD *x, UWORD *y)
{
    ULONG loc;
    loc = (s->location[0]<<16) + (s->location[1]<<8) + s->location[2];
    *x=loc%800; *y=loc/800;
}

void getcitylocation(struct city *s, UWORD *x, UWORD *y)
{
    ULONG loc;
    loc = (s->location[0]<<16) + (s->location[1]<<8) + s->location[2];
    *x=loc%800; *y=loc/800;
}

/* Returns the image index (not the struct Image *) for a ship based on size
   class and three flags. First flag is 0 for left-facing ships, 1 for right-
   facing ships. Second flag is 0 for inactive ships, 1 for active ships. Third
   flag is 0 for non-selected ships, 1 for selected ships. */
UWORD getshipimage(UBYTE size, UBYTE face, UBYTE active, UBYTE selected)
{
    UWORD im;
    im=375+size;
    if (!face)
        im+=8;
    if (!active)
        im+=4;
    if (selected)
        im+=16;
    return im;
}

void drawmap(WORD left, WORD top)
{
    UWORD sx, sy, currentx, currenty;
    UBYTE x, y, direction, movesleft, iscurrent;
    struct ship *s, *found;
    if (left<0)
        mapleft=left=0;
    if (top<0)
        maptop=top=0;
    if (left>788)
        mapleft=left=788;
    if (top>788)
        maptop=top=788;
    getshiplocation(currentship, &currentx, &currenty);
    for (x=0; x<11; x++)
        for (y=0; y<11; y++)
        {
            drawimage(&hidden_rp, getblocktype(left+x, top+y), x, y);
            found=NULL;
            for (s=shiplist; s; s=s->next)
            {
                getshiplocation(s, &sx, &sy);
                if (sx==left+x && sy==top+y)
                {
                    direction=(s->flags&4)/4;
                    movesleft=s->moves>=1.0;
                    iscurrent=s==currentship;
                    found=s;
                    if (iscurrent || sx!=currentx || sy!=currenty)
                        break;
                }
            }
            if (found)
                superimpose(&hidden_rp, getshipimage(found->class/14, direction,
                    movesleft, iscurrent), x, y);
        }
    ClipBlit(&hidden_rp, 8, 8, SeaTradeWnd->RPort, 8, 8, 176, 176, 0xC0);
}

/* Adds a new ship to our list. The variable "ship" will point to the list's
   tail. Returns a pointer to the new ship. Supplied parameters: ship name,
   index number of ship class. */
struct ship *createship(STRPTR name, UBYTE class)
{
    struct ship *newship;
    if (!(newship=AllocVec(sizeof(struct ship), MEMF_CLEAR)))
        return NULL;
    CopyMem(name, newship->name, 13);
    newship->class=class;
    if (!shiplist)
        shiplist=ship=newship;
    else
    {
        ship->next=newship;
        newship->prev=ship;
        ship=newship;
    }
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    AddTail(&Ships0List, &newship->node);
    newship->node.ln_Name=newship->name;
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        &Ships0List, TAG_DONE);
    ships++;
    return newship;
}

/* Renames the given ship. Since thisship->node->ln_Name already points to the
   same memory location as thisship->name, all we need to update the ship
   ListViewgadget is to detach and reattach the list. */
void renameship(struct ship *thisship, STRPTR name)
{
    UBYTE message[80];
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    sprintf(message, ": The %s class ship \"%s\" was renamed \"%s\".\n",
        class[thisship->class].name, thisship->name, name);
    writelogdate();
    writelog(message);
    CopyMem(name, thisship->name, 13);
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        &Ships0List, TAG_DONE);
}

/* Deletes the given ship from the list. */
void deleteship(struct ship *oldship)
{
    if (!oldship)
        return;
    if (oldship->prev)
        oldship->prev->next=oldship->next;
    if (oldship->next)
        oldship->next->prev=oldship->prev;
    if (oldship==ship)
        ship=oldship->prev;
    if (oldship==shiplist)
        shiplist=ship=NULL;
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    Remove(&oldship->node);
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        &Ships0List, TAG_DONE);
    FreeVec(oldship);
    ships--;
}

/* Deletes all the ships from the list. */
void freeships()
{
    struct ship *ship1, *ship2;
    ship1=shiplist;
    while (ship1)
    {
        ship2=ship1->next;
        FreeVec(ship1);
        ship1=ship2;
    }
}

/* Creates a new person. Supplied parameters are: Person type and name (array
   index), amount of pay person demands or offers, deadline before which person
   must be handled, pointer to city where person appears, array index of city
   where person wants to go. */
struct person *createperson(UWORD pay, ULONG deadline, struct city *location,
    UBYTE destination)
{
    struct person *newperson;
    UWORD nameno, i;
    if (namesleft)
    {
        nameno=rnd(namesleft);
        if (nameno<namesleft-1)
            for (i=nameno; i<namesleft-1; i++)
                namesavailable[i]=namesavailable[i+1];
        namesleft--;
    }
    else
    {
        namesleft=6400;
        for (i=0; i<6400; i++)
            namesavailable[i]=i;
        nameno=rnd(namesleft);
    }
    if (!(newperson=AllocVec(sizeof(struct person), MEMF_CLEAR)))
        return NULL;
    sprintf(newperson->name, "%s %s", firstnames[namesavailable[nameno]%80],
        lastnames[namesavailable[nameno]/80]);
    newperson->node.ln_Name=newperson->name;
    newperson->pay=pay; newperson->deadline=deadline;
    newperson->location=location; newperson->destination=destination;
    persons++;
    return newperson;
}

void settype(struct person *p, UBYTE type)
{
    p->flags=(p->flags & TYPEMASK) | ((type & 3) << 9);
}

UBYTE gettype(struct person *p)
{
    return (p->flags >> 9) & 3;
}

void setloc(struct person *p, UWORD loc)
{
    p->flags=(p->flags & LOCMASK) | (loc & 0x1FF);
}

UWORD getmark(struct person *p)
{
    return p->flags & (CONTRACTMARK | FAILMARK);
}

void setmark(struct person *p, UWORD mark)
{
    p->flags = (p->flags & MARKMASK) | mark;
}

UWORD getloc(struct person *p)
{
    return p->flags & 0x1FF;
}

/* Adds the given person to the list. Persons are sorted in order of deadline,
   earliest deadline first. */
void addperson(struct person *thisperson)
{
    struct person *pointer;
    if (!personlist)
        personlist=person=thisperson;
    else
    {
        pointer=person;
        while (pointer && pointer->deadline > thisperson->deadline)
            pointer=pointer->prev;
        if (!pointer)
        {
            thisperson->next=personlist;
            personlist->prev=thisperson;
            personlist=thisperson;
        }
        else
        {
            thisperson->prev=pointer;
            thisperson->next=pointer->next;
            pointer->next->prev=thisperson;
            pointer->next=thisperson;
            if (pointer==person)
                person=thisperson;
        }
    }
}

/* Creates a new passenger to one of the 64 cities. The passenger will have a
   random destination, deadline, and payment offer. */
void createpassenger()
{
    struct person *newperson;
    LONG hurry;
    WORD x1, y1, x2, y2, dx, dy;
    UWORD pay;
    UBYTE fromcity, tocity, attempts;
    double d, dmodifier, hurrymodifier, rmodifier;
    fromcity=rnd(64);
    getcitylocation(&city[fromcity], &x1, &y1);
    attempts=0;
    do
    {
        tocity=rnd(64);
        if (fromcity!=tocity)
        {
            getcitylocation(&city[tocity], &x2, &y2);
            dx=x1-x2; dy=y1-y2;
            d=sqrt(dx*dx + dy*dy);
        }
        else
            d=0.0;
        attempts++;
    }
    while ((d<60.0 || d>=240.0) && attempts<200);
    if (attempts==200)
        return; /* Give up after 200 attempts, to prevent infinite loops */
    /* How much of a hurry the passenger is in? The times the passenger has to
       travel range from 6 to 18 hours. A time of 6 hours will cause a
       modifier of 1.25, a time of 18 hours a modifier of 0.75. */
    hurry=rnd(43200);
    hurrymodifier=1.0+(21600-hurry)/86400.0;
    /* How far the passenger wants to go? The distances range from 60 to 240
       squares. A distance of 60 squares will cause a modifier of 0.5, a
       distance of 240 squares a modifier of 1.5. */
    dmodifier=1.0+(d-150.0)/180.0;
    /* And to spice it up, a random modifier from 0.9 to 1.1. */
    rmodifier=1.0+(rnd(20)-10)/100.0;
    pay=(400*dmodifier*hurrymodifier*rmodifier) + (fromcity<<10);
    newperson=createperson(pay, gametime+21600+hurry, &city[fromcity], tocity);
    if (newperson)
    {
        addperson(newperson);
        settype(newperson, TOURIST);
        setloc(newperson, fromcity);
    }
}

/* Creates a new potential crew member (ie. a person looking for work) in one of
   the 64 cities. The person will have a random deadline and salary demand. */
void createcrew()
{
    struct person *newperson;
    UBYTE incity;
    incity=rnd(64);
    newperson=createperson(rnd(20)+25, gametime+21600+rnd(43200), &city[incity],
        0);
    if (newperson)
    {
        addperson(newperson);
        settype(newperson, CREW);
        setloc(newperson, incity);
    }
}

/* Deletes the given person from the list. */
void freeperson(struct person *oldperson)
{
    if (oldperson==personlist)
        personlist=oldperson->next;
    else
        oldperson->prev->next=oldperson->next;
    if (oldperson==person)
        person=oldperson->prev;
    else
        oldperson->next->prev=oldperson->prev;
    FreeVec(oldperson);
    persons--;
}

void freepersons()
{
    struct person *p, *pp;
    p=personlist;
    while (p)
    {
        pp=p->next;
        freeperson(p);
        p=pp;
    }
}

/* Makes a list of the persons in a given place (whether it's a city or a ship).
   Since one person can be only in one place at a time, there's no need to store
   the nodes in multiple lists, and the list can be cleared at the start of this
   function. Supplied parameters: pointer to list to create, pointer to city or
   ship where the persons are. */
void createpersonlist(struct MinList *list, void *location, UBYTE type)
{
    struct person *p;
    UBYTE flag;
    NewList(list);
    if (list!=&CityList8List)
        shippeople=0;
    for (p=personlist; p; p=p->next)
        if (p->location == location)
        {
            flag=FALSE;
            switch (type)
            {
                case CREW:
                flag=(gettype(p)==CREW); break;
                case (UBYTE)~0:
                flag=TRUE; break;
                default:
                flag=(gettype(p)!=CREW); break;
            }
            if (flag)
            {
                if (list!=&List1List && list!=&Items2List)
                    AddTail(list, &p->node);
                else
                {
                    sprintf(labels[shippeople], "%13s (%s)", p->name,
                        types[gettype(p)]);
                    AddTail(list, &List1Nodes[shippeople]);
                }
                if (list!=&CityList8List)
                    shippeople++;
            }
        }
    if (location!=&currentcity->store)
        if (list!=&List1List && list!=&Items2List)
        {
            sprintf(freecabinstext, "%2d free cabins",
                class[currentship->class].cabins - currentship->crew -
                currentship->passengers);
            freecabinsnode.ln_Name=freecabinstext;
            if (list!=&CityList8List)
                AddTail(list, &freecabinsnode);
        }
        else
        {
            sprintf(labels[shippeople], "Free cabins left: %2d",
                class[currentship->class].cabins - currentship->crew -
                currentship->passengers);
            AddTail(list, &List1Nodes[shippeople]);
        }
}

/* Returns the (index-1)th person whose location is the one specified. For
   instance, use findperson(currentcity, 0) to find the first person in the
   current city. */
struct person *findperson(void *location, LONG index, UBYTE type)
{
    struct person *p;
    LONG i=-1;
    UBYTE flag;
    p=personlist;
    do
    {
        flag=FALSE;
        if (p->location==location)
        {
            switch (type)
            {
                case CREW:
                flag=(gettype(p)==CREW);
                break;
                case (UBYTE)~0:
                flag=TRUE;
                break;
                default:
                flag=(gettype(p)!=CREW);
                break;
            }
            if (flag)
                i++;
        }
        if (i<index)
            p=p->next;
    }
    while (i!=index);
    return p;
}

/* The inverse of the above function: Returns the (0-based) index of the
   given person. */
ULONG rfindperson(void *location, struct person *who, UBYTE type)
{
    struct person *p;
    LONG i=-1;
    UBYTE found=FALSE, flag;
    p=personlist;
    do
    {
        flag=FALSE;
        if (p->location==location)
        {
            switch (type)
            {
                case CREW:
                flag=(gettype(p)==CREW);
                break;
                case (UBYTE)~0:
                flag=TRUE;
                break:
                default:
                flag=(gettype(p)!=CREW);
                break;
            }
            if (flag)
                i++;
        }
        if (p==who)
            found=TRUE;
        else
            p=p->next;
    }
    while (!found);
    return i;
}

void showperson(struct person *p)
{
    UBYTE d[21], lat[8], lon[8], message[116];
    UWORD x, y;
    datestring(d, p->deadline);
    getcitylocation(&city[p->destination], &x, &y);
    coordinatestrings(lat, lon, x, y);
    cleartext();
    if (peoplemode)
        sprintf(message, "Hi, I'm %s and I want to go to %s (%s %s) by %s. I "
        "will pay %d.", p->name, city[p->destination].name, lat, lon, d,
        p->pay & 0x3FF);
    else
        sprintf(message, "Hi, I'm %s and I want a job on a ship by %s. I would "
        "like a salary of %d per day.", p->name, d, p->pay & 0x3FF);
    addtext(message);
    showtext();
}

/* Creates a new struct Node and names it with the given name. Automatically
   adds the new struct Node to the given struct List. */
struct Node *createnode(STRPTR name, struct List *list)
{
    struct Node *newnode;
    UBYTE *label;
    if (!(newnode=AllocVec(sizeof(struct Node), MEMF_CLEAR)))
        return NULL;
    if (!(label=AllocVec(13, MEMF_CLEAR)))
    {
        FreeVec(newnode);
        return NULL;
    }
    CopyMem(name, label, 13);
    newnode->ln_Name=label;
    AddTail(/*&SelectShip6List*/ list, newnode);
    return newnode;
}

/* Frees all the struct Nodes we have allocated. */
void freenodes()
{
    struct Node *node, *oldnode;
    UWORD i;
    i=0;
    oldnode=nodelist;
    while (i<shipnum)
    {
        node=oldnode->ln_Succ;
        FreeVec(oldnode->ln_Name);
        FreeVec(oldnode);
        oldnode=node;
        i++;
    }
    nodelist=NULL;
}

/* Initialises a list. This must be called before addnode() or selectship(). */
void createlist(struct List *list)
{
    NewList(/*&SelectShip6List*/ list);
    nodelist=NULL;
    shipnum=0;
}

/* Adds a new ship as a struct Node. First parameter is the index number of the
   ship in the "real" shiplist. Second parameter is the ship's name. Third
   parameter is a pointer to the struct List the node should be added to. */
UBYTE addnode(UBYTE number, STRPTR name, struct List *list)
{
    struct Node *newnode;
    if (!(newnode=createnode(name, list)))
        return FALSE;
    if (!nodelist)
        nodelist=newnode;
    shipnums[shipnum++]=number;
    return TRUE;
}

/* Selects the given ship as the current ship. The ship's attributes will be
   displayed and it will be centerd on screen (with autocenter on). Passing a
   NULL pointer will cause the first ship in the fleet, wherever it is, to be
   selected. */
void select(struct ship *thisship)
{
    struct ship *s;
    UWORD i;
    if (!thisship)
        thisship=shiplist;
    if (!thisship)
    {
        request(SeaTradeWnd, information, "You have no ships left!",
            proceed, NULL);
        menuonoff(1, 0, FALSE);
        menuonoff(1, 1, FALSE);
        submenuonoff(1, 3, 0, FALSE);
        submenuonoff(1, 3, 1, FALSE);
        return;
    }
    menuonoff(1, 0, !!thisship->next);
    menuonoff(1, 1, !!thisship->prev);
    menuonoff(1, 3, !!thisship->carrying[0]);
    submenuonoff(1, 3, 0, !!thisship->carrying[0]);
    submenuonoff(1, 3, 1, !!thisship->carrying[0]);
    currentship=thisship;
    setshipmoves(thisship->moves);
    setshipfuel(thisship->cargo[10]);
    setshipfood(thisship->cargo[11]);
    i=0;
    for (s=shiplist; s!=thisship; s=s->next)
        i++;
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected, i,
        TAG_DONE);
    moveship(0, 0);
}

/* Displays the "Select a ship" window and returns a pointer to the selected
   ship. Returns NULL if the user closed the window without selecting any ship.
   createlist() and addnode() must be called before this. */
struct ship *selectship()
{
    struct ship *s;
    UWORD i;
    if (!nodelist)
        return NULL;
    selected=(UWORD)~0;
    if (!OpenSelectWindow())
    {
        while (HandleSelectIDCMP());
        CloseSelectWindow();
    }
    freenodes();
    if (selected==~0)
        return NULL;
    s=shiplist;
    for (i=0; i<shipnums[selected]; i++)
        s=s->next;
    return s;
}

/* Displays Info window for the given ship, to allow viewing or modifying of
   ship attributes. */
void info(struct ship *thisship)
{
    UBYTE i;
    infomode=0;
    currentdockedship=-1;
    sprintf(InfoWdt, "Info for ship \"%s\"", thisship->name);
    InfoGTags[1]=(ULONG)thisship->name;
    InfoGTags[6]=(ULONG)class[thisship->class].name;
    NewList(&Docked1List);
    for (i=0; i<3; i++)
        if (thisship->carrying[i])
        {
            dockednodes[i].ln_Name=thisship->carrying[i]->name;
            AddTail(&Docked1List, &dockednodes[i]);
        }
    if (!OpenInfoWindow())
    {
        showcargolist();
        while (HandleInfoIDCMP());
        CloseInfoWindow();
    }
}

void showinfo(UBYTE mode)
{
    GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    if (!mode)
        makecargolist();
    else
        createpersonlist(&List1List, currentship, ~0);
    GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
        &List1List, TAG_DONE);
}

/* Returns the current total weight of the given ship. Smaller ships being
   carried (ships of class Tiger and above can carry ships of class Albatross
   and below) are calculated recursively with this function. */
UWORD weight(struct ship *thisship)
{
    UWORD wt;
    UBYTE i;
    wt=class[thisship->class].weight;
    for (i=0; i<12; i++)
        wt+=thisship->cargo[i];
    if (class[thisship->class].docks)
        for (i=0; i<class[thisship->class].docks; i++)
            if (thisship->carrying[i])
                wt+=weight(thisship->carrying[i]);
    return wt;
}

/* Calculates the amount of free space available on the given ship. */
UWORD freespace(struct ship *thisship)
{
    UWORD wt;
    UBYTE i;
    wt=class[thisship->class].maxcargo;
    for (i=0; i<12; i++)
        wt-=thisship->cargo[i];
    return wt;
}

/* Returns the current speed factor of the given ship. Theoretical maximum is 1
   (ship is nothing but a big engine), but in practice the values range from
   0.0137 (maximally laden Centaur) to 0.48 (unladen Hummingbird). */
double speed(struct ship *thisship)
{
    return (double)class[thisship->class].engine/(double)weight(thisship);
}

/* Finds the ship with the slowest current speed and sets the variable slowest
   to equal its speed. */
void findslowest()
{
    struct ship *s;
    slowest=1.0;
    for (s=shiplist; s; s=s->next)
        if (speed(s)<slowest)
            slowest=speed(s);
}

/* Calculates the minimum amount of crew a ship of the given class takes to be
   able to operate. */
UBYTE getcrew(UBYTE classn)
{
    if (classn<=23)
        return 1;
    if (classn<=33)
        return 2;
    if (classn<=39)
        return 3;
    if (classn<=46)
        return 4;
    return 5;
}

/* Writes a human-readable date to the given string, based on the given amount
   of elapsed seconds. Ranges from 0 ( 1.Jan 2048 00:00:00) to 4294967295
   ( 1.Feb 2186 06:28:15), a total of 138 years, 1 month, 6 hours 28 minutes and
   15 seconds. */
void datestring(STRPTR string, ULONG date)
{
    UBYTE year, month, day, hour, minute, second;
    second=date%60; date/=60;
    minute=date%60; date/=60;
    hour=date%24; date/=24;
    day=date%30; date/=30;
    month=date%12; date/=12;
    year=date;
    sprintf(string, "%2d.%s %d %2d:%2d:%2d", day+1, months[month], year+2048,
        hour, minute, second);
}

/* Writes human-readable map coordinates to the given strings, based on the
   given block coordinates. Ranges from (0,0) (66\B030'N 66\B030'W) to (799,799)
   (66\B040'S 66\B040'E). */
void coordinatestrings(STRPTR lat, STRPTR lon, UWORD x, UWORD y)
{
    UBYTE degree, minute, ns, we;
    if (y<400)
    {
        ns='N';
        y=400-y;
    }
    else
    {
        ns='S';
        y-=400;
    }
    degree=y/6; minute=y%6;
    sprintf(lat, "%2d\B0%2d'%c", degree, minute*10, ns);
    if (x<400)
    {
        we='W';
        x=400-x;
    }
    else
    {
        we='E';
        x-=400;
    }
    degree=x/6; minute=x%6;
    sprintf(lon, "%2d\B0%2d'%c", degree, minute*10, we);
}

void setshipmoves(double moves)
{
    currentship->moves=moves;
    GT_SetGadgetAttrs(SeaTradeGadgets[12], SeaTradeWnd, NULL, GTNM_Number,
        (LONG)moves, TAG_DONE);
}

void setshipfuel(UWORD fuel)
{
    currentship->cargo[10]=fuel;
    GT_SetGadgetAttrs(SeaTradeGadgets[13], SeaTradeWnd, NULL, GTNM_Number,
        (LONG)fuel, TAG_DONE);
}

void setshipfood(UWORD food)
{
    currentship->cargo[11]=food;
    GT_SetGadgetAttrs(SeaTradeGadgets[15], SeaTradeWnd, NULL, GTNM_Number,
        (LONG)food, TAG_DONE);
}

void clearcitydiffs()
{
    UBYTE i, j;
    for (i=0; i<64; i++)
        for (j=0; j<12; j++)
            citydiff[i][j]=0;
}

void clearpersonmarks()
{
    struct person *p;
    for (p=personlist; p; p=p->next)
        setmark(p, 0);
}

void setdate(ULONG seconds)
{
    struct person *p, *pp;
    struct ship *s;
    UBYTE title[27], message[94], shiptext[25];
    UBYTE flag, comma;
    gametime=seconds;
    datestring(datestr, seconds);
    GT_SetGadgetAttrs(SeaTradeGadgets[16], SeaTradeWnd, NULL, GTTX_Text,
        datestr, TAG_DONE);
    while (gametime > hour*3600)
        hourly();
    p=personlist;
    flag=0;
    while (p)
    {
        pp=p; p=p->next;
        /* All TOURISTs (transferable back to city) onboard a ship become
           PASSENGERs (not transferable back to city) */
        if (gettype(pp)==TOURIST && getloc(pp)>=64)
        {
            settype(pp, PASSENGER);
            setmark(pp, CONTRACTMARK);
            flag|=1;
        }
        /* Free all persons which satisfy these requirements:
           1. Person's deadline has expired
           2. Person's type is TOURIST -or- person's type is CREW and he/she is
              in a city, not on board a ship */
        if (gametime > pp->deadline)
        {
            if (gettype(pp)==TOURIST || (gettype(pp)==CREW && getloc(pp)<64))
                freeperson(pp);
            if (gettype(pp)==PASSENGER)
            {
                sprintf(title, "Message from %s", pp->name);
                sprintf(shiptext, "(Aboard \"%s\")\n",
                    ((struct ship *)pp->location)->name);
                sprintf(message, "%sI was supposed to be in %s\nby now! You "
                    "can forget about\npayment!", (pp->location==currentship ?
                    "" : shiptext), city[pp->destination].name);
                request(SeaTradeWnd, title, message, proceed, NULL);
                /* Persons having exceeded their deadline without getting to
                   their destination vanish immediately if they are in a city
                   store ship, but hang around if they're on a real ship. */
                if (((struct ship *)pp->location)->class < 56)
                {
                    settype(pp, FAILED);
                    setmark(pp, FAILMARK);
                    flag|=2;
                }
                else
                {
                    ((struct ship *)p->location)->passengers--;
                    freeperson(pp);
                }
            }
        }
    }
    if (logfile && (flag & 1))
    {
        writelogdate();
        writelog(": The following people were taken on ship voyages:\n");
        comma=FALSE;
        for (p=personlist; p; p=p->next)
            if (getmark(p)==CONTRACTMARK)
            {
                sprintf(message, "%s%s from %s to %s", (comma ? ", " : ""),
                    p->name, city[p->pay >> 10].name,
                    city[p->destination].name);
                comma=TRUE;
                writelog(message);
            }
        writelog("\n");
    }
    if (logfile && (flag & 2))
    {
        writelogdate();
        writelog(": The following people failed to reach their destinations\n"
            "on time:\n");
        comma=FALSE;
        for (p=personlist; p; p=p->next)
            if (getmark(p)==FAILMARK)
            {
                sprintf(message, "%s%s to %s", (comma ? ", " : ""), p->name,
                    city[p->destination].name);
                comma=TRUE;
                writelog(message);
            }
        writelog("\n");
    }
    clearpersonmarks();
    /* If any ships are on strike, and the player has got enough money to pay
       them, then pay them and put them to work again. */
    for (s=shiplist; s; s=s->next)
        if (money>=getpay(s) && s->flags&8)
        {
            request(SeaTradeWnd, information, "The crew of \"%s\"\nstart "
                "working again.", proceed, s->name);
            setmoney(money-getpay(s));
            s->flags&=~8;
        }
}

void setmoney(ULONG cash)
{
    money=cash;
    GT_SetGadgetAttrs(SeaTradeGadgets[17], SeaTradeWnd, NULL, GTNM_Number, cash,
        TAG_DONE);
    if (CityWnd)
        GT_SetGadgetAttrs(CityGadgets[5], CityWnd, NULL, GTNM_Number, cash,
            TAG_DONE);
}

void consumefood()
{
    struct ship *s;
    for (s=shiplist; s; s=s->next)
        if (s->cargo[11] >= s->crew+s->passengers)
            s->cargo[11]-=s->crew+s->passengers;
        else
        {
            s->cargo[11]=0;
            request(SeaTradeWnd, "Alarm", "Ship \"%s\" has no\nfood left!",
                proceed, s->name);
        }
    setshipfood(currentship->cargo[11]);
}

UWORD getpay(struct ship *s)
{
    UWORD pay=0;
    struct person *p;
    for (p=personlist; p; p=p->next)
        if (p->location==s && gettype(p)==CREW)
            pay+=(p->pay & 0x3FF);
    return pay;
}

void calculatemoney(ULONG *shipmoney, ULONG *cargomoney, ULONG *maxcargo)
{
    struct ship *s;
    UBYTE i;
    *shipmoney=*cargomoney=*maxcargo=0;
    for (s=shiplist; s; s=s->next)
    {
        *shipmoney+=class[s->class].price;
        for (i=0; i<12; i++)
        {
            *cargomoney+=s->cargo[i]*price[i];
            *maxcargo+=s->cargo[i];
        }
    }
}

void daily()
{
    struct ship *s;
    UBYTE message[140];
    ULONG shipmoney, cargomoney, maxcargo;
    UBYTE i, j, day;
    BYTE d, diff;
    /* All ship crews either get paid (if there's enough money left) or go on
       strike (if there isn't). */
    for (s=shiplist; s; s=s->next)
        if (money>=getpay(s))
            setmoney(money-getpay(s));
        else
        {
            if (!(s->flags&8))
                request(SeaTradeWnd, information, "The crew of \"%s\"\n"
                    "refuse to work without pay.", proceed, s->name);
            s->flags|=8;
        }
    /* All the supplies and demands in the cities change randomly. The ranges
       for changing are [-2, 2] for normal goods, [-4, 0] for major imports,
       [-3, 1] for minor imports, [0, 4] for major exports and [-1, 3] for minor
       exports. The demands change to reflect the supplies, and further change
       by a random amount in the range [-1, 1]. */
    for (i=0; i<64; i++)
        for (j=0; j<12; j++)
        {
            d=-2-cargotype[city[i].type][j];
            diff=rnd(5)+d;
            if (city[i].supply[j]+diff < 0)
                diff=0;
            city[i].supply[j]+=diff;
            if (city[i].demand[j]-diff < 0)
                diff=0;
            city[i].demand[j]-=diff;
            diff=rnd(3)-1;
            if (city[i].demand[j]-diff < 0)
                diff=0;
            city[i].demand[j]-=diff;
        }
    day=gametime/86400;
    if (!(day%5))
    {
        writelogdate();
        writelog(": Periodical money report:\n");
        calculatemoney(&shipmoney, &cargomoney, &maxcargo);
        sprintf(message, "%10 d in %3d ships.\n%10d in %8d kg of cargo.\n"
            "%10d in cash.\n------------------------------------\n"
            "%10d in total.\n", shipmoney, ships, cargomoney, maxcargo, money,
            shipmoney+cargomoney+money);
        writelog(message);
    }
}

void monthly()
{
    UBYTE i;
    for (i=0; i<64; i++)
        city[i].shipsavailable[city[i].shipsmade[shipturn]]++;
    shipturn++;
    if (shipturn==14)
        shipturn=0;
}

void hourly()
{
    UBYTE i;
    if (!(hour % 24))
        daily();
    if (!(hour % 720))
        monthly();
    consumefood();
    hour++;
    for (i=0; i<4; i++)
    {
        createpassenger();
        createcrew();
    }
}

WORD abs(WORD n)
{
    if (n>=0)
        return n;
    else
        return -n;
}

/* Check if any ship still has moves left. If one has, select it, otherwise
   start a new round with all ships getting new moves. */
void checkships()
{
    struct ship *s;
    UBYTE message[80];
    UBYTE finished, i, j, flag;
    /* is there a ship (not being carried by another ship) that still has at
       least 1 move left? */
    finished=TRUE;
    for (s=shiplist; s; s=s->next)
        if (s->moves>=1.0 && !s->carriedby)
        {
            finished=FALSE;
            break;
        }
    if (finished)
    {
        /* start a new round */
        setdate(gametime+(ULONG)increment);
        /***************************************************************************
         * INSERT CODE HERE TO LOG HOW MUCH WAS BOUGHT AND SOLD IN THE CITIES      *
         * DURING THE TIME THAT JUST PASSED!                                       *
         ***************************************************************************/
        flag=FALSE;
        for (i=0; i<64; i++)
        {
            for (j=0; j<12; j++)
                if (citydiff[i][j] != 0)
                {
                    flag=TRUE;
                    break;
                }
            if (flag)
                break;
        }
        if (logfile && flag)
        {
            writelogdate();
            writelog(": The following transactions took place:\n");
            for (i=0; i<64; i++)
                for (j=0; j<12; j++)
                    if (citydiff[i][j] != 0)
                    {
                        sprintf(message, "%s %d %11s %s %s.\n",
                            (citydiff[i][j]>0 ? "Bought" : "Sold  "),
                            abs(citydiff[i][j]), CargoName4Labels[j],
                            (citydiff[i][j]>0 ? "from" : "to  "),
                            city[i].name);
                        writelog(message);
                    }
        }
        clearcitydiffs();
        findslowest();
        increment=60.0/slowest;
        for (s=shiplist; s; s=s->next)
            s->moves+=4.0*speed(s)/slowest;
        /* find the first ship which isn't being carried by another ship */
        for (s=shiplist; s->carriedby; s=s->next);
        select(s);
        setshipmoves(currentship->moves);
    }
    else
        if (currentship->moves<1.0)
            /* s is already pointing to the first ship that still has at least
               1 move left and isn't being carried by another ship */
            select(s);
}

/* Moves the current ship by the given delta coordinates. Delta coordinates must
   be either -1, 0 or 1. */
void moveship(BYTE dx, BYTE dy)
{
    UWORD x, y;
    UBYTE stage, i;
    double maxmoves, newmoves;
    /* the amount of moves this ship started with in this round */
    maxmoves=4.0/slowest*speed(currentship);
    if (currentship->moves<1.0)
        return;
    if (!currentship->cargo[10])
        return;
    if (currentship->carriedby)
    {
        request(SeaTradeWnd, error, "This ship is being carried by the\n"
            "ship \"%s\". Release\nit first.", proceed,
            currentship->carriedby->name);
        return;
    }
    getshiplocation(currentship, &x, &y);
    if (getblocktype(x+dx, y+dy)<353)
        return;
    if (dx!=0 || dy!=0)
    {
        if (currentship->flags&8)
            return;
        /*
        if (currentship->crew < getcrew(currentship->class))
        {
            request(SeaTradeWnd, error, "You don't have enough crew to\n"
                "operate the ship \"%s\".", proceed, currentship->name);
            return;
        }
        */
        stage=currentship->flags&3;
        if (stage<3)
            currentship->flags=(currentship->flags&~3)|(stage+1);
        else
        {
            currentship->flags&=~3;
            setshipfuel(currentship->cargo[10]-1);
        }
        if (dx==-1)
            currentship->flags&=~4;
        if (dx==1)
            currentship->flags|=4;
        /* the amount of moves this ship would now have if we were to start a
           new round */
        newmoves=4.0/slowest*speed(currentship);
        setshipmoves(newmoves-maxmoves+currentship->moves);
    }
    x+=dx; y+=dy;
    setshiplocation(currentship, x, y);
    for (i=0; i<3; i++)
        if (currentship->carrying[i])
            setshiplocation(currentship->carrying[i], x, y);
    switch (autocenter)
    {
        case 0:
        /* Autocenter "None": Never center on ship at all */
        break;
        case 1:
        /* Autocenter "Off-line": Center on ship only if it's moving off-screen
        */
        if (x<mapleft || x>mapleft+10 || y<maptop || y>maptop+10)
        {
            mapleft=x-5; maptop=y-5;
        }
        break;
        case 2:
        /* Autocenter "On-line": Always center on a moving ship */
        mapleft=x-5; maptop=y-5;
        break;
    }
    drawmap(mapleft, maptop);
    coordinatestrings(latitude, longitude, x, y);
    GT_SetGadgetAttrs(SeaTradeGadgets[18], SeaTradeWnd, NULL, GTTX_Text,
        latitude, TAG_DONE);
    GT_SetGadgetAttrs(SeaTradeGadgets[19], SeaTradeWnd, NULL, GTTX_Text,
        longitude, TAG_DONE);
    if (dx!=0 || dy!=0)
    {
        /* ship has now moved, so it has 1 move less */
        setshipmoves(currentship->moves-1.0);
        checkships();
    }
}

/* Sets the autocenter mode to "None" (never center on ship), "Off-line" (center
   on ships moving off-screen) or "On-line" (always center on ship). Calls
   moveship(0, 0); to make sure ship is centered, if it needs to be. */
void setautocenter(UBYTE mode)
{
    autocenter=mode;
    moveship(0, 0);
}

void citymap(struct RastPort *rp, UWORD sx, UWORD sy, UBYTE width, UBYTE height,
    UWORD destx, UWORD desty)
{
    UWORD b;
    UBYTE x, y, p;
    for (x=0; x<width; x++)
        for (y=0; y<height; y++)
        {
            if (width!=39 && x==17 && y==17)
                p=1;
            else
            {
                b=getblocktype(sx+x, sy+y);
                if (b<0x100)
                    p=57;
                if (b>=0x100 && b<0x151)
                    p=56;
                if (b>=0x151 && b<0x161)
                    p=55;
                if (b>=0x161 && b<0x171)
                    p=39;
                if (b==0x171)
                    p=41;
                if (b>0x171)
                    p=88+(b-0x172)*4;
            }
            SetAPen(&hidden_rp, p);
            WritePixel(&hidden_rp, x*2, y*2);
            SetAPen(&hidden_rp, p+1);
            WritePixel(&hidden_rp, x*2+1, y*2);
            WritePixel(&hidden_rp, x*2, y*2+1);
            SetAPen(&hidden_rp, p+2);
            WritePixel(&hidden_rp, x*2+1, y*2+1);
        }
    ClipBlit(&hidden_rp, 0, 0, rp, destx, desty, 2*width, 2*height, 0xC0);
}

/* Makes the currently selected ship dock inside the city with the given index
   number. The ship must already physically reside in the city's location. This
   function doesn't return until the player clicks "EXIT" in the city window. */
void gotocity(UBYTE n)
{
    struct person *p, *pp;
    UBYTE coordstr[16], title[27], pay[5], message[80];
    UWORD x, y;
    currentcity=&city[n]; cityn=n;
    ship->next=&currentcity->store; currentcity->store.prev=ship;
    ship=&currentcity->store;
    getshiplocation(currentship, &x, &y);
    coordinatestrings(latitude, longitude, x, y);
    sprintf(coordstr, "%s %s", latitude, longitude);
    if (!OpenCityWindow())
    {
        citymap(CityWnd->RPort, x-19, y-19, 39, 39, 24, 8);
        GT_SetGadgetAttrs(CityGadgets[0], CityWnd, NULL, GTTX_FrontPen,
            88+city[n].type*4, GTTX_Text, city[n].name, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[1], CityWnd, NULL, GTTX_Text,
            coordstr, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[2], CityWnd, NULL, GTTX_Text,
            datestr, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text,
            currentship->name, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[5], CityWnd, NULL, GTNM_Number,
            money, TAG_DONE);
        p=personlist;
        while (p)
        {
            pp=p; p=p->next;
            if ((gettype(pp)==PASSENGER && pp->location==currentship &&
                pp->destination==n) || gettype(pp)==FAILED)
            {
                sprintf(title, "Message from %s", pp->name);
                sprintf(pay, "%d", pp->pay & 0x3FF);
                if (gettype(pp)!=FAILED)
                {
                    request(CityWnd, title, "Thanks for bringing me here!\n"
                        "Here's %s in payment.", proceed, pay);
                    setmoney(money+(pp->pay & 0x3FF));
                    writelogdate();
                    sprintf(message, ": %s got to %s on time.\n", pp->name,
                        city[n].name);
                    writelog(message);
                }
                else
                    if (pp->destination==n)
                        request(CityWnd, title, "Good riddance! Don't\n"
                            "even ask for payment!", proceed, NULL);
                    else
                        request(CityWnd, title, "Good riddance! I'll go\n"
                            "to %s on my own!", proceed,
                              city[pp->destination].name);
                ((struct ship *)pp->location)->passengers--;
                freeperson(pp);
            }
        }
        while (HandleCityIDCMP());
        CloseCityWindow();
        ship=ship->prev; ship->next=NULL;
        if (currentship==&currentcity->store)
            currentship=NULL;
        select(currentship);
    }
    currentcity=NULL;
}

/* Finds all the ships that are capable of carrying the current ship in the
   location given. The ships' addresses will be written into the array
   shipspresent and their number will be returned as the return value of this
   function. */
BYTE finddockableships(UWORD x, UWORD y, struct ship **shipspresent,
    UBYTE *shipnums)
{
    struct ship *s=shiplist;
    UWORD sx, sy, myweight;
    WORD i=0, j=0, k=0;
    UBYTE carrying;
    myweight=weight(currentship);
    for (i=0; i<ships && i<256; i++)
    {
        if (s!=currentship)
        {
            getshiplocation(s, &sx, &sy);
            /* Check that the ship in question is in the same place as our
               current ship and is not itself being carried by another ship, and
               that its docks are big enough to hold the current ship */
            if (x==sx && y==sy)
                if (s->class==56)
                {
                    shipspresent[j]=s;
                    shipnums[j++]=i;
                }
                else
                    if (!s->carriedby && myweight<=class[s->class].docksize)
                    {
                        /* Check that the ship isn't already carrying all it can
                        */
                        carrying=0;
                        for (k=0; k<3; k++)
                            carrying+=!!s->carrying[k];
                        if (carrying < class[s->class].docks)
                        {
                            shipspresent[j]=s;
                            shipnums[j++]=i;
                        }
                    }
        }
        s=s->next;
    }
    return j;
}

/* Enables the currently selected ship to dock with cities or other ships. */
void dock()
{
    struct ship *shipspresent[256], *shiptouse;
    UBYTE shipnums[256];
    UWORD x, y;
    BYTE i, n=-1, shipsfound;
    getshiplocation(currentship, &x, &y);
    if (getblocktype(x, y)>=370)
    {
        for (i=0; i<64; i++)
            if (currentship->location[0]==city[i].location[0] &&
                currentship->location[1]==city[i].location[1] &&
                currentship->location[2]==city[i].location[2])
            {
                n=i;
                break;
            }
        if (n>=0)
        {
            /* Temporarily add the "store" ship of the city we just found to our
               shiplist. */
            city[n].store.prev=ship;
            ship->next=&city[n].store;
            ship=&city[n].store;
            ships++;
        }
    }
    shipsfound=finddockableships(x, y, shipspresent, shipnums);
    if (!shipsfound)
        return; /* Nothing to dock with! */
    /* If there's only one ship available to dock it, dock with it without any
       further questions */
    if (shipsfound==1)
    {
        shiptouse=shipspresent[0];
        if (n>=0)
        {
            ship=ship->prev;
            ship->next->prev=NULL;
            ship->next=NULL;
            ships--;
        }
    }
    else
    {
        createlist((struct List *)&SelectShip6List);
        for (i=0; i<shipsfound; i++)
            addnode(shipnums[i], shipspresent[i]->name,
                (struct List *)&SelectShip6List);
        shiptouse=selectship();
        if (n>=0)
        {
            ship=ship->prev;
            ship->next->prev=NULL;
            ship->next=NULL;
            ships--;
        }
        if (!shiptouse)
            return;
    }
    /* If we selected a real ship, dock with it. If we selected the "store" ship
       of some city, go to that city instead. */
    if (shiptouse->class<56)
    {
        /* This ship enters the selected ship's docks, causing the selected ship
           to be selected as our current ship instead. */
        for (i=0; shiptouse->carrying[i]; i++);
        shiptouse->carrying[i]=currentship;
        currentship->carriedby=shiptouse;
        select(shiptouse);
    }
    else
        if (n>=0)
            gotocity(n);
}

/* Opens the cargo trade window to allow the player to buy and sell cargo in the
   city. The price when selling to the city is always only 90% of the price when
   buying from the city. */
void tradecargo(UBYTE cn)
{
    cargonum=CargoGTags[3]=cn;
    CargoGTags[6]=(ULONG)currentship->name;
    CargoGTags[21]=(ULONG)currentcity->name;
    if (!OpenCargoWindow())
    {
        showcargostatus(currentship->cargo[cargonum], freespace(currentship),
            currentcity->price[cargonum], currentcity->supply[cargonum],
            currentcity->demand[cargonum]);
        while (HandleCargoIDCMP());
        CloseCargoWindow();
    }
}

/* Updates the status of the cargo window. Parameters: how much of this cargo we
   have on the ship, how much free space is there on the ship, how much does the
   cargo cost, how much is there left in the city, how much more does the city
   need. */
void showcargostatus(UWORD amount, UWORD space, UBYTE price, UWORD supply,
    UWORD demand)
{
    GT_SetGadgetAttrs(CargoGadgets[2], CargoWnd, NULL, GTNM_Number, amount,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[3], CargoWnd, NULL, GTNM_Number, space,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[5], CargoWnd, NULL, GTNM_Number, price,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[6], CargoWnd, NULL, GTNM_Number, supply,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[7], CargoWnd, NULL, GTNM_Number, demand,
        TAG_DONE);
}

/* Writes information about the cargo to the labels array, allowing it to be
   used in List1List, Items2List or Cargo3List. */
void makecargolist()
{
    struct ship *s;
    UBYTE i;
    if (InfoWnd)
        NewList(&List1List);
    if (TransferWnd)
    {
        NewList(&Items2List);
        s=shipa;
    }
    else
        s=currentship;
    for (i=0; i<13; i++)
    {
        if (i<12)
            sprintf(labels[i], "%14s %5d|%5d|%3d", CargoName4Labels[i],
                s->cargo[i], currentcity ? currentcity->supply[i] : 0,
                currentcity ? currentcity->price[i] : 0);
        else
            sprintf(labels[i], "Free space:    %5d", freespace(s));
        if (InfoWnd)
            AddTail(&List1List, &List1Nodes[i]);
        if (TransferWnd)
            AddTail(&Items2List, &List1Nodes[i]);
    }
}

/* Updates the cargo list and shows it on all relevant windows that are
   currently opened. */
void showcargolist()
{
    if (InfoWnd)
        GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
    if (CityWnd)
        GT_SetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
    if (currentship)
        makecargolist();
    else
    {
        NewList(&List1List);
        NewList(&Cargo3List);
    }
    if (InfoWnd)
        GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
            &List1List, TAG_DONE);
    if (CityWnd)
        GT_SetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Labels,
            &Cargo3List, TAG_DONE);
}

UBYTE getclasspic(UBYTE n)
{
    if (n<14)
        return 0;
    if (n<24)
        return 1;
    if (n<28)
        return 2;
    if (n<34)
        return 3;
    if (n<40)
        return 4;
    if (n<42)
        return 5;
    if (n<47)
        return 6;
    return 7;
}

void showshipclass(UBYTE n)
{
    BYTE i, found;
    GT_SetGadgetAttrs(BuyShipGadgets[0], BuyShipWnd, NULL, GTTX_Text,
        class[n].name, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[1], BuyShipWnd, NULL, GTNM_Number,
        class[n].weight, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[2], BuyShipWnd, NULL, GTNM_Number,
        class[n].maxcargo, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[3], BuyShipWnd, NULL, GTNM_Number,
        class[n].cabins, TAG_DONE);
    if (class[n].docks)
        sprintf(dockstring, "%d * %d kg", class[n].docks, class[n].docksize);
    else
        sprintf(dockstring, "None");
    GT_SetGadgetAttrs(BuyShipGadgets[4], BuyShipWnd, NULL, GTTX_Text,
        dockstring, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[5], BuyShipWnd, NULL, GTNM_Number,
        (240*class[n].engine)/class[n].weight, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[6], BuyShipWnd, NULL, GTNM_Number,
        class[n].price, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[7], BuyShipWnd, NULL, GTNM_Number, money,
        TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[8], BuyShipWnd, NULL, GA_Disabled,
        money<class[n].price, TAG_DONE);
    if (!n)
        GT_SetGadgetAttrs(BuyShipGadgets[9], BuyShipWnd, NULL, GA_Disabled,
            TRUE, TAG_DONE);
    else
    {
        found=FALSE;
        for (i=n-1; i>-1; i--)
            if (currentcity->shipsavailable[i])
            {
                found=TRUE;
                break;
            }
        GT_SetGadgetAttrs(BuyShipGadgets[9], BuyShipWnd, NULL, GA_Disabled,
            !found, TAG_DONE);
    }
    if (n==55)
        GT_SetGadgetAttrs(BuyShipGadgets[10], BuyShipWnd, NULL, GA_Disabled,
            TRUE, TAG_DONE);
    else
    {
        found=FALSE;
        for (i=n+1; i<56; i++)
            if (currentcity->shipsavailable[i])
            {
                found=TRUE;
                break;
            }
        GT_SetGadgetAttrs(BuyShipGadgets[10], BuyShipWnd, NULL, GA_Disabled,
            !found, TAG_DONE);
    }
    DrawImage(BuyShipWnd->RPort, shipimage[getclasspic(n)], 18, 17);
    ClipBlit(&hidden_rp, 0, 2*n, BuyShipWnd->RPort, 6, 57, 56, 2, 0xC0);
    shipclass=n;
}

UBYTE selectshipclass()
{
    UBYTE i, found;
    found=FALSE;
    for (i=0; i<56; i++)
        if (currentcity->shipsavailable[i])
        {
            found=TRUE;
            break;
        }
    if (!found)
    {
        request(CityWnd, error, "The city \"%s\" has no\nships left.",
            proceed, currentcity->name);
        return (UBYTE)~0;
    }
    selected=(UBYTE)~0;
    if (!OpenBuyShipWindow())
    {
        DrawImage(&hidden_rp, classimage, 0, 0);
        showshipclass(i);
        while (HandleBuyShipIDCMP());
        CloseBuyShipWindow();
    }
    return selected;
}

void showmap()
{
    UWORD x, y;
    getshiplocation(currentship, &x, &y);
    if (!OpenMapWindow())
    {
        citymap(MapWnd->RPort, x-17, y-17, 35, 35, 2, 1);
        GT_SetGadgetAttrs(MapGadgets[0], MapWnd, NULL, GTTX_Text, latitude,
            TAG_DONE);
        GT_SetGadgetAttrs(MapGadgets[1], MapWnd, NULL, GTTX_Text, longitude,
            TAG_DONE);
        while (HandleMapIDCMP());
        CloseMapWindow();
    }
}

void showtransferlist(UBYTE mode)
{
    GT_SetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    if (!mode)
        makecargolist();
    else
        createpersonlist(&Items2List, shipa, ~0);
    GT_SetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Labels,
        &Items2List, TAG_DONE);
    if (!mode)
        showtransfervalues(transfernum);
    else
        selectfirstperson();
    GT_SetGadgetAttrs(TransferGadgets[7], TransferWnd, NULL, GTNM_FrontPen,
        !mode, TAG_DONE);
    GT_SetGadgetAttrs(TransferGadgets[8], TransferWnd, NULL, GA_Disabled, mode,
        TAG_DONE);
}

void showtransfervalues(UBYTE n)
{
    GT_SetGadgetAttrs(TransferGadgets[2], TransferWnd, NULL, GTTX_Text,
        shipb->name, TAG_DONE);
    GT_SetGadgetAttrs(TransferGadgets[3], TransferWnd, NULL, GTNM_Number,
        freespace(shipb));
    GT_SetGadgetAttrs(TransferGadgets[7], TransferWnd, NULL, GTNM_Number,
        n!=~0 ? shipb->cargo[n] : 0);
}

void transfer(struct ship *firstship, struct ship *secondship)
{
    shipa=first=firstship; shipb=second=secondship;
    Ship2Labels[0]=first->name; Ship2Labels[1]=second->name;
    transfermode=0; transfernum=~0;
    if (!OpenTransferWindow())
    {
        showtransferlist(transfermode);
        showtransfervalues(transfernum);
        while (HandleTransferIDCMP());
        CloseTransferWindow();
    }
}

void selectfirstperson()
{
    UBYTE i;
    GT_SetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Selected, 0,
        TAG_DONE);
    for (i=5; i<7; i++)
        GT_SetGadgetAttrs(TransferGadgets[i], TransferWnd, NULL, GA_Disabled,
            !shippeople, TAG_DONE);
    if (shippeople)
        currentperson=findperson(shipa, 0, ~0);
}
void transfercargo(struct ship *a, struct ship *b)
{
    UBYTE message[56];
    if (!transfermode)
    {
        if (transfernum==~0)
            return;
        if (freespace(b)<howmuch)
        {
            sprintf(message, "%s hasn't got enough\nspace left! (Only %d)",
                b->name, freespace(b));
            request(TransferWnd, error, message, proceed, NULL);
            return;
        }
        if (a->cargo[transfernum]<howmuch)
        {
            sprintf(message, "%s hasn't got enough\nof it! (Only %d)", a->name,
                a->cargo[transfernum]);
            request(TransferWnd, error, message, proceed, NULL);
            return;
        }
        a->cargo[transfernum]-=howmuch; b->cargo[transfernum]+=howmuch;
        showtransferlist(0);
    }
    else
    {
        if (shipb->crew + shipb->passengers == class[shipb->class].cabins)
        {
            request(TransferWnd, error, "%s has no free cabins!", proceed,
                shipb->name);
            return;
        }
        currentperson->location=shipb;
        if (gettype(currentperson)==CREW)
        {
            shipa->crew--; shipb->crew++;
        }
        else
        {
            shipa->passengers--; shipb->passengers++;
        }
        showtransferlist(1);
        selectfirstperson();
    }
}

void viewpeople(UBYTE mode)
{
    peoplemode=mode;
    PeopleGTags[1]=(ULONG)currentship->name;
    PeopleGTags[11]=(ULONG)currentcity->name;
    createpersonlist(&ShipList8List, currentship, mode?TOURIST:CREW);
    createpersonlist(&CityList8List, currentcity, mode?TOURIST:CREW);
    if (!OpenPeopleWindow())
    {
        cleartext();
        showtext();
        while (HandlePeopleIDCMP());
        ClosePeopleWindow();
    }
}

void addword(STRPTR line, UBYTE i, UBYTE l)
{
    if (textx >= 36-l)
    {
        texty++;
        textx=0;
    }
    CopyMem(line+(i-l), text[texty]+textx, l);
    textx+=l;
    if (textx<35)
    {
        text[texty][textx]=' ';
        textx++;
        text[texty][textx]='\0';
    }
    else
    {
        text[texty][textx]='\0';
        texty++;
        textx=0;
    }
}

void addtext(STRPTR line)
{
    UBYTE i, l;
    l=0;
    for (i=0; line[i]; i++)
        if (line[i]==' ')
        {
            addword(line, i, l);
            l=0;
        }
        else
            l++;
    addword(line, i, l);
}

void cleartext()
{
    UBYTE i;
    textx=texty=0;
    for (i=0; i<4; i++)
        text[i][0]='\0';
}

void showtext()
{
    UBYTE i;
    for (i=0; i<4; i++)
        GT_SetGadgetAttrs(PeopleGadgets[i+5], PeopleWnd, NULL, GTTX_Text,
            text[i], TAG_DONE);
}

void savegame(UBYTE *filename)
{
    BPTR file;
    UBYTE *buffer;
    struct ship *s, *shipbegin;
    struct person *p, *personbegin;
    ULONG size;
    UWORD i, j, a;
    UBYTE b;
    if (file=Open(filename, MODE_OLDFILE))
    {
        Close(file);
        if (!request(SeaTradeWnd, "Confirmation", "The file\n\"%s\"\nalready "
            "exists. Overwrite?", "Yes|No", filename))
            return;
    }
    size = 13648 + ships*sizeof(struct ship) + persons*sizeof(struct person);
    if (!(buffer=AllocVec(size, MEMF_CLEAR)))
    {
        request(SeaTradeWnd, error, "Not enough memory for temporary buffer.",
            proceed, NULL);
        return;
    }
    shipbegin = (struct ship *)(buffer+13648); personbegin = (struct person *)
        (buffer+13648 + ships*sizeof(struct ship));
    if (!(file=Open(filename, MODE_NEWFILE)))
    {
        FreeVec(buffer);
        request(SeaTradeWnd, error, "Could not open file\n\"%s\".", proceed,
            filename);
        return;
    }
    *(ULONG *)buffer=0x25101976; /* My birthday! */
    *(ULONG *)(buffer+8)=gametime;
    *(ULONG *)(buffer+12)=money;
    *(double *)(buffer+16)=slowest;
    *(double *)(buffer+24)=increment;
    *(WORD *)(buffer+32)=mapleft;
    *(WORD *)(buffer+34)=maptop;
    *(UWORD *)(buffer+36)=ships;
    *(UWORD *)(buffer+40)=persons;
    *(UWORD *)(buffer+42)=namesleft;
    for (i=0; i<namesleft; i++)
    {
        a=namesavailable[i]/8; b=namesavailable[i]&7;
        buffer[48+a]|=(1<<b);
    }
    for (i=0; i<64; i++)
    {
        for (j=0; j<56; j++)
            buffer[848+i*200+j]=city[i].shipsavailable[j];
        for (j=0; j<12; j++)
        {
            ((UWORD *)(buffer+904+i*200))[j]=city[i].supply[j];
            ((UWORD *)(buffer+928+i*200))[j]=city[i].supply[j];
        }
        CopyMem(&city[i].store, buffer+952+i*200, sizeof(struct ship));
    }
    /* Write the list of the ships as a consecutive array of ships. Since the
       pointers "carrying" and "carriedby" lose their meaning when written to
       the file, we must first enumerate each ship in the list, and then replace
       each pointer by the number we gave the ship it points to. This requires
       two passes over the list, but Amigas should be fast enough to handle
       that. */
    i=1; /* Serial numbers start at 1 instead of 0, since 0 is also a null
            pointer */
    for (s=shiplist; s; s=s->next)
        s->serialnumber=i++;
    *(UWORD *)(buffer+38)=currentship->serialnumber;
    i=0;
    for (s=shiplist; s; s=s->next, i++)
    {
        CopyMem(s, shipbegin+i, sizeof(struct ship));
        for (j=0; j<3; j++)
            if (s->carrying[j])
                shipbegin[i].carrying[j]=(struct ship *)s->carrying[j]->
                    serialnumber;
        if (s->carriedby)
            shipbegin[i].carriedby=(struct ship *)s->carriedby->serialnumber;
    }
    i=0;
    for (p=personlist; p; p=p->next, i++)
    {
        if (getloc(p)>=64)
            setloc(p, 63+((struct ship *)p->location)->serialnumber);
        CopyMem(p, personbegin+i, sizeof(struct person));
    }
    Write(file, buffer, size);
    Close(file);
    FreeVec(buffer);
}

UBYTE loadgame(STRPTR filename)
{
    BPTR file;
    UBYTE *buffer;
    ULONG size;
    UWORD numships, numpersons, i, j, a;
    UBYTE b;
    struct ship **shippointers;
    struct ship *shiparray, *s;
    struct person *personarray, *p;
    if (!(file=Open(filename, MODE_OLDFILE)))
    {
        request(SeaTradeWnd, error, "The file\n\"%s\"\ndoes not exist.",
            proceed, filename);
        return FALSE;
    }
    size=sizeoffile(file);
    if (!(buffer=AllocVec(size, MEMF_CLEAR)))
    {
        Close(file);
        request(SeaTradeWnd, error, "Not enough memory for temporary buffer.",
            proceed, NULL);
        return FALSE;
    }
    Read(file, buffer, size);
    Close(file);
    if (*(ULONG *)buffer!=0x25101976)
    {
        FreeVec(buffer);
        request(SeaTradeWnd, error, "This is not a Sea Trade saved game.",
            proceed, NULL);
        return FALSE;
    }
    setdate(*(ULONG *)(buffer+8));
    setmoney(*(ULONG *)(buffer+12));
    slowest=*(double *)(buffer+16);
    increment=*(double *)(buffer+24);
    mapleft=*(UWORD *)(buffer+32);
    maptop=*(UWORD *)(buffer+34);
    numships=*(UWORD *)(buffer+36);
    numpersons=*(UWORD *)(buffer+40);
    namesleft=*(UWORD *)(buffer+42);
    j=0;
    for (i=0; i<6400; i++)
    {
        a=i/8; b=i&7;
        if (buffer[48+a]&(1<<b))
        {
            namesavailable[j]=i;
            j++;
        }
    }
    for (i=0; i<64; i++)
    {
        for (j=0; j<56; j++)
            city[i].shipsavailable[j]=buffer[848+i*200+j];
        for (j=0; j<12; j++)
        {
            city[i].supply[j]=((UWORD *)(buffer+904+i*200))[j];
            city[i].demand[j]=((UWORD *)(buffer+928+i*200))[j];
        }
        CopyMem(buffer+952+i*200, &city[i].store, sizeof(struct ship));
    }
    shiparray=(struct ship *)(buffer+13648);
    shippointers=AllocVec(ships*sizeof(struct ship *), MEMF_CLEAR);
    for (i=0; i<numships; i++)
    {
        if (s=createship(shiparray[i].name, shiparray[i].class))
        {
            for (j=0; j<3; j++)
                s->location[j]=shiparray[i].location[j];
            s->flags=shiparray[i].flags;
            for (j=0; j<12; j++)
                s->cargo[j]=shiparray[i].cargo[j];
            s->crew=shiparray[i].crew;
            s->passengers=shiparray[i].passengers;
            s->moves=shiparray[i].moves;
            s->serialnumber=shiparray[i].serialnumber;
            shippointers[i]=s;
        }
    }
    for (s=shiplist; s; s=s->next)
    {
        for (i=0; i<3; i++)
            if (s->carrying[i])
                s->carrying[i]=shippointers[(ULONG)(s->carrying[i])-1];
        if (s->carriedby)
            s->carriedby=shippointers[(ULONG)(s->carriedby)-1];
    }
    currentship=shippointers[*(UWORD *)(buffer+38)-1];
    personarray=(struct person *)(buffer+13648+ships*sizeof(struct ship));
    for (i=0; i<numpersons; i++)
    {
        if (p=AllocVec(sizeof(struct person), MEMF_CLEAR))
        {
            CopyMem(personarray[i], p, sizeof(struct person));
            if (getloc(p)>=64)
                p->location=shippointers[getloc(p)-64];
            else
                p->location=&city[getloc(p)];
            addperson(p);
        }
    }
    FreeVec(shippointers);
    FreeVec(buffer);
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected,
        currentship->serialnumber-1, TAG_DONE);
    setshipmoves(currentship->moves);
    setshipfuel(currentship->cargo[10]);
    setshipfood(currentship->cargo[11]);
    drawmap(mapleft, maptop);
    return TRUE;
}

void newgame()
{
    struct person *firstperson;
    UWORD i, j;
    for (i=0; i<64; i++)
    {
        for (j=0; j<12; j++)
        {
            city[i].supply[j]=1023;
            city[i].demand[j]=255;
        }
        for (j=0; j<14; j++)
            city[i].shipsavailable[city[i].shipsmade[j]]=1;
        city[i].store.class=56;
        sprintf(city[i].store.name, "\AB%s\BB", city[i].name);
        city[i].store.next=city[i].store.prev=NULL;
        for (j=0; j<3; j++)
            city[i].store.location[j]=city[i].location[j];
    }
    shiplist=ship=NULL;
    personlist=person=NULL;
    for (i=0; i<6400; i++)
        namesavailable[i]=i;
    for (i=0; i<96; i++)
    {
        createpassenger();
        createcrew();
    }
    setdate(0); setmoney(500000);
    clearcitydiffs();
    currentship=createship("Spider", 0);
    firstperson=createperson(25, 0, (struct city *)currentship, 0);
    if (firstperson)
    {
        addperson(firstperson);
        settype(firstperson, CREW);
        setloc(firstperson, 64);
    }
    currentship->crew=1;
    setshiplocation(currentship, 405, 405);
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected, 0,
        TAG_DONE);
    setshipmoves(4.0);
    setshipfuel(100);
    setshipfood(20);
    findslowest();
    increment=60.0/slowest;
    mapleft=400; maptop=400;
    drawmap(mapleft, maptop);
}

int SeaTradeRawKey()
{
    switch (SeaTradeMsg.Code)
    {
        case 0xBD:
        moveship(-1, -1);
        break;
        case 0xBE:
        case 0xCC:
        moveship(0, -1);
        break;
        case 0xBF:
        moveship(1, -1);
        break;
        case 0xAD:
        case 0xCF:
        moveship(-1, 0);
        break;
        case 0xAE:
        CenterClicked();
        break;
        case 0xAF:
        case 0xCE:
        moveship(1, 0);
        break;
        case 0x9D:
        moveship(-1, 1);
        break;
        case 0x9E:
        case 0xCD:
        moveship(0, 1);
        break;
        case 0x9F:
        moveship(1, 1);
        break;
        case 0xA2:
        return DockClicked();
        break;
        case 0x97:
        return InfoClicked();
        break;
        case 0xB7:
        showmap();
        break;
        case 0xC0:
        setshipmoves(0.0);
        checkships();
        break;
    }
    return TRUE;
}
int ULClicked()
{
    moveship(-1, -1);
    return TRUE;
}
int UClicked()
{
    moveship(0, -1);
    return TRUE;
}
int URClicked()
{
    moveship(1, -1);
    return TRUE;
}
int LClicked()
{
    moveship(-1, 0);
    return TRUE;
}
int CenterClicked()
{
    UBYTE oldautocenter;
    oldautocenter=autocenter;
    setautocenter(2);
    setautocenter(oldautocenter);
    return TRUE;
}
int RClicked()
{
    moveship(1, 0);
    return TRUE;
}
int DLClicked()
{
    moveship(-1, 1);
    return TRUE;
}
int DClicked()
{
    moveship(0, 1);
    return TRUE;
}
int DRClicked()
{
    moveship(1, 1);
    return TRUE;
}
int InfoClicked()
{
    info(currentship);
    return TRUE;
}
int DockClicked()
{
    dock();
    return TRUE;
}
int ShipsClicked()
{
    struct ship *s;
    ULONG n, i;
    GT_GetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected, &n,
        TAG_DONE);
    s=shiplist;
    for (i=0; i<n; i++)
        s=s->next;
    if (s!=currentship)
        select(s);
    return TRUE;
}
int SeaTradeSave()
{
    UBYTE filename[32];
    if (aslreq(TRUE, filename))
        savegame(filename);
    return TRUE;
}
int SeaTradeAbout()
{ return TRUE; }
int SeaTradeQuit()
{
    if (logfile)
        Close(logfile);
    return FALSE;
}
int SeaTradeNext()
{
    struct ship *s;
    if (!skipflag)
        s=currentship->next;
    else
    {
        for (s=currentship->next; s && s->moves>=1.0; s=s->next);
        if (!s)
        {
            request(SeaTradeWnd, error, "Could not find a next ship.", proceed,
                NULL);
            return TRUE;
        }
    }
    select(s);
    return TRUE;
}
int SeaTradePrevious()
{
    struct ship *s;
    if (!skipflag)
        s=currentship->prev;
    else
    {
        for (s=currentship->prev; s && s->moves>=1.0; s=s->prev);
        if (!s)
        {
            request(SeaTradeWnd, error, "Could not find a previous ship.",
                proceed, NULL);
            return TRUE;
        }
    }
    select(s);
    return TRUE;
}
int SeaTradeReleaseall()
{
    UBYTE i;
    for (i=0; i<3 && currentship->carrying[i]; i++)
    {
        currentship->carrying[i]->carriedby=NULL;
        currentship->carrying[i]=NULL;
    }
    submenuonoff(1, 3, 0, FALSE);
    submenuonoff(1, 3, 1, FALSE);
    return TRUE;
}
int SeaTradeReleaseselect()
{
    struct ship *s;
    UBYTE i, j;
    if (!currentship->carrying[1])
        return SeaTradeReleaseall();
    createlist((struct List *)&SelectShip6List);
    i=0;
    for (s=shiplist; s; s=s->next)
    {
        if (s==currentship->carrying[0] ||
            s==currentship->carrying[1] ||
            s==currentship->carrying[2])
            addnode(i, s->name, (struct List *)&SelectShip6List);
        i++;
    }
    s=selectship();
    if (!s)
        return TRUE;
    for (i=0; i<3 && s!=currentship->carrying[i]; i++);
    s->carriedby=NULL;
    for (j=i; j<3; j++)
        if (j==2)
            currentship->carrying[j]=NULL;
        else
            currentship->carrying[j]=currentship->carrying[j+1];
    if (!currentship->carrying[0])
    {
        submenuonoff(1, 3, 0, FALSE);
        submenuonoff(1, 3, 1, FALSE);
    }
    return TRUE;
}
int SeaTradeNone()
{
    setautocenter(0);
    return TRUE;
}
int SeaTradeOffline()
{
    setautocenter(1);
    return TRUE;
}
int SeaTradeOnline()
{
    setautocenter(2);
    return TRUE;
}
int SeaTradeSkip()
{
    struct MenuItem *n;
    n=ItemAddress(SeaTradeMenus, FULLMENUNUM(0, 1, NOSUB));
    skipflag=(n->Flags&CHECKED)/CHECKED;
    return TRUE;
}
int SeaTradeAlarms()
{ return TRUE; }
int SeaTradeLog()
{
    APTR file;
    UBYTE filename[32];
    UBYTE response=2;
    if (aslreq(2, filename))
    {
        file=Open(filename, MODE_OLDFILE);
        if (file)
        {
            Close(file);
            response=request(SeaTradeWnd, "Request",
                "File \"%s\" already\nexists. What should I do?",
                "Append|Overwrite|Cancel", filename);
            if (!response)
                return TRUE;
        }
        if (logfile)
        {
            Close(logfile);
            logfile=NULL;
        }
        if (response==1)
        {
            file=Open(filename, MODE_READWRITE);
            if (file)
                Seek(file, 0, OFFSET_END);
        }
        else
            file=Open(filename, MODE_NEWFILE);
        if (!file)
            request(SeaTradeWnd, error, "Error opening file\n\"%s\".", proceed,
                filename);
        else
            logfile=file;
        menuonoff(2, 4, !!file);
    }
    return TRUE;
}
int SeaTradeCloseLog()
{
    if (logfile)
        Close(logfile);
    logfile=NULL;
    menuonoff(2, 4, FALSE);
    return TRUE;
}

int NameClicked()
{
    ULONG name;
    GT_GetGadgetAttrs(InfoGadgets[0], InfoWnd, NULL, GTST_String, &name,
        TAG_DONE);
    renameship(currentship, (STRPTR)name);
    sprintf(InfoWdt, "Info for ship \"%s\"", name);
    SetWindowTitles(InfoWnd, InfoWdt, Sct);
    return TRUE;
}
int ListClicked()
{
    UBYTE message[97], dstr[21], lat[8], lon[8];
    ULONG which;
    UWORD x, y;
    if (infomode)
    {
        GT_GetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Selected, &which,
            TAG_DONE);
        if (which<shippeople)
        {
            currentperson=findperson(currentship, which, ~0);
            getcitylocation(&city[currentperson->destination], &x, &y);
            coordinatestrings(lat, lon, x, y);
            switch (gettype(currentperson))
            {
                case CREW:
                sprintf(message, "Type: crew member\nDaily salary: %d",
                    currentperson->pay & 0x3FF);
                break;
                case TOURIST:
                case PASSENGER:
                datestring(dstr, currentperson->deadline);
                sprintf(message, "Type: passenger\nDestination: %s\n(%s %s)\n"
                    "Deadline:\n%s\nPay: %d", city[currentperson->destination].
                    name, lat, lon, dstr, currentperson->pay & 0x3FF);
                break;
                case FAILED:
                sprintf(message, "Type: passenger\nDestination: %s\n(%s %s)\n"
                    "Deadline:\n*EXPIRED*", city[currentperson->destination].
                    name, lat, lon);
                break;
            }
            request(InfoWnd, currentperson->name, message, proceed, NULL);
        }
    }
    return TRUE;
}
int DockedClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(InfoGadgets[3], InfoWnd, NULL, GTLV_Selected, &which,
        TAG_DONE);
    if (which==~0)
        currentdockedship=-1;
    else
        currentdockedship=which;
    return TRUE;
}
int ViewClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(InfoGadgets[4], InfoWnd, NULL, GTCY_Active, &which,
        TAG_DONE);
    if (which!=infomode)
    {
        infomode=which;
        showinfo(infomode);
    }
    return TRUE;
}
int TransferClicked()
{
    if (currentdockedship==-1)
        return TRUE;
    transfer(currentship, currentship->carrying[currentdockedship]);
    return TRUE;
}
int ReleaseClicked()
{
    struct ship *releasedship;
    UBYTE i;
    if (currentdockedship==-1)
        return TRUE;
    /* Mark the ship being released as free of any carrying ship */
    releasedship=currentship->carrying[currentdockedship];
    releasedship->carriedby=NULL;
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(InfoGadgets[3], InfoWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    Remove(&dockednodes[currentdockedship]);
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(InfoGadgets[3], InfoWnd, NULL, GTLV_Labels, &Docked1List,
        TAG_DONE);
    /* Update both the dockednodes array and the current ship's carrying list to
       mark that it is no longer carrying the ship we just released */
    for (i=currentdockedship; i<3; i++)
        if (i==2)
            currentship->carrying[i]=NULL;
        else
        {
            currentship->carrying[i]=currentship->carrying[i+1];
            dockednodes[i].ln_Name=dockednodes[i+1].ln_Name;
        }
    return TRUE;
}
int InfoCloseWindow()
{
    return FALSE;
}

int TransferCloseWindow()
{
    return FALSE;
}
int ModeClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(TransferGadgets[0], TransferWnd, NULL, GTCY_Active,
        &which, TAG_DONE);
    if (which!=transfermode)
    {
        transfermode=which;
        showtransferlist(transfermode);
    }
    return TRUE;
}
int ItemsClicked()
{
    ULONG n;
    UBYTE i;
    GT_GetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Selected,
        &n, TAG_DONE);
    if (!transfermode)
    {
        transfernum=(UBYTE)n;
        showtransfervalues(transfernum);
    }
    else
    {
        for (i=5; i<7; i++)
            GT_SetGadgetAttrs(TransferGadgets[i], TransferWnd, NULL,
                GA_Disabled, n>=shippeople, TAG_DONE);
        if (n<shippeople)
            currentperson=findperson(shipa, n, ~0);
    }
    return TRUE;
}
int ShipClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(TransferGadgets[4], TransferWnd, NULL, GTCY_Active,
        &which, TAG_DONE);
    if (!which)
        if (first!=shipa)
        {
            shipa=first; shipb=second;
            showtransferlist(transfermode);
        }
        else;
    else
        if (first==shipa)
        {
            shipb=first; shipa=second;
            showtransferlist(transfermode);
        }
    return TRUE;
}
int TransferOtherClicked()
{
    transfercargo(shipa, shipb);
    return TRUE;
}
int TransferThisClicked()
{
    transfercargo(shipb, shipa);
    return TRUE;
}
int HowMuchClicked()
{
    ULONG hm;
    GT_GetGadgetAttrs(TransferGadgets[8], TransferWnd, NULL, GTIN_Number, &hm,
        TAG_DONE);
    if (hm>65535)
    {
        hm=0;
        GT_SetGadgetAttrs(TransferGadgets[8], TransferWnd, NULL, GTIN_Number,
            0, TAG_DONE);
    }
    howmuch=hm;
    return TRUE;
}

int SelectClicked()
{
    struct ship *s;
    UWORD i;
    i=0;
    createlist((struct List *)&SelectShip6List);
    for (s=shiplist; s; s=s->next)
        if (s->location[0]==currentcity->location[0] &&
            s->location[1]==currentcity->location[1] &&
            s->location[2]==currentcity->location[2])
            addnode(i++, s->name, (struct List *)&SelectShip6List);
    s=selectship();
    if (s!=currentship)
    {
        currentship=s;
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text, s->name,
            TAG_DONE);
        showcargolist();
    }
    GT_SetGadgetAttrs(CityGadgets[6], CityWnd, NULL, GA_Disabled,
        s==&currentcity->store, TAG_DONE);
    return TRUE;
}

int SellClicked()
{
    struct person *p;
    UBYTE message[80];
    UWORD amount;
    UBYTE i;
    sprintf(message, "Selling your %s\nwill pay you %d.\nReally sell it?",
        class[currentship->class].name, (class[currentship->class].price*9)/10);
    if (request(CityWnd, "Confirmation", message, "Yes|No", NULL))
    {
        sprintf(message, ": The class %s ship \"%s\" was sold to %s.\n",
            class[currentship->class].name, currentship->name,
            currentcity->name);
        writelogdate();
        writelog(message);
        /* Try to find a suitable storing place for the cargo on this ship. */
        for (i=0; i<12; i++)
        {
            if (freespace(&currentcity->store) >= currentship->cargo[i])
                /* It fits in the city's storehouse, put it there */
                currentcity->store.cargo[i]+=currentship->cargo[i];
            else
            {
                /* It doesn't fit entirely in the city's storehouse, put as
                   much as possible there, then sell as much as possible, dump
                   the rest */
                currentship->cargo[i]-=freespace(&currentcity->store);
                currentcity->store.cargo[i]+=freespace(&currentcity->store);
                amount=currentcity->demand[i]<currentship->cargo[i] ?
                    currentcity->demand[i] : currentship->cargo[i];
                currentcity->supply[i]+=amount; currentcity->demand[i]-=amount;
                setmoney(money + (amount*currentcity->price[i]*9)/10);
            }
        }
        /* Put all the people onboard the current ship into the city's
           storehouse. BUG: Putting more than 255 crew members or more than 255
           passengers into the storehouse will cause undefined behaviour! Not
           that that is very likely to happen... */
        for (p=personlist; p; p=p->next)
            if (p->location==currentship)
            {
                p->location=&currentcity->store;
                if (gettype(p)==CREW)
                    currentcity->store.crew++;
                else
                    currentcity->store.passengers++;
            }
        currentcity->shipsavailable[currentship->class]++;
        setmoney(money + (class[currentship->class].price*9)/10);
        deleteship(currentship);
        currentship=&currentcity->store;
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text,
            currentship->name, TAG_DONE);
        showcargolist();
        GT_SetGadgetAttrs(CityGadgets[6], CityWnd, NULL, GA_Disabled, TRUE,
            TAG_DONE);
        showcargolist();
    }
    return TRUE;
}
int BuyClicked()
{
    UBYTE message[80];
    UBYTE n;
    n=selectshipclass();
    if (n!=~0)
    {
        currentcity->shipsavailable[n]--;
        setmoney(money-class[n].price);
        ship=ship->prev; ship->next=NULL;
        currentship=createship(class[n].name, n);
        sprintf(message, ": A new %s class ship was bought from %s.\n",
            class[n].name, currentcity->name);
        writelogdate();
        writelog(message);
        setshipmoves(speed(currentship)/(15.0*increment));
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text,
            currentship->name, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[6], CityWnd, NULL, GA_Disabled, FALSE,
            TAG_DONE);
        CopyMem(currentcity->location, currentship->location, 3);
        showcargolist();
        findslowest();
        setshipmoves(4.0*speed(currentship)/slowest);
        ship->next=&currentcity->store; currentcity->store.prev=ship;
        ship=&currentcity->store;
    }
    return TRUE;
}
int CargoClicked()
{ return TRUE; }
int ViewCrewClicked()
{
    viewpeople(0);
    return TRUE;
}
int ViewPassengersClicked()
{
    viewpeople(1);
    return TRUE;
}
int ExitClicked()
{
    return FALSE;
}
int BuySellClicked()
{
    ULONG cn;
    if (!currentship)
        return;
    GT_GetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Selected, &cn,
        TAG_DONE);
    if (cn!=~0 && cn<12)
        tradecargo(cn);
    else
        tradecargo(0);
    return TRUE;
}
int CityTransferClicked()
{
    struct ship *s;
    UWORD i;
    i=0;
    createlist((struct List *)&SelectShip6List);
    for (s=shiplist; s; s=s->next)
        if (s->location[0]==currentcity->location[0] &&
            s->location[1]==currentcity->location[1] &&
            s->location[2]==currentcity->location[2])
            addnode(i++, s->name, (struct List *)&SelectShip6List);
    s=selectship();
    if (s)
        transfer(currentship, s);
    return TRUE;
}

int CargoNameClicked()
{
    ULONG cn;
    GT_GetGadgetAttrs(CargoGadgets[0], CargoWnd, NULL, GTCY_Active, &cn,
        TAG_DONE);
    cargonum=cn;
    showcargostatus(currentship->cargo[cargonum], freespace(currentship),
        currentcity->price[cargonum], currentcity->supply[cargonum],
        currentcity->demand[cargonum]);
    return TRUE;
}
int CargoHowMuchClicked()
{
    ULONG hm;
    GT_GetGadgetAttrs(CargoGadgets[8], CargoWnd, NULL, GTIN_Number, &hm,
        TAG_DONE);
    if (hm>65535)
    {
        hm=0;
        GT_SetGadgetAttrs(CargoGadgets[8], CargoWnd, NULL, GTIN_Number, 0,
            TAG_DONE);
    }
    howmuch=hm;
    return TRUE;
}
int CargoBuyClicked()
{
    UBYTE number[11];
    if (money < howmuch*currentcity->price[cargonum])
    {
        sprintf(number, "%d", money);
        request(CargoWnd, error, "You haven't got enough money\n(Only %s)",
            proceed, number);
        return TRUE;
    }
    if (freespace(currentship) < howmuch)
    {
        sprintf(number, "%d", freespace(currentship));
        request(CargoWnd, error, "You haven't got enough space\nfor it "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    if ((ULONG)currentship->cargo[cargonum]+(ULONG)howmuch > 65535)
    {
        sprintf(number, "%d", 65535-currentship->cargo[cargonum]);
        request(CargoWnd, error, "You can't fit enough of that\ncargo "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    if (currentcity->supply[cargonum] < howmuch)
    {
        sprintf(number, "%d", currentcity->supply[cargonum]);
        request(CargoWnd, error, "The city's supply is not large\nenough "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    setmoney(money-howmuch*currentcity->price[cargonum]);
    currentship->cargo[cargonum]+=howmuch;
    currentcity->supply[cargonum]-=howmuch;
    currentcity->demand[cargonum]+=howmuch;
    citydiff[cityn][cargonum]+=howmuch;
    showcargostatus(currentship->cargo[cargonum], freespace(currentship),
        currentcity->price[cargonum], currentcity->supply[cargonum],
        currentcity->demand[cargonum]);
    showcargolist();
    return TRUE;
}
int CargoSellClicked()
{
    UBYTE number[6];
    if (currentship->cargo[cargonum] < howmuch)
    {
        sprintf(number, "%d", currentship->cargo[cargonum]);
        request(CargoWnd, error, "You haven't got enough cargo\n"
            "(Only %s)", proceed, number);
        return TRUE;
    }
    if (currentcity->demand[cargonum] < howmuch)
    {
        sprintf(number, "%d", currentcity->demand[cargonum]);
        request(CargoWnd, error, "The city's demand is not large\nenough "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    /* Selling price is always only 90% of buying price! Taxes, you know. */
    setmoney(money + ((howmuch*currentcity->price[cargonum])*9)/10);
    currentship->cargo[cargonum]-=howmuch;
    currentcity->supply[cargonum]+=howmuch;
    currentcity->demand[cargonum]-=howmuch;
    citydiff[cityn][cargonum]-=howmuch;
    showcargostatus(currentship->cargo[cargonum], freespace(currentship),
        currentcity->price[cargonum], currentcity->supply[cargonum],
        currentcity->demand[cargonum]);
    showcargolist();
    return TRUE;
}
int CargoCloseWindow()
{
    return FALSE;
}

int ShipBuyClicked()
{
    UBYTE message[79];
    sprintf(message,
        "A new %s costs %d.\nMoney left: %d\nAre you sure to buy it?",
        class[shipclass].name, class[shipclass].price, money);
    if (request(BuyShipWnd, "Confirmation", message, "Yes|No", NULL))
    {
        selected=shipclass;
        return FALSE;
    }
    return TRUE;
}
int PreviousClicked()
{
    UBYTE i;
    for (i=shipclass-1; !currentcity->shipsavailable[i]; i--);
    showshipclass(i);
    return TRUE;
}
int NextClicked()
{
    UBYTE i;
    for (i=shipclass+1; !currentcity->shipsavailable[i]; i++);
    showshipclass(i);
    return TRUE;
}
int BuyShipCloseWindow()
{
    return FALSE;
}

int SelectShipClicked()
{
    ULONG number;
    GT_GetGadgetAttrs(SelectGadgets[0], SelectWnd, NULL, GTLV_Selected, &number,
        TAG_DONE);
    selected=number;
    return FALSE;
}
int SelectCloseWindow()
{
    return FALSE;
}

int MapCloseWindow()
{
    return FALSE;
}
int MapMouseButtons()
{
    UBYTE lat[8], lon[8];
    UWORD x, y, shipx, shipy;
    UBYTE code, px, py;
    code=MapMsg.Code;
    x=MapMsg.MouseX-MapWnd->BorderLeft; y=MapMsg.MouseY-MapWnd->BorderTop;
    if (code&128)
        return TRUE;
    if (x<2 || y<1 || x>71 || y>70)
        return TRUE;
    px=(x-2)/2; py=(y-1)/2;
    getshiplocation(currentship, &shipx, &shipy);
    coordinatestrings(lat, lon, shipx-17+px, shipy-17+py);
    GT_SetGadgetAttrs(MapGadgets[0], MapWnd, NULL, GTTX_Text, lat, TAG_DONE);
    GT_SetGadgetAttrs(MapGadgets[1], MapWnd, NULL, GTTX_Text, lon, TAG_DONE);
    return TRUE;
}
int MapRawKey()
{
    return MapMsg.Code!=0xB7;
}

int PeopleCloseWindow()
{
    return FALSE;
}

int ShipListClicked()
{
    UBYTE message[45];
    LONG sel;
    GT_GetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected, &sel,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected, ~0,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[4], PeopleWnd, NULL, GA_Disabled,
        sel>=shippeople, TAG_DONE);
    if (sel<shippeople)
    {
        currentperson=findperson(currentship, sel, peoplemode?TOURIST:CREW);
        showperson(currentperson);
    }
    else
    {
        sprintf(message, "Your ship \"%s\" has %2d free cabins.",
            currentship->name, class[currentship->class].cabins-
            currentship->crew-currentship->passengers);
        cleartext();
        addtext(message);
        showtext();
        currentperson=NULL;
    }
    return TRUE;
}
int CityListClicked()
{
    LONG sel;
    GT_GetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected, &sel,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected, ~0,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[4], PeopleWnd, NULL, GA_Disabled, FALSE,
        TAG_DONE);
    currentperson=findperson(currentcity, sel, peoplemode?TOURIST:CREW);
    showperson(currentperson);
    return TRUE;
}
int MoveClicked()
{
    UBYTE moved=FALSE;
    if (!currentperson)
        return TRUE;
    if (currentperson->location==currentship)
        if (gettype(currentperson)==PASSENGER)
            request(PeopleWnd, error, "You have a contract\nwith %s!", proceed,
                currentperson->name);
        else
        {
            currentperson->location=currentcity;
            if (gettype(currentperson)==CREW)
                currentship->crew--;
            else
            {
                currentship->passengers--;
                settype(currentperson, TOURIST);
            }
            setloc(currentperson, cityn);
            moved=TRUE;
        }
    else
    {
        if (class[currentship->class].cabins == currentship->crew +
            currentship->passengers)
        request(PeopleWnd, error, "You have no free cabins left!", proceed,
            NULL);
        else
        {
            currentperson->location=currentship;
            if (gettype(currentperson)==CREW)
                currentship->crew++;
            else
                currentship->passengers++;
            setloc(currentperson, 64);
            moved=TRUE;
        }
    }
    if (moved)
    {
        GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
        GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
        createpersonlist(&ShipList8List, currentship, peoplemode?TOURIST:CREW);
        createpersonlist(&CityList8List, currentcity, peoplemode?TOURIST:CREW);
        GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Labels,
            &ShipList8List, TAG_DONE);
        GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Labels,
            &CityList8List, TAG_DONE);
        if (currentperson->location==currentship)
        {
            GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected,
                rfindperson(currentship, currentperson,
                gettype(currentperson)), TAG_DONE);
            GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected,
                ~0, TAG_DONE);
        }
        else
        {
            GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected,
                rfindperson(currentcity, currentperson,
                gettype(currentperson)), TAG_DONE);
            GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected,
                ~0, TAG_DONE);
        }
    }
    return TRUE;
}

int main(int argc, char *argv[])
{
    if (!SetupScreen())
    {
        if (loadgraphics() && loadpalette() && allocstuff())
        {
            if (!OpenSeaTradeWindow())
            {
                if (argc<2 || !loadgame(argv[1]))
                    newgame();
                while (HandleSeaTradeIDCMP());
                CloseSeaTradeWindow();
            }
            cleanup();
        }
        CloseDownScreen();
    }
    return 0;
}
