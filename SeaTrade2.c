/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : JIPsoft (Joona I Palaste)
 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <libraries/dos.h>
#include <libraries/asl.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#include "SeaTrade.h"

extern struct Image *panelimage, *citypanelimage, *shipviewimage;

struct Screen         *Scr = NULL;
APTR                   VisualInfo = NULL;
struct Window         *SeaTradeWnd = NULL;
struct Window         *InfoWnd = NULL;
struct Window         *TransferWnd = NULL;
struct Window         *CityWnd = NULL;
struct Window         *CargoWnd = NULL;
struct Window         *BuyShipWnd = NULL;
struct Window         *SelectWnd = NULL;
struct Window         *MapWnd = NULL;
struct Window         *PeopleWnd = NULL;
struct Window         *AutopilotWnd = NULL;
struct Gadget         *SeaTradeGList = NULL;
struct Gadget         *InfoGList = NULL;
struct Gadget         *TransferGList = NULL;
struct Gadget         *CityGList = NULL;
struct Gadget         *CargoGList = NULL;
struct Gadget         *BuyShipGList = NULL;
struct Gadget         *SelectGList = NULL;
struct Gadget         *MapGList = NULL;
struct Gadget         *PeopleGList = NULL;
struct Gadget         *AutopilotGList = NULL;
struct Menu           *SeaTradeMenus = NULL;
struct IntuiMessage    SeaTradeMsg;
struct IntuiMessage    InfoMsg;
struct IntuiMessage    TransferMsg;
struct IntuiMessage    CityMsg;
struct IntuiMessage    CargoMsg;
struct IntuiMessage    BuyShipMsg;
struct IntuiMessage    SelectMsg;
struct IntuiMessage    MapMsg;
struct IntuiMessage    PeopleMsg;
struct IntuiMessage    AutopilotMsg;
struct Gadget         *SeaTradeGadgets[20];
struct Gadget         *InfoGadgets[7];
struct Gadget         *TransferGadgets[9];
struct Gadget         *CityGadgets[14];
struct Gadget         *CargoGadgets[11];
struct Gadget         *BuyShipGadgets[11];
struct Gadget         *SelectGadgets[1];
struct Gadget         *MapGadgets[2];
struct Gadget         *PeopleGadgets[9];
struct Gadget         *AutopilotGadgets[8];
UWORD                  SeaTradeLeft = 0;
UWORD                  SeaTradeTop = 0;
UWORD                  SeaTradeWidth = 320;
UWORD                  SeaTradeHeight = 256;
UWORD                  InfoLeft = 10;
UWORD                  InfoTop = 15;
UWORD                  InfoWidth = 287;
UWORD                  InfoHeight = 142;
UWORD                  TransferLeft = 10;
UWORD                  TransferTop = 15;
UWORD                  TransferWidth = 294;
UWORD                  TransferHeight = 113;
UWORD                  CityLeft = 0;
UWORD                  CityTop = 0;
UWORD                  CityWidth = 320;
UWORD                  CityHeight = 256;
UWORD                  CargoLeft = 10;
UWORD                  CargoTop = 115;
UWORD                  CargoWidth = 302;
UWORD                  CargoHeight = 125;
UWORD                  BuyShipLeft = 10;
UWORD                  BuyShipTop = 15;
UWORD                  BuyShipWidth = 293;
UWORD                  BuyShipHeight = 95;
UWORD                  SelectLeft = 10;
UWORD                  SelectTop = 15;
UWORD                  SelectWidth = 131;
UWORD                  SelectHeight = 88;
UWORD                  MapLeft = 10;
UWORD                  MapTop = 15;
UWORD                  MapWidth = 83;
UWORD                  MapHeight = 108;
UWORD                  PeopleLeft = 10;
UWORD                  PeopleTop = 15;
UWORD                  PeopleWidth = 303;
UWORD                  PeopleHeight = 127;
UWORD                  AutopilotLeft = 10;
UWORD                  AutopilotTop = 15;
UWORD                  AutopilotWidth = 232;
UWORD                  AutopilotHeight = 56;
UBYTE                 *Sct = (UBYTE *)"SeaTrade v2.0";
UBYTE                 *SeaTradeWdt = (UBYTE *)"SeaTrade";
UBYTE                  InfoWdt[40];
UBYTE                 *TransferWdt = (UBYTE *)"Cargo/personnel transfer";
UBYTE                 *CityWdt = (UBYTE *)"Inside the city";
UBYTE                 *CargoWdt = (UBYTE *)"Buy/sell cargo";
UBYTE                 *BuyShipWdt = (UBYTE *)"Buy a new ship...";
UBYTE                 *SelectWdt = (UBYTE *)"Ship?";
UBYTE                 *MapWdt = (UBYTE *)"Map";
UBYTE                 *PeopleWdt = (UBYTE *)"View people";
UBYTE                 *AutopilotWdt = (UBYTE *)"Set autopilot";

UBYTE                  labels[15][32];

UBYTE *View1Labels[] = {
        (UBYTE *)"Cargo",
        (UBYTE *)"People",
        NULL };

UBYTE *Mode2Labels[] = {
        (UBYTE *)"Cargo",
        (UBYTE *)"People",
        NULL };

UBYTE *Ship2Labels[] = {
        (UBYTE *)"",
        (UBYTE *)"",
        NULL };

UBYTE *CargoName4Labels[] = {
        (UBYTE *)"Animal meat",
        (UBYTE *)"Chemicals",
        (UBYTE *)"Electronics",
        (UBYTE *)"Gemstones",
        (UBYTE *)"Iron ore",
        (UBYTE *)"Liquor",
        (UBYTE *)"Narcotics",
        (UBYTE *)"Robots",
        (UBYTE *)"Vegetables",
        (UBYTE *)"Wood",
        (UBYTE *)"Fuel",
        (UBYTE *)"Food",
        NULL };

UBYTE *NorthSouth9Labels[] = {
    (UBYTE *)"N",
    (UBYTE *)"S",
    NULL };

UBYTE *WestEast9Labels[] = {
    (UBYTE *)"W",
    (UBYTE *)"E",
    NULL };

extern struct MinList Ships0List;

struct MinList Ships0List;

extern struct MinList List1List;

struct Node List1Nodes[] = {
        &List1Nodes[1], ( struct Node * )&List1List.mlh_Head, 0, 0, labels[0],
        &List1Nodes[2], ( struct Node * )&List1Nodes[0], 0, 0, labels[1],
        &List1Nodes[3], ( struct Node * )&List1Nodes[1], 0, 0, labels[2],
        &List1Nodes[4], ( struct Node * )&List1Nodes[2], 0, 0, labels[3],
        &List1Nodes[5], ( struct Node * )&List1Nodes[3], 0, 0, labels[4],
        &List1Nodes[6], ( struct Node * )&List1Nodes[4], 0, 0, labels[5],
        &List1Nodes[7], ( struct Node * )&List1Nodes[5], 0, 0, labels[6],
        &List1Nodes[8], ( struct Node * )&List1Nodes[6], 0, 0, labels[7],
        &List1Nodes[9], ( struct Node * )&List1Nodes[7], 0, 0, labels[8],
        &List1Nodes[10], ( struct Node * )&List1Nodes[8], 0, 0, labels[9],
        &List1Nodes[11], ( struct Node * )&List1Nodes[9], 0, 0, labels[10],
        &List1Nodes[12], ( struct Node * )&List1Nodes[10], 0, 0, labels[11],
        &List1Nodes[13], ( struct Node * )&List1Nodes[11], 0, 0, labels[12],
        &List1Nodes[14], ( struct Node * )&List1Nodes[12], 0, 0, labels[13],
        ( struct Node * )&List1List.mlh_Tail, &List1Nodes[13], 0, 0, labels[14] };

struct MinList List1List = {
        ( struct MinNode * )&List1Nodes[0], ( struct MinNode * )NULL, ( struct MinNode * )&List1Nodes[1] };

extern struct MinList Docked1List;

struct MinList Docked1List;

extern struct MinList Items2List;

struct MinList Items2List;

extern struct MinList Cargo3List;

struct Node Cargo3Nodes[] = {
        &Cargo3Nodes[1], ( struct Node * )&Cargo3List.mlh_Head, 0, 0, labels[0],
        &Cargo3Nodes[2], ( struct Node * )&Cargo3Nodes[0], 0, 0, labels[1],
        &Cargo3Nodes[3], ( struct Node * )&Cargo3Nodes[1], 0, 0, labels[2],
        &Cargo3Nodes[4], ( struct Node * )&Cargo3Nodes[2], 0, 0, labels[3],
        &Cargo3Nodes[5], ( struct Node * )&Cargo3Nodes[3], 0, 0, labels[4],
        &Cargo3Nodes[6], ( struct Node * )&Cargo3Nodes[4], 0, 0, labels[5],
        &Cargo3Nodes[7], ( struct Node * )&Cargo3Nodes[5], 0, 0, labels[6],
        &Cargo3Nodes[8], ( struct Node * )&Cargo3Nodes[6], 0, 0, labels[7],
        &Cargo3Nodes[9], ( struct Node * )&Cargo3Nodes[7], 0, 0, labels[8],
        &Cargo3Nodes[10], ( struct Node * )&Cargo3Nodes[8], 0, 0, labels[9],
        &Cargo3Nodes[11], ( struct Node * )&Cargo3Nodes[9], 0, 0, labels[10],
        &Cargo3Nodes[12], ( struct Node * )&Cargo3Nodes[10], 0, 0, labels[11],
        ( struct Node * )&Cargo3List.mlh_Tail, &Cargo3Nodes[11], 0, 0, labels[12] };

struct MinList Cargo3List = {
        ( struct MinNode * )&Cargo3Nodes[0], ( struct MinNode * )NULL, ( struct MinNode * )&Cargo3Nodes[0] };

struct MinList SelectShip6List;

struct MinList ShipList8List;

struct MinList CityList8List;

struct TextAttr topaz8 = {
        ( STRPTR )"topaz.font", 8, 0x00, 0x01 };

struct IntuiText AutopilotIText[] = {
    1, 0, JAM1,-4, -1, &topaz8, (UBYTE *)"Latitude:", &AutopilotIText[1],
    1, 0, JAM1,-4, 15, &topaz8, (UBYTE *)"Longitude:", NULL };

struct NewMenu SeaTradeNewMenu[] = {
        NM_TITLE, (STRPTR)"Game", NULL, 0, NULL, NULL,
        NM_ITEM, (STRPTR)"Save...", (STRPTR)"S", 0, 0L, (APTR)SeaTradeSave,
        NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL,
        NM_ITEM, (STRPTR)"About...", (STRPTR)"?", 0, 0L, (APTR)SeaTradeAbout,
        NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL,
        NM_ITEM, (STRPTR)"Quit...", (STRPTR)"Q", 0, 0L, (APTR)SeaTradeQuit,
        NM_TITLE, (STRPTR)"Ship", NULL, 0, NULL, NULL,
        NM_ITEM, (STRPTR)"Next ship", (STRPTR)"+", NM_ITEMDISABLED, 0L, (APTR)SeaTradeNext,
        NM_ITEM, (STRPTR)"Previous ship", (STRPTR)"-", NM_ITEMDISABLED, 0L, (APTR)SeaTradePrevious,
        NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL,
        NM_ITEM, (STRPTR)"Release docked ship", NULL, NM_ITEMDISABLED, NULL, NULL,
        NM_SUB, (STRPTR)"All", (STRPTR)"R", 0, 0L, (APTR)SeaTradeReleaseall,
        NM_SUB, (STRPTR)"Select ship...", (STRPTR)"E", 0, 0L, (APTR)SeaTradeReleaseselect,
        NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL,
        NM_ITEM, (STRPTR)"Autopilot...", (STRPTR)"P", 0, 0L, (APTR)SeaTradeAutopilot,
        NM_TITLE, (STRPTR)"Options", NULL, 0, NULL, NULL,
        NM_ITEM, (STRPTR)"Autocenter", NULL, CHECKIT|MENUTOGGLE, NULL, NULL,
        NM_SUB, (STRPTR)"None", (STRPTR)"0", CHECKIT|MENUTOGGLE, 6L, (APTR)SeaTradeNone,
        NM_SUB, (STRPTR)"Off-line", (STRPTR)"1", CHECKIT|MENUTOGGLE, 5L, (APTR)SeaTradeOffline,
        NM_SUB, (STRPTR)"On-line", (STRPTR)"2", CHECKIT|CHECKED|MENUTOGGLE, 3L, (APTR)SeaTradeOnline,
        NM_ITEM, (STRPTR)"Skip used ships", (STRPTR)"U", CHECKIT|CHECKED|MENUTOGGLE, 0L, (APTR)SeaTradeSkip,
        NM_ITEM, (STRPTR)"Alarms", (STRPTR)"A", CHECKIT|MENUTOGGLE, 0L, (APTR)SeaTradeAlarms,
        NM_ITEM, (STRPTR)"Log file...", (STRPTR)"L", 0, 0L, (APTR)SeaTradeLog,
        NM_ITEM, (STRPTR)"Close log file", (STRPTR)"C", NM_ITEMDISABLED, NULL, (APTR)SeaTradeCloseLog,
        NM_ITEM, (STRPTR)"Fast autopilot", (STRPTR)"F", CHECKIT, 0L, (APTR)SeaTradeFastAutopilot,
        NM_END, NULL, NULL, 0, 0L, NULL };

UWORD SeaTradeGTypes[] = {
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        LISTVIEW_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        TEXT_KIND,
        NUMBER_KIND,
        TEXT_KIND,
        TEXT_KIND
};

UWORD InfoGTypes[] = {
        STRING_KIND,
        TEXT_KIND,
        LISTVIEW_KIND,
        LISTVIEW_KIND,
        CYCLE_KIND,
        BUTTON_KIND,
        BUTTON_KIND
};

UWORD TransferGTypes[] = {
        CYCLE_KIND,
        LISTVIEW_KIND,
        TEXT_KIND,
        NUMBER_KIND,
        CYCLE_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        NUMBER_KIND,
        INTEGER_KIND
};

UWORD CityGTypes[] = {
        TEXT_KIND,
        TEXT_KIND,
        TEXT_KIND,
        TEXT_KIND,
        BUTTON_KIND,
        NUMBER_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        LISTVIEW_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND
};

UWORD CargoGTypes[] = {
        CYCLE_KIND,
        TEXT_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        TEXT_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        INTEGER_KIND,
        BUTTON_KIND,
        BUTTON_KIND
};

UWORD BuyShipGTypes[] = {
        TEXT_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        TEXT_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        NUMBER_KIND,
        BUTTON_KIND,
        BUTTON_KIND,
        BUTTON_KIND
};

UWORD SelectGTypes[] = {
        LISTVIEW_KIND
};

UWORD MapGTypes[] = {
        TEXT_KIND,
        TEXT_KIND
};

UWORD PeopleGTypes[] = {
        TEXT_KIND,
        LISTVIEW_KIND,
        TEXT_KIND,
        LISTVIEW_KIND,
        BUTTON_KIND,
        TEXT_KIND,
        TEXT_KIND,
        TEXT_KIND,
        TEXT_KIND
};

UWORD AutopilotGTypes[] = {
    INTEGER_KIND,
    INTEGER_KIND,
    CYCLE_KIND,
    INTEGER_KIND,
    INTEGER_KIND,
    CYCLE_KIND,
    STRING_KIND,
    BUTTON_KIND
};

struct NewGadget SeaTradeNGad[] = {
        200, 5, 16, 16, (UBYTE *)"\\", NULL, GD_UL, PLACETEXT_IN, NULL, (APTR)ULClicked,
        216, 5, 16, 16, (UBYTE *)"|", NULL, GD_U, PLACETEXT_IN, NULL, (APTR)UClicked,
        232, 5, 16, 16, (UBYTE *)"/", NULL, GD_UR, PLACETEXT_IN, NULL, (APTR)URClicked,
        200, 21, 16, 16, (UBYTE *)"-", NULL, GD_L, PLACETEXT_IN, NULL, (APTR)LClicked,
        216, 21, 16, 16, (UBYTE *)"*", NULL, GD_Center, PLACETEXT_IN, NULL, (APTR)CenterClicked,
        232, 21, 16, 16, (UBYTE *)"-", NULL, GD_R, PLACETEXT_IN, NULL, (APTR)RClicked,
        200, 37, 16, 16, (UBYTE *)"/", NULL, GD_DL, PLACETEXT_IN, NULL, (APTR)DLClicked,
        216, 37, 16, 16, (UBYTE *)"|", NULL, GD_D, PLACETEXT_IN, NULL, (APTR)DClicked,
        232, 37, 16, 16, (UBYTE *)"\\", NULL, GD_DR, PLACETEXT_IN, NULL, (APTR)DRClicked,
        256, 13, 49, 11, (UBYTE *)"Info", NULL, GD_Info, PLACETEXT_IN, NULL, (APTR)InfoClicked,
        256, 29, 49, 11, (UBYTE *)"Dock", NULL, GD_Dock, PLACETEXT_IN, NULL, (APTR)DockClicked,
        192, 109, 121, 136, (UBYTE *)"Ships:", NULL, GD_Ships, PLACETEXT_ABOVE, NULL, (APTR)ShipsClicked,
        264, 53, 33, 11, (UBYTE *)"Moves:", NULL, GD_Moves, PLACETEXT_LEFT, NULL, NULL,
        264, 61, 33, 11, (UBYTE *)"Fuel:", NULL, GD_Fuel, PLACETEXT_LEFT, NULL, NULL,
        264, 69, 17, 11, (UBYTE *)"Crew:", NULL, GD_Crew, PLACETEXT_LEFT, NULL, NULL,
        264, 77, 33, 11, (UBYTE *)"Food:", NULL, GD_Food, PLACETEXT_LEFT, NULL, NULL,
        16, 181, 169, 11, NULL, NULL, GD_Date, 0, NULL, NULL,
        16, 205, 89, 11, (UBYTE *)"Money:", NULL, GD_Money, PLACETEXT_ABOVE, NULL, NULL,
        120, 197, 57, 11, NULL, NULL, GD_Latitude, 0, NULL, NULL,
        120, 205, 57, 11, NULL, NULL, GD_Longitude, 0, NULL, NULL
};

struct NewGadget InfoNGad[] = {
        32, 5, 113, 12, (UBYTE *)"Name:", NULL, GD_Name, PLACETEXT_ABOVE, NULL, (APTR)NameClicked,
        152, 5, 97, 11, (UBYTE *)"Class:", NULL, GD_Class, PLACETEXT_ABOVE, NULL, NULL,
        96, 29, 185, 48, NULL, NULL, GD_List, 0, NULL, (APTR)ListClicked,
        24, 93, 121, 32, (UBYTE *)"Docked ships:", NULL, GD_Docked, PLACETEXT_ABOVE, NULL, (APTR)DockedClicked,
        8, 45, 81, 11, (UBYTE *)"View:", NULL, GD_View, PLACETEXT_ABOVE, NULL, (APTR)ViewClicked,
        160, 93, 105, 11, (UBYTE *)"Release ship", NULL, GD_Release, PLACETEXT_IN, NULL, (APTR)ReleaseClicked,
        160, 109, 105, 11, (UBYTE *)"Transfer...", NULL, GD_Transfer, PLACETEXT_IN, NULL, (APTR)TransferClicked
};

struct NewGadget TransferNGad[] = {
        196, 5, 81, 11, (UBYTE *)"Mode:", NULL, GD_Mode, PLACETEXT_ABOVE, NULL, (APTR)ModeClicked,
        4, 5, 185, 64, NULL, NULL, GD_Items, 0, NULL, (APTR)ItemsClicked,
        68, 69, 105, 11, (UBYTE *)"To:", NULL, GD_To, PLACETEXT_LEFT, NULL, NULL,
        228, 85, 49, 11, (UBYTE *)"Free space:", NULL, GD_Free, PLACETEXT_LEFT, NULL, NULL,
        52, -11, 121, 11, (UBYTE *)"From:", NULL, GD_Ship, PLACETEXT_LEFT, NULL, (APTR)ShipClicked,
        196, 61, 81, 11, (UBYTE *)"Transfer»", NULL, GD_TransferOther, PLACETEXT_IN, NULL, (APTR)TransferOtherClicked,
        196, 45, 81, 11, (UBYTE *)"Transfer«", NULL, GD_TransferThis, PLACETEXT_IN, NULL, (APTR)TransferThisClicked,
        76, 85, 49, 11, (UBYTE *)"Amount:", NULL, GD_Amount, PLACETEXT_LEFT, NULL, NULL,
        212, 29, 57, 12, (UBYTE *)"How much?", NULL, GD_HowMuch, PLACETEXT_ABOVE, NULL, (APTR)HowMuchClicked
};

struct NewGadget CityNGad[] = {
        167, 13, 65, 11, (UBYTE *)"Welcome to the city of", NULL, GD_Welcome, PLACETEXT_ABOVE, NULL, NULL,
        136, 29, 129, 11, NULL, NULL, GD_Coordinates, 0, NULL, NULL,
        120, 45, 169, 11, NULL, NULL, GD_CityDate, 0, NULL, NULL,
        64, 101, 105, 11, (UBYTE *)"Ship:", NULL, GD_CityShip, PLACETEXT_LEFT, NULL, NULL,
        176, 101, 121, 11, (UBYTE *)"Select ship...", NULL, GD_Select, PLACETEXT_IN, NULL, (APTR)SelectClicked,
        120, 69, 89, 11, (UBYTE *)"Money:", NULL, GD_CityMoney, PLACETEXT_ABOVE, NULL, NULL,
        16, 117, 145, 11, (UBYTE *)"Sell this ship...", NULL, GD_Sell, PLACETEXT_IN, NULL, (APTR)SellClicked,
        168, 117, 129, 11, (UBYTE *)"Buy new ship...", NULL, GD_Buy, PLACETEXT_IN, NULL, (APTR)BuyClicked,
        16, 141, 281, 64, (UBYTE *)"Cargo name  Amount|Supply|Price", NULL, GD_Cargo, PLACETEXT_ABOVE, NULL, (APTR)CargoClicked,
        176, 205, 105, 11, (UBYTE *)"View crew...", NULL, GD_ViewCrew, PLACETEXT_IN, NULL, (APTR)ViewCrewClicked,
        144, 221, 153, 11, (UBYTE *)"View passengers...", NULL, GD_ViewPassengers, PLACETEXT_IN, NULL, (APTR)ViewPassengersClicked,
        248, 69, 41, 11, (UBYTE *)"EXIT", NULL, GD_Exit, PLACETEXT_IN, NULL, (APTR)ExitClicked,
        24, 205, 137, 11, (UBYTE *)"Buy/sell cargo...", NULL, GD_BuySell, PLACETEXT_IN, NULL, (APTR)BuySellClicked,
        40, 221, 97, 11, (UBYTE *)"Transfer...", NULL, GD_CityTransfer, PLACETEXT_IN, NULL, (APTR)CityTransferClicked
};

struct NewGadget CargoNGad[] = {
        124, -11, 145, 11, (UBYTE *)"Buying/selling", NULL, GD_CargoName, PLACETEXT_LEFT, NULL, (APTR)CargoNameClicked,
        60, 13, 105, 11, (UBYTE *)"Ship:", NULL, GD_CargoShip, PLACETEXT_LEFT, NULL, NULL,
        76, 29, 49, 11, (UBYTE *)"Amount:", NULL, GD_CargoAmount, PLACETEXT_LEFT, NULL, NULL,
        228, 29, 49, 11, (UBYTE *)"Free space:", NULL, GD_CargoSpace, PLACETEXT_LEFT, NULL, NULL,
        60, 53, 65, 11, (UBYTE *)"City:", NULL, GD_CargoCity, PLACETEXT_LEFT, NULL, NULL,
        244, 53, 33, 11, (UBYTE *)"Price:", NULL, GD_Price, PLACETEXT_LEFT, NULL, NULL,
        76, 69, 49, 11, (UBYTE *)"Supply:", NULL, GD_CargoSupply, PLACETEXT_LEFT, NULL, NULL,
        228, 69, 49, 11, (UBYTE *)"Demand:", NULL, GD_CargoDemand, PLACETEXT_LEFT, NULL, NULL,
        108, 93, 57, 12, (UBYTE *)"How much?", NULL, GD_CargoHowMuch, PLACETEXT_LEFT, NULL, (APTR)CargoHowMuchClicked,
        172, 93, 33, 11, (UBYTE *)"Buy", NULL, GD_CargoBuy, PLACETEXT_IN, NULL, (APTR)CargoBuyClicked,
        212, 93, 41, 11, (UBYTE *)"Sell", NULL, GD_CargoSell, PLACETEXT_IN, NULL, (APTR)CargoSellClicked
};

struct NewGadget BuyShipNGad[] = {
        164, -11, 97, 11, (UBYTE *)"Ship class:", NULL, GD_ShipClass, PLACETEXT_LEFT, NULL, NULL,
        172, 5, 33, 11, (UBYTE *)"Weight (kg):", NULL, GD_Weight, PLACETEXT_LEFT, NULL, NULL,
        172, 13, 41, 11, (UBYTE *)"Cargo (kg):", NULL, GD_ShipCargo, PLACETEXT_LEFT, NULL, NULL,
        172, 21, 17, 11, (UBYTE *)"Cabins:", NULL, GD_Cabins, PLACETEXT_LEFT, NULL, NULL,
        124, 29, 65, 11, (UBYTE *)"Docks:", NULL, GD_Docks, PLACETEXT_LEFT, NULL, NULL,
        188, 37, 25, 11, (UBYTE *)"Speed (knots):", NULL, GD_Speed, PLACETEXT_LEFT, NULL, NULL,
        220, 21, 57, 11, (UBYTE *)"Price:", NULL, GD_ShipPrice, PLACETEXT_ABOVE, NULL, NULL,
        68, 53, 89, 11, (UBYTE *)"Money:", NULL, GD_ShipMoney, PLACETEXT_LEFT, NULL, NULL,
        164, 53, 57, 11, (UBYTE *)"Buy...", NULL, GD_ShipBuy, PLACETEXT_IN, NULL, (APTR)ShipBuyClicked,
        68, 69, 81, 11, (UBYTE *)"«Previous", NULL, GD_Previous, PLACETEXT_IN, NULL, (APTR)PreviousClicked,
        156, 69, 49, 11, (UBYTE *)"Next»", NULL, GD_Next, PLACETEXT_IN, NULL, (APTR)NextClicked
};

struct NewGadget SelectNGad[] = {
        -4, -11, 121, 88, NULL, NULL, GD_SelectShip, 0, NULL, (APTR)SelectShipClicked
};

struct NewGadget MapNGad[] = {
        4, 69, 57, 11, NULL, NULL, GD_MapLatitude, 0, NULL, NULL,
        4, 77, 57, 11, NULL, NULL, GD_MapLongitude, 0, NULL, NULL
};

struct NewGadget PeopleNGad[] = {
        28, 5, 105, 11, (UBYTE *)"People on ship:", NULL, GD_PeopleShip, PLACETEXT_ABOVE, NULL, NULL,
        4, 21, 137, 40, NULL, NULL, GD_ShipList, 0, NULL, (APTR)ShipListClicked,
        172, 5, 65, 11, (UBYTE *)"People in city:", NULL, GD_PeopleCity, PLACETEXT_ABOVE, NULL, NULL,
        148, 21, 137, 40, NULL, NULL, GD_CityList, 0, NULL, (APTR)CityListClicked,
        4, 61, 281, 11, (UBYTE *)"Take on board / Put ashore", NULL, GD_Move, PLACETEXT_IN, NULL, (APTR)MoveClicked,
        4, 77, 281, 11, NULL, NULL, GD_Text1, 0, NULL, NULL,
        4, 85, 281, 11, NULL, NULL, GD_Text2, 0, NULL, NULL,
        4, 93, 281, 11, NULL, NULL, GD_Text3, 0, NULL, NULL,
        4, 101, 281, 11, NULL, NULL, GD_Text4, 0, NULL, NULL
};

struct NewGadget AutopilotNGad[] = {
    76, -3, 37, 12, (UBYTE *)"°", NULL, GD_LatDegrees, PLACETEXT_RIGHT, NULL, (APTR)LatDegreesClicked,
    130, -3, 37, 12, (UBYTE *)"'", NULL, GD_LatMinutes, PLACETEXT_RIGHT, NULL, (APTR)LatMinutesClicked,
    180, -3, 41, 11, NULL, NULL, GD_NorthSouth, 0, NULL, (APTR)NorthSouthClicked,
    76, 13, 37, 12, (UBYTE *)"°", NULL, GD_LonDegrees, PLACETEXT_RIGHT, NULL, (APTR)LonDegreesClicked,
    130, 13, 37, 12, (UBYTE *)"'", NULL, GD_LonMinutes, PLACETEXT_RIGHT, NULL, (APTR)LonMinutesClicked,
    180, 13, 41, 11, NULL, NULL, GD_WestEast, 0, NULL, (APTR)WestEastClicked,
    76, 29, 77, 12, (UBYTE *)"City:", NULL, GD_City, PLACETEXT_LEFT, NULL, (APTR)CityClicked,
    164, 29, 57, 11, (UBYTE *)"OK", NULL, GD_OK, PLACETEXT_IN, NULL, (APTR)OKClicked
};

ULONG SeaTradeGTags[] = {
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (GTLV_Labels), (ULONG)&Ships0List, (GTLV_ShowSelected), NULL, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTNM_Number), 0, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE)
};

ULONG InfoGTags[] = {
        (GTST_String), (ULONG)"", (GTST_MaxChars), 12, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTLV_Labels), (ULONG)&List1List, (GTLV_ShowSelected), NULL, (TAG_DONE),
        (GTLV_Labels), (ULONG)&Docked1List, (GTLV_ShowSelected), NULL, (TAG_DONE),
        (GTCY_Labels), (ULONG)&View1Labels[ 0 ], (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE)
};

ULONG TransferGTags[] = {
        (GTCY_Labels), (ULONG)&Mode2Labels[ 0 ], (TAG_DONE),
        (GTLV_ShowSelected), NULL, (GTLV_Labels), (ULONG)&Items2List, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTCY_Labels), (ULONG)&Ship2Labels[ 0 ], (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTIN_Number), 0, (GTIN_MaxChars), 5, (TAG_DONE)
};

ULONG CityGTags[] = {
        (GTTX_FrontPen), 0, (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (GTLV_Labels), (ULONG)&Cargo3List, (GTLV_ShowSelected), NULL, (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE)
};

ULONG CargoGTags[] = {
        (GTCY_Labels), (ULONG)&CargoName4Labels[ 0 ], (GTCY_Active), 0, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTNM_Number), 0, (GTNM_Border), TRUE, (TAG_DONE),
        (GTIN_Number), 0, (GTIN_MaxChars), 5, (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE)
};

ULONG BuyShipGTags[] = {
        (GTTX_Border), TRUE, (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE),
        (TAG_DONE),
        (GTNM_Border), TRUE, (TAG_DONE),
        (GTNM_Border), TRUE, (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE),
        (TAG_DONE)
};

ULONG SelectGTags[] = {
        (GTLV_ShowSelected), NULL, (GTLV_Labels), (ULONG)&SelectShip6List, (TAG_DONE)
};

ULONG MapGTags[] = {
        (GTTX_Text), (ULONG)"", (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE)
};

ULONG PeopleGTags[] = {
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTLV_Labels), (ULONG)&ShipList8List, (GTLV_ShowSelected), NULL, (TAG_DONE),
        (GTTX_Text), (ULONG)"", (GTTX_Border), TRUE, (TAG_DONE),
        (GTLV_Labels), (ULONG)&CityList8List, (GTLV_ShowSelected), NULL, (TAG_DONE),
        (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE),
        (GTTX_Text), (ULONG)"", (TAG_DONE)
};

ULONG AutopilotGTags[] = {
    (GTIN_Number), 0, (GTIN_MaxChars), 2, (TAG_DONE),
    (GTIN_Number), 0, (GTIN_MaxChars), 2, (TAG_DONE),
    (GTCY_Labels), (ULONG)&NorthSouth9Labels[ 0 ], (TAG_DONE),
    (GTIN_Number), 0, (GTIN_MaxChars), 2, (TAG_DONE),
    (GTIN_Number), 0, (GTIN_MaxChars), 2, (TAG_DONE),
    (GTCY_Labels), (ULONG)&WestEast9Labels[ 0 ], (TAG_DONE),
    (GTST_String), (ULONG)"", (GTST_MaxChars), 7, (TAG_DONE),
    (TAG_DONE)
};

UWORD DriPens[] = {
        0, /* DETAILPEN */
        1, /* BLOCKPEN */
        1, /* TEXTPEN */
        1, /* SHINEPEN */
        17, /* SHADOWPEN */
        32, /* FILLPEN */
        1, /* FILLTEXTPEN */
        0, /* BACKGROUNDPEN */
        64, /* HIGHLIGHTTEXTPEN */
        1, /* BARDETAILPEN */
        32, /* BARBLOCKPEN */
        0, /* BARTRIMPEN */
        ~0 };

int SetupScreen( void )
{
    ULONG screenmode;
    APTR aslrequest;
    aslrequest=AllocAslRequestTags(ASL_ScreenModeRequest,
                                   ASLSM_PubScreenName, (STRPTR)"Workbench",
                                   ASLSM_SleepWindow, TRUE,
                                   ASLSM_TitleText, (STRPTR)"Choose a screen mode for Sea Trade",
                                   ASLSM_InitialDisplayWidth, 320,
                                   ASLSM_InitialDisplayHeight, 256,
                                   ASLSM_InitialDisplayDepth, 8,
                                   ASLSM_MinWidth, 320,
                                   ASLSM_MinHeight, 256,
                                   ASLSM_MinDepth, 8,
                                   TAG_DONE);
    if (AslRequest(aslrequest, NULL))
        screenmode=((struct ScreenModeRequester *)aslrequest)->sm_DisplayID;
    else
        screenmode=INVALID_ID;
    FreeAslRequest(aslrequest);
    if (screenmode==INVALID_ID)
    {
        printf("Unable to find a suitable screen mode!\n");
        return 1L;
    }
    else
        printf("Found suitable screenmode: %8X\n", screenmode);
        if ( ! ( Scr = OpenScreenTags( NULL, SA_Left,   0,
                                        SA_Top,         0,
                                        SA_Width,       320,
                                        SA_Height,      267,
                                        SA_Depth,       8,
                                        SA_Font,        &topaz8,
                                        SA_Type,        CUSTOMSCREEN,
                                        SA_DisplayID,   screenmode /*PAL_MONITOR_ID|LORES_KEY*/,
                                        SA_Pens,        &DriPens[0],
                                        SA_Title,       Sct,
                                        TAG_DONE )))
                return( 1L );

        if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
                return( 2L );

        return( 0L );
}

void CloseDownScreen( void )
{
        if ( VisualInfo ) {
                FreeVisualInfo( VisualInfo );
                VisualInfo = NULL;
        }

        if ( Scr        ) {
                CloseScreen( Scr );
                Scr = NULL;
        }
}

void SeaTradeRender( void )
{
        UWORD           offx, offy;

        offx = 0;
        offy = Scr->WBorTop + Scr->Font->ta_YSize + 1;

        DrawImage(SeaTradeWnd->RPort, panelimage, 0, 0);

        DrawBevelBox( SeaTradeWnd->RPort, offx + 118, offy + 197, 60, 19, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
        DrawBevelBox( SeaTradeWnd->RPort, offx + 192, offy + -3, 121, 97, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( SeaTradeWnd->RPort, offx + 6, offy + -4, 180, 178, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );

        RefreshGList(SeaTradeGList, SeaTradeWnd, NULL, -1);

        /* detach list from ListView gadget to allow editing */
        /* GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE); */
        /* reattach list to ListView gadget to update display */
        /* GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
            &Ships0List, TAG_DONE); */
}

int HandleSeaTradeIDCMP( void )
{
        struct IntuiMessage     *m;
        struct MenuItem         *n;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( SeaTradeWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&SeaTradeMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( SeaTradeMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( SeaTradeWnd );
                                SeaTradeRender();
                                GT_EndRefresh( SeaTradeWnd, TRUE );
                                break;

                        case    IDCMP_GADGETUP:
                        case    IDCMP_GADGETDOWN:
                                func = ( void * )(( struct Gadget * )SeaTradeMsg.IAddress )->UserData;
                                running = func();
                                break;

                        case    IDCMP_MENUPICK:
                                while( SeaTradeMsg.Code != MENUNULL ) {
                                        n = ItemAddress( SeaTradeMenus, SeaTradeMsg.Code );
                                        func = (void *)(GTMENUITEM_USERDATA( n ));
                                        running = func();
                                        SeaTradeMsg.Code = n->NextSelect;
                                }
                                break;

                        case    IDCMP_RAWKEY:
                                running = SeaTradeRawKey();
                                break;

                        case    IDCMP_MOUSEBUTTONS:
                                running = SeaTradeMouseButtons();
                                break;

                }
        }
        return( running );
}

int OpenSeaTradeWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = 0, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        /* Initialise Ships0List as an empty list. Ships will later be added to
        it. */
        NewList(&Ships0List);

        if ( ! ( g = CreateContext( &SeaTradeGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < SeaTrade_CNT; lc++ ) {

                CopyMem((char * )&SeaTradeNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                SeaTradeGadgets[ lc ] = g = CreateGadgetA((ULONG)SeaTradeGTypes[ lc ], g, &ng, ( struct TagItem * )&SeaTradeGTags[ tc ] );

                while( SeaTradeGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( SeaTradeMenus = CreateMenus( SeaTradeNewMenu, GTMN_FrontPen, 0L, TAG_DONE )))
                return( 3L );

        LayoutMenus( SeaTradeMenus, VisualInfo, GTMN_TextAttr, &topaz8, TAG_DONE );

        if ( ! ( SeaTradeWnd = OpenWindowTags( NULL,
                                WA_Left,        SeaTradeLeft,
                                WA_Top,         SeaTradeTop + Scr->BarHeight + 1,
                                WA_InnerWidth,  SeaTradeWidth,
                                WA_InnerHeight, SeaTradeHeight,
                                WA_IDCMP,       IDCMP_MOUSEBUTTONS|BUTTONIDCMP|LISTVIEWIDCMP|NUMBERIDCMP|TEXTIDCMP|IDCMP_MENUPICK|IDCMP_REFRESHWINDOW|IDCMP_RAWKEY,
                                WA_Flags,       WFLG_SMART_REFRESH|WFLG_BACKDROP|WFLG_GIMMEZEROZERO|WFLG_BORDERLESS|WFLG_ACTIVATE,
                                WA_Gadgets,     SeaTradeGList,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        SetMenuStrip( SeaTradeWnd, SeaTradeMenus );
        GT_RefreshWindow( SeaTradeWnd, NULL );

        SeaTradeRender();

        return( 0L );
}

void CloseSeaTradeWindow( void )
{
        if ( SeaTradeMenus      ) {
                ClearMenuStrip( SeaTradeWnd );
                FreeMenus( SeaTradeMenus );
                SeaTradeMenus = NULL;   }

        if ( SeaTradeWnd        ) {
                CloseWindow( SeaTradeWnd );
                SeaTradeWnd = NULL;
        }

        if ( SeaTradeGList      ) {
                FreeGadgets( SeaTradeGList );
                SeaTradeGList = NULL;
        }
}

void InfoRender( void )
{
        UWORD           offx, offy;

        offx = InfoWnd->BorderLeft;
        offy = InfoWnd->BorderTop;


        DrawBevelBox( InfoWnd->RPort, offx + 16, offy + -11, 249, 33, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( InfoWnd->RPort, offx + 16, offy + 77, 257, 49, GT_VisualInfo, VisualInfo, TAG_DONE );
}

int HandleInfoIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( InfoWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&InfoMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( InfoMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( InfoWnd );
                                InfoRender();
                                GT_EndRefresh( InfoWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = InfoCloseWindow();
                                break;

                        case    IDCMP_GADGETUP:
                        case    IDCMP_GADGETDOWN:
                                func = ( void * )(( struct Gadget * )InfoMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenInfoWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        makecargolist();

        if ( ! ( g = CreateContext( &InfoGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < Info_CNT; lc++ ) {

                CopyMem((char * )&InfoNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                InfoGadgets[ lc ] = g = CreateGadgetA((ULONG)InfoGTypes[ lc ], g, &ng, ( struct TagItem * )&InfoGTags[ tc ] );

                while( InfoGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( InfoWnd = OpenWindowTags( NULL,
                                WA_Left,        InfoLeft,
                                WA_Top,         InfoTop,
                                WA_InnerWidth,  InfoWidth,
                                WA_InnerHeight, InfoHeight,
                                WA_IDCMP,       STRINGIDCMP|TEXTIDCMP|LISTVIEWIDCMP|CYCLEIDCMP|NUMBERIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     InfoGList,
                                WA_Title,       InfoWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( InfoWnd, NULL );

        InfoRender();

        return( 0L );
}

void CloseInfoWindow( void )
{
        if ( InfoWnd        ) {
                CloseWindow( InfoWnd );
                InfoWnd = NULL;
        }

        if ( InfoGList      ) {
                FreeGadgets( InfoGList );
                InfoGList = NULL;
        }
}

int HandleTransferIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( TransferWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&TransferMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( TransferMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( TransferWnd );
                                GT_EndRefresh( TransferWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = TransferCloseWindow();
                                break;

                        case    IDCMP_GADGETUP:
                        case    IDCMP_GADGETDOWN:
                                func = ( void * )(( struct Gadget * )TransferMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenTransferWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &TransferGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < Transfer_CNT; lc++ ) {

                CopyMem((char * )&TransferNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                TransferGadgets[ lc ] = g = CreateGadgetA((ULONG)TransferGTypes[ lc ], g, &ng, ( struct TagItem * )&TransferGTags[ tc ] );

                while( TransferGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( TransferWnd = OpenWindowTags( NULL,
                                WA_Left,        TransferLeft,
                                WA_Top,         TransferTop,
                                WA_Width,       TransferWidth,
                                WA_Height,      TransferHeight + offy,
                                WA_IDCMP,       CYCLEIDCMP|LISTVIEWIDCMP|TEXTIDCMP|NUMBERIDCMP|BUTTONIDCMP|INTEGERIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     TransferGList,
                                WA_Title,       TransferWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))

        return( 4L );

        GT_RefreshWindow( TransferWnd, NULL );

        return( 0L );
}

void CloseTransferWindow( void )
{
        if ( TransferWnd        ) {
                CloseWindow( TransferWnd );
                TransferWnd = NULL;
        }

        if ( TransferGList      ) {
                FreeGadgets( TransferGList );
                TransferGList = NULL;
        }
}

void CityRender( void )
{
        UWORD           offx, offy;

        offx = 0;
        offy = Scr->WBorTop + Scr->Font->ta_YSize + 1;

        DrawImage(CityWnd->RPort, citypanelimage, 0, 0);

        DrawBevelBox( CityWnd->RPort, offx + 245, offy + 67, 47, 15, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( CityWnd->RPort, offx + 22, offy + -4, 82, 80, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
        DrawBevelBox( CityWnd->RPort, offx + 8, offy + -11, 297, 97, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( CityWnd->RPort, offx + 8, offy + 93, 297, 145, GT_VisualInfo, VisualInfo, TAG_DONE );

        RefreshGList(CityGList, CityWnd, NULL, -1);

        /* detach list from ListView gadget to allow editing */
        /* GT_SetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE); */
        /* reattach list to ListView gadget to update display */
        /* GT_SetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Labels,
            &Cargo3List, TAG_DONE); */
}

int HandleCityIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( CityWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&CityMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( CityMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( CityWnd );
                                CityRender();
                                GT_EndRefresh( CityWnd, TRUE );
                                break;

                        case    IDCMP_GADGETUP:
                        case    IDCMP_GADGETDOWN:
                                func = ( void * )(( struct Gadget * )CityMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenCityWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = 0, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &CityGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < City_CNT; lc++ ) {

                CopyMem((char * )&CityNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                CityGadgets[ lc ] = g = CreateGadgetA((ULONG)CityGTypes[ lc ], g, &ng, ( struct TagItem * )&CityGTags[ tc ] );

                while( CityGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( CityWnd = OpenWindowTags( NULL,
                                WA_Left,        CityLeft,
                                WA_Top,         CityTop + Scr->BarHeight + 1,
                                WA_InnerWidth,  CityWidth,
                                WA_InnerHeight, CityHeight,
                                WA_IDCMP,       TEXTIDCMP|BUTTONIDCMP|NUMBERIDCMP|LISTVIEWIDCMP|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_SMART_REFRESH|WFLG_BACKDROP|WFLG_GIMMEZEROZERO|WFLG_BORDERLESS|WFLG_ACTIVATE,
                                WA_Gadgets,     CityGList,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( CityWnd, NULL );

        CityRender();

        showcargolist();

        return( 0L );
}

void CloseCityWindow( void )
{
        if ( CityWnd        ) {
                CloseWindow( CityWnd );
                CityWnd = NULL;
        }

        if ( CityGList      ) {
                FreeGadgets( CityGList );
                CityGList = NULL;
        }
}

void CargoRender( void )
{
        UWORD           offx, offy;

        offx = CargoWnd->BorderLeft;
        offy = CargoWnd->BorderTop;


        DrawBevelBox( CargoWnd->RPort, offx + 4, offy + 85, 281, 25, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( CargoWnd->RPort, offx + 4, offy + 5, 281, 40, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( CargoWnd->RPort, offx + 4, offy + 45, 281, 40, GT_VisualInfo, VisualInfo, TAG_DONE );
}

int HandleCargoIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( CargoWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&CargoMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( CargoMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( CargoWnd );
                                CargoRender();
                                GT_EndRefresh( CargoWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = CargoCloseWindow();
                                break;

                        case    IDCMP_GADGETUP:
                                func = ( void * )(( struct Gadget * )CargoMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenCargoWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &CargoGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < Cargo_CNT; lc++ ) {

                CopyMem((char * )&CargoNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                CargoGadgets[ lc ] = g = CreateGadgetA((ULONG)CargoGTypes[ lc ], g, &ng, ( struct TagItem * )&CargoGTags[ tc ] );

                while( CargoGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( CargoWnd = OpenWindowTags( NULL,
                                WA_Left,        CargoLeft,
                                WA_Top,         CargoTop,
                                WA_Width,       CargoWidth,
                                WA_Height,      CargoHeight + offy,
                                WA_IDCMP,       CYCLEIDCMP|TEXTIDCMP|NUMBERIDCMP|INTEGERIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     CargoGList,
                                WA_Title,       CargoWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( CargoWnd, NULL );

        CargoRender();

        return( 0L );
}

void CloseCargoWindow( void )
{
        if ( CargoWnd        ) {
                CloseWindow( CargoWnd );
                CargoWnd = NULL;
        }

        if ( CargoGList      ) {
                FreeGadgets( CargoGList );
                CargoGList = NULL;
        }
}

void BuyShipRender( void )
{
        UWORD           offx, offy;

        offx = BuyShipWnd->BorderLeft;
        offy = BuyShipWnd->BorderTop;

        DrawBevelBox( BuyShipWnd->RPort, offx + -4, offy + -11, 68, 66, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
        DrawBevelBox( BuyShipWnd->RPort, offx + 65, offy + 5, 149, 44, GT_VisualInfo, VisualInfo, TAG_DONE );

        DrawImage(BuyShipWnd->RPort, shipviewimage, 2, 1);
}

int HandleBuyShipIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( BuyShipWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&BuyShipMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( BuyShipMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( BuyShipWnd );
                                BuyShipRender();
                                GT_EndRefresh( BuyShipWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = BuyShipCloseWindow();
                                break;

                        case    IDCMP_GADGETUP:
                                func = ( void * )(( struct Gadget * )BuyShipMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenBuyShipWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &BuyShipGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < BuyShip_CNT; lc++ ) {

                CopyMem((char * )&BuyShipNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                BuyShipGadgets[ lc ] = g = CreateGadgetA((ULONG)BuyShipGTypes[ lc ], g, &ng, ( struct TagItem * )&BuyShipGTags[ tc ] );

                while( BuyShipGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( BuyShipWnd = OpenWindowTags( NULL,
                                WA_Left,        BuyShipLeft,
                                WA_Top,         BuyShipTop,
                                WA_Width,       BuyShipWidth,
                                WA_Height,      BuyShipHeight + offy,
                                WA_IDCMP,       TEXTIDCMP|NUMBERIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     BuyShipGList,
                                WA_Title,       BuyShipWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( BuyShipWnd, NULL );

        BuyShipRender();

        return( 0L );
}

void CloseBuyShipWindow( void )
{
        if ( BuyShipWnd        ) {
                CloseWindow( BuyShipWnd );
                BuyShipWnd = NULL;
        }

        if ( BuyShipGList      ) {
                FreeGadgets( BuyShipGList );
                BuyShipGList = NULL;
        }
}

int HandleSelectIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( SelectWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&SelectMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( SelectMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( SelectWnd );
                                GT_EndRefresh( SelectWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = SelectCloseWindow();
                                break;

                        case    IDCMP_GADGETUP:
                        case    IDCMP_GADGETDOWN:
                                func = ( void * )(( struct Gadget * )SelectMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenSelectWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &SelectGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < Select_CNT; lc++ ) {

                CopyMem((char * )&SelectNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                SelectGadgets[ lc ] = g = CreateGadgetA((ULONG)SelectGTypes[ lc ], g, &ng, ( struct TagItem * )&SelectGTags[ tc ] );

                while( SelectGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( SelectWnd = OpenWindowTags( NULL,
                                WA_Left,        SelectLeft,
                                WA_Top,         SelectTop,
                                WA_Width,       SelectWidth,
                                WA_Height,      SelectHeight + offy,
                                WA_IDCMP,       LISTVIEWIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     SelectGList,
                                WA_Title,       SelectWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( SelectWnd, NULL );

        return( 0L );
}

void CloseSelectWindow( void )
{
        if ( SelectWnd        ) {
                CloseWindow( SelectWnd );
                SelectWnd = NULL;
        }

        if ( SelectGList      ) {
                FreeGadgets( SelectGList );
                SelectGList = NULL;
        }
}

void MapRender( void )
{
        UWORD           offx, offy;

        offx = MapWnd->BorderLeft;
        offy = MapWnd->BorderTop;


        DrawBevelBox( MapWnd->RPort, offx + -4, offy + 61, 74, 33, GT_VisualInfo, VisualInfo, TAG_DONE );
        DrawBevelBox( MapWnd->RPort, offx + -4, offy + -11, 74, 72, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int HandleMapIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( MapWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&MapMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( MapMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( MapWnd );
                                MapRender();
                                GT_EndRefresh( MapWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = MapCloseWindow();
                                break;

                        case    IDCMP_MOUSEBUTTONS:
                                running = MapMouseButtons();
                                break;

                        case    IDCMP_RAWKEY:
                                running = MapRawKey();
                                break;
                }
        }
        return( running );
}

int OpenMapWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &MapGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < Map_CNT; lc++ ) {

                CopyMem((char * )&MapNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                MapGadgets[ lc ] = g = CreateGadgetA((ULONG)MapGTypes[ lc ], g, &ng, ( struct TagItem * )&MapGTags[ tc ] );

                while( MapGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( MapWnd = OpenWindowTags( NULL,
                                WA_Left,        MapLeft,
                                WA_Top,         MapTop,
                                WA_Width,       MapWidth,
                                WA_Height,      MapHeight + offy,
                                WA_IDCMP,       TEXTIDCMP|IDCMP_MOUSEBUTTONS|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW|IDCMP_RAWKEY,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     MapGList,
                                WA_Title,       MapWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( MapWnd, NULL );

        MapRender();

        return( 0L );
}

void CloseMapWindow( void )
{
        if ( MapWnd        ) {
                CloseWindow( MapWnd );
                MapWnd = NULL;
        }

        if ( MapGList      ) {
                FreeGadgets( MapGList );
                MapGList = NULL;
        }
}

void PeopleRender( void )
{
        UWORD           offx, offy;

        offx = PeopleWnd->BorderLeft;
        offy = PeopleWnd->BorderTop;


        DrawBevelBox( PeopleWnd->RPort, offx + 2, offy + 77, 285, 35, GT_VisualInfo, VisualInfo, GTBB_Recessed, TRUE, TAG_DONE );
}

int HandlePeopleIDCMP( void )
{
        struct IntuiMessage     *m;
        int                     (*func)();
        BOOL                    running = TRUE;

        while( m = GT_GetIMsg( PeopleWnd->UserPort )) {

                CopyMem(( char * )m, ( char * )&PeopleMsg, (long)sizeof( struct IntuiMessage ));

                GT_ReplyIMsg( m );

                switch ( PeopleMsg.Class ) {

                        case    IDCMP_REFRESHWINDOW:
                                GT_BeginRefresh( PeopleWnd );
                                PeopleRender();
                                GT_EndRefresh( PeopleWnd, TRUE );
                                break;

                        case    IDCMP_CLOSEWINDOW:
                                running = PeopleCloseWindow();
                                break;

                        case    IDCMP_GADGETUP:
                        case    IDCMP_GADGETDOWN:
                                func = ( void * )(( struct Gadget * )PeopleMsg.IAddress )->UserData;
                                running = func();
                                break;
                }
        }
        return( running );
}

int OpenPeopleWindow( void )
{
        struct NewGadget        ng;
        struct Gadget   *g;
        UWORD           lc, tc;
        UWORD           offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

        if ( ! ( g = CreateContext( &PeopleGList )))
                return( 1L );

        for( lc = 0, tc = 0; lc < People_CNT; lc++ ) {

                CopyMem((char * )&PeopleNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

                ng.ng_VisualInfo = VisualInfo;
                ng.ng_TextAttr   = &topaz8;
                ng.ng_LeftEdge  += offx;
                ng.ng_TopEdge   += offy;

                PeopleGadgets[ lc ] = g = CreateGadgetA((ULONG)PeopleGTypes[ lc ], g, &ng, ( struct TagItem * )&PeopleGTags[ tc ] );

                while( PeopleGTags[ tc ] ) tc += 2;
                tc++;

                if ( NOT g )
                        return( 2L );
        }

        if ( ! ( PeopleWnd = OpenWindowTags( NULL,
                                WA_Left,        PeopleLeft,
                                WA_Top,         PeopleTop,
                                WA_Width,       PeopleWidth,
                                WA_Height,      PeopleHeight + offy,
                                WA_IDCMP,       TEXTIDCMP|LISTVIEWIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                                WA_Flags,       WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                                WA_Gadgets,     PeopleGList,
                                WA_Title,       PeopleWdt,
                                WA_ScreenTitle, Sct,
                                WA_CustomScreen,        Scr,
                                TAG_DONE )))
        return( 4L );

        GT_RefreshWindow( PeopleWnd, NULL );

        PeopleRender();

        return( 0L );
}

void ClosePeopleWindow( void )
{
        if ( PeopleWnd        ) {
                CloseWindow( PeopleWnd );
                PeopleWnd = NULL;
        }

        if ( PeopleGList      ) {
                FreeGadgets( PeopleGList );
                PeopleGList = NULL;
        }
}

void AutopilotRender( void )
{
    UWORD       offx, offy;

    offx = AutopilotWnd->BorderLeft;
    offy = AutopilotWnd->BorderTop;

    PrintIText( AutopilotWnd->RPort, AutopilotIText, offx, offy );
}

int HandleAutopilotIDCMP( void )
{
    struct IntuiMessage *m;
    int         (*func)();
    BOOL            running = TRUE;

    while( m = GT_GetIMsg( AutopilotWnd->UserPort )) {

        CopyMem(( char * )m, ( char * )&AutopilotMsg, (long)sizeof( struct IntuiMessage ));

        GT_ReplyIMsg( m );

        switch ( AutopilotMsg.Class ) {

            case    IDCMP_REFRESHWINDOW:
                GT_BeginRefresh( AutopilotWnd );
                AutopilotRender();
                GT_EndRefresh( AutopilotWnd, TRUE );
                break;

            case    IDCMP_CLOSEWINDOW:
                running = AutopilotCloseWindow();
                break;

            case    IDCMP_GADGETUP:
                func = ( void * )(( struct Gadget * )AutopilotMsg.IAddress )->UserData;
                running = func();
                break;
        }
    }
    return( running );
}

int OpenAutopilotWindow( void )
{
    struct NewGadget    ng;
    struct Gadget   *g;
    UWORD       lc, tc;
    UWORD       offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

    if ( ! ( g = CreateContext( &AutopilotGList )))
        return( 1L );

    for( lc = 0, tc = 0; lc < Autopilot_CNT; lc++ ) {

        CopyMem((char * )&AutopilotNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

        ng.ng_VisualInfo = VisualInfo;
        ng.ng_TextAttr   = &topaz8;
        ng.ng_LeftEdge  += offx;
        ng.ng_TopEdge   += offy;

        AutopilotGadgets[ lc ] = g = CreateGadgetA((ULONG)AutopilotGTypes[ lc ], g, &ng, ( struct TagItem * )&AutopilotGTags[ tc ] );

        while( AutopilotGTags[ tc ] ) tc += 2;
        tc++;

        if ( NOT g )
            return( 2L );
    }

    if ( ! ( AutopilotWnd = OpenWindowTags( NULL,
                WA_Left,    AutopilotLeft,
                WA_Top,     AutopilotTop,
                WA_InnerWidth,  AutopilotWidth,
                WA_InnerHeight, AutopilotHeight,
                WA_IDCMP,   INTEGERIDCMP|CYCLEIDCMP|STRINGIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
                WA_Flags,   WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_GIMMEZEROZERO|WFLG_ACTIVATE,
                WA_Gadgets, AutopilotGList,
                WA_Title,   AutopilotWdt,
                WA_ScreenTitle, "GadToolsBox V2.0b © 1991-1993",
                WA_CustomScreen,    Scr,
                TAG_DONE )))
    return( 4L );

    GT_RefreshWindow( AutopilotWnd, NULL );

    AutopilotRender();

    return( 0L );
}

void CloseAutopilotWindow( void )
{
    if ( AutopilotWnd        ) {
        CloseWindow( AutopilotWnd );
        AutopilotWnd = NULL;
    }

    if ( AutopilotGList      ) {
        FreeGadgets( AutopilotGList );
        AutopilotGList = NULL;
    }
}
