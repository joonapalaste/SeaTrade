/* Project and source code (c) Copyright by Joona Palaste */
/* Licenced under GNU GPL 3.0                             */

/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : JIPsoft (Joona I Palaste)
 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <libraries/asl.h>
#include <libraries/dos.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <math.h>

#include "SeaTrade.h"
#include "SeaTrade_extern.h"

struct city *getcity(UBYTE i)
{
    return city+i;
}

void getcitylocation(struct city *s, UWORD *x, UWORD *y)
{
    ULONG loc;
    loc = (s->location[0]<<16) + (s->location[1]<<8) + s->location[2];
    *x=loc%1024; *y=loc/1024;
}

void clearcitydiffs()
{
    UBYTE i, j;
    for (i=0; i<128; i++)
        for (j=0; j<12; j++)
            citydiff[i][j]=0;
}

void citymap(struct RastPort *rp, UWORD sx, UWORD sy, UBYTE width, UBYTE height,
    UWORD destx, UWORD desty)
{
    UWORD xx, yy;
    UBYTE x, y, p, i;
    for (x=0; x<width; x++)
        for (y=0; y<height; y++)
        {
            if (width!=39 && x==17 && y==17)
                p=1;
            else
            {
                switch (getrawblocktype(sx+x, sy+y))
                {
                    case 0: /* Deep sea, or anything else */
                    default:
                    p=43;
                    break;
                    case 1: /* Medium sea */
                    p=41;
                    break;
                    case 2: /* Shallow sea */
                    p=39;
                    break;
                    case 3: /* Shallow forest */
                    p=55;
                    break;
                    case 4: /* Medium forest */
                    p=56;
                    break;
                    case 5: /* Deep forest */
                    p=57;
                    break;
                    case 6: /* City */
                    for (i=0; i<128; i++)
                    {
                        getcitylocation(getcity(i), &xx, &yy);
                        if (xx==sx+x && yy==sy+y)
                            break;
                    }
                    p=88+getcity(i)->type*4;
                    break;
                }
            }
            SetAPen(&hidden_rp, p);
            WritePixel(&hidden_rp, x*2, y*2);
            SetAPen(&hidden_rp, p+1);
            WritePixel(&hidden_rp, x*2+1, y*2);
            WritePixel(&hidden_rp, x*2, y*2+1);
            SetAPen(&hidden_rp, p+2);
            WritePixel(&hidden_rp, x*2+1, y*2+1);
        }
    ClipBlit(&hidden_rp, 0, 0, rp, destx, desty, 2*width, 2*height, 0xC0);
}

/* Makes the currently selected ship dock inside the city with the given index
   number. The ship must already physically reside in the city's location. This
   function doesn't return until the player clicks "EXIT" in the city window. */
void gotocity(UBYTE n)
{
    struct person *p, *pp;
    UBYTE coordstr[16], title[27], pay[5], message[80];
    UWORD x, y;
    currentcity=getcity(n); cityn=n; citiesknown[n]=TRUE;
    ship->next=&currentcity->store; currentcity->store.prev=ship;
    ship=&currentcity->store;
    getshiplocation(currentship, &x, &y);
    coordinatestrings(latitude, longitude, x, y);
    sprintf(coordstr, "%s %s", latitude, longitude);
    if (!OpenCityWindow())
    {
        citymap(CityWnd->RPort, x-19, y-19, 39, 39, 24, 8);
        GT_SetGadgetAttrs(CityGadgets[0], CityWnd, NULL, GTTX_FrontPen,
            88+getcity(n)->type*4, GTTX_Text, getcity(n)->name, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[1], CityWnd, NULL, GTTX_Text,
            coordstr, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[2], CityWnd, NULL, GTTX_Text,
            datestr, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text,
            currentship->name, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[5], CityWnd, NULL, GTNM_Number,
            money, TAG_DONE);
        p=personlist;
        while (p)
        {
            pp=p; p=p->next;
            if ((gettype(pp)==PASSENGER && pp->location==currentship &&
                pp->destination==n) || gettype(pp)==FAILED)
            {
                sprintf(title, "Message from %s", pp->name);
                sprintf(pay, "%d", pp->pay);
                if (gettype(pp)!=FAILED)
                {
                    request(CityWnd, title, "Thanks for bringing me here!\n"
                        "Here's %s in payment.", proceed, pay);
                    setmoney(money + pp->pay);
                    if (reputation<32767)
                        reputation++;
                    writelogdate();
                    sprintf(message, ": %s got to %s on time.\n", pp->name,
                        getcity(n)->name);
                    writelog(message);
                }
                else
                    if (pp->destination==n)
                        request(CityWnd, title, "Good riddance! Don't\n"
                            "even ask for payment!", proceed, NULL);
                    else
                        request(CityWnd, title, "Good riddance! I'll go\n"
                            "to %s on my own!", proceed,
                              getcity(pp->destination)->name);
                ((struct ship *)pp->location)->passengers--;
                freeperson(pp);
            }
        }
        while (HandleCityIDCMP());
        CloseCityWindow();
        ship=ship->prev; ship->next=NULL;
        if (currentship==&currentcity->store)
            currentship=NULL;
        select(currentship);
    }
    currentcity=NULL;
}

/* Opens the cargo trade window to allow the player to buy and sell cargo in the
   city. The price when selling to the city is always only 90% of the price when
   buying from the city. */
void tradecargo(UBYTE cn)
{
    cargonum=CargoGTags[3]=cn;
    CargoGTags[6]=(ULONG)currentship->name;
    CargoGTags[21]=(ULONG)currentcity->name;
    if (!OpenCargoWindow())
    {
        showcargostatus(currentship->cargo[cargonum], freespace(currentship),
            currentcity->price[cargonum], currentcity->supply[cargonum],
            currentcity->demand[cargonum]);
        while (HandleCargoIDCMP());
        CloseCargoWindow();
    }
}

/* Updates the status of the cargo window. Parameters: how much of this cargo we
   have on the ship, how much free space is there on the ship, how much does the
   cargo cost, how much is there left in the city, how much more does the city
   need. */
void showcargostatus(UWORD amount, UWORD space, UBYTE price, UWORD supply,
    UWORD demand)
{
    GT_SetGadgetAttrs(CargoGadgets[2], CargoWnd, NULL, GTNM_Number, amount,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[3], CargoWnd, NULL, GTNM_Number, space,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[5], CargoWnd, NULL, GTNM_Number, price,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[6], CargoWnd, NULL, GTNM_Number, supply,
        TAG_DONE);
    GT_SetGadgetAttrs(CargoGadgets[7], CargoWnd, NULL, GTNM_Number, demand,
        TAG_DONE);
}

/* Writes information about the cargo to the labels array, allowing it to be
   used in List1List, Items2List or Cargo3List. */
void makecargolist()
{
    struct ship *s;
    UBYTE i;
    if (InfoWnd)
        NewList(&List1List);
    if (TransferWnd)
    {
        NewList(&Items2List);
        s=shipa;
    }
    else
        s=currentship;
    for (i=0; i<13; i++)
    {
        if (i<12)
            sprintf(labels[i], "%14s %5d|%5d|%3d", CargoName4Labels[i],
                s->cargo[i], currentcity ? currentcity->supply[i] : 0,
                currentcity ? currentcity->price[i] : 0);
        else
            sprintf(labels[i], "Free space:    %5d", freespace(s));
        if (InfoWnd)
            AddTail(&List1List, &List1Nodes[i]);
        if (TransferWnd)
            AddTail(&Items2List, &List1Nodes[i]);
    }
}

/* Updates the cargo list and shows it on all relevant windows that are
   currently opened. */
void showcargolist()
{
    if (InfoWnd)
        GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
    if (CityWnd)
        GT_SetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
    if (currentship)
        makecargolist();
    else
    {
        NewList(&List1List);
        NewList(&Cargo3List);
    }
    if (InfoWnd)
        GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
            &List1List, TAG_DONE);
    if (CityWnd)
        GT_SetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Labels,
            &Cargo3List, TAG_DONE);
}

UBYTE getclasspic(UBYTE n)
{
    if (n<14)
        return 0;
    if (n<24)
        return 1;
    if (n<28)
        return 2;
    if (n<34)
        return 3;
    if (n<40)
        return 4;
    if (n<42)
        return 5;
    if (n<47)
        return 6;
    return 7;
}

void showshipclass(UBYTE n)
{
    BYTE i, found;
    GT_SetGadgetAttrs(BuyShipGadgets[0], BuyShipWnd, NULL, GTTX_Text,
        class[n].name, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[1], BuyShipWnd, NULL, GTNM_Number,
        class[n].weight, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[2], BuyShipWnd, NULL, GTNM_Number,
        class[n].maxcargo, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[3], BuyShipWnd, NULL, GTNM_Number,
        class[n].cabins, TAG_DONE);
    if (class[n].docks)
        sprintf(dockstring, "%d * %d kg", class[n].docks, class[n].docksize);
    else
        sprintf(dockstring, "None");
    GT_SetGadgetAttrs(BuyShipGadgets[4], BuyShipWnd, NULL, GTTX_Text,
        dockstring, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[5], BuyShipWnd, NULL, GTNM_Number,
        (240*class[n].engine)/class[n].weight, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[6], BuyShipWnd, NULL, GTNM_Number,
        class[n].price, TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[7], BuyShipWnd, NULL, GTNM_Number, money,
        TAG_DONE);
    GT_SetGadgetAttrs(BuyShipGadgets[8], BuyShipWnd, NULL, GA_Disabled,
        money<class[n].price, TAG_DONE);
    if (!n)
        GT_SetGadgetAttrs(BuyShipGadgets[9], BuyShipWnd, NULL, GA_Disabled,
            TRUE, TAG_DONE);
    else
    {
        found=FALSE;
        for (i=n-1; i>-1; i--)
            if (currentcity->shipsavailable[i])
            {
                found=TRUE;
                break;
            }
        GT_SetGadgetAttrs(BuyShipGadgets[9], BuyShipWnd, NULL, GA_Disabled,
            !found, TAG_DONE);
    }
    if (n==55)
        GT_SetGadgetAttrs(BuyShipGadgets[10], BuyShipWnd, NULL, GA_Disabled,
            TRUE, TAG_DONE);
    else
    {
        found=FALSE;
        for (i=n+1; i<56; i++)
            if (currentcity->shipsavailable[i])
            {
                found=TRUE;
                break;
            }
        GT_SetGadgetAttrs(BuyShipGadgets[10], BuyShipWnd, NULL, GA_Disabled,
            !found, TAG_DONE);
    }
    DrawImage(BuyShipWnd->RPort, shipimage[getclasspic(n)], 18, 17);
    ClipBlit(&hidden_rp, 0, 2*n, BuyShipWnd->RPort, 6, 57, 56, 2, 0xC0);
    shipclass=n;
}

UBYTE selectshipclass()
{
    UBYTE i, found;
    found=FALSE;
    for (i=0; i<56; i++)
        if (currentcity->shipsavailable[i])
        {
            found=TRUE;
            break;
        }
    if (!found)
    {
        request(CityWnd, error, "The city \"%s\" has no\nships left.",
            proceed, currentcity->name);
        return (UBYTE)~0;
    }
    selected=(UBYTE)~0;
    if (!OpenBuyShipWindow())
    {
        DrawImage(&hidden_rp, classimage, 0, 0);
        showshipclass(i);
        while (HandleBuyShipIDCMP());
        CloseBuyShipWindow();
    }
    return selected;
}

void showtransferlist(UBYTE mode)
{
    GT_SetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    if (!mode)
        makecargolist();
    else
        createpersonlist(&Items2List, shipa, ~0);
    GT_SetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Labels,
        &Items2List, TAG_DONE);
    if (!mode)
        showtransfervalues(transfernum);
    else
        selectfirstperson();
    GT_SetGadgetAttrs(TransferGadgets[7], TransferWnd, NULL, GTNM_FrontPen,
        !mode, TAG_DONE);
    GT_SetGadgetAttrs(TransferGadgets[8], TransferWnd, NULL, GA_Disabled, mode,
        TAG_DONE);
}

void showtransfervalues(UBYTE n)
{
    GT_SetGadgetAttrs(TransferGadgets[2], TransferWnd, NULL, GTTX_Text,
        shipb->name, TAG_DONE);
    GT_SetGadgetAttrs(TransferGadgets[3], TransferWnd, NULL, GTNM_Number,
        freespace(shipb));
    GT_SetGadgetAttrs(TransferGadgets[7], TransferWnd, NULL, GTNM_Number,
        n!=~0 ? shipb->cargo[n] : 0);
}

void transfer(struct ship *firstship, struct ship *secondship)
{
    shipa=first=firstship; shipb=second=secondship;
    Ship2Labels[0]=first->name; Ship2Labels[1]=second->name;
    transfermode=0; transfernum=~0;
    if (!OpenTransferWindow())
    {
        showtransferlist(transfermode);
        showtransfervalues(transfernum);
        while (HandleTransferIDCMP());
        CloseTransferWindow();
    }
}

void selectfirstperson()
{
    UBYTE i;
    GT_SetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Selected, 0,
        TAG_DONE);
    for (i=5; i<7; i++)
        GT_SetGadgetAttrs(TransferGadgets[i], TransferWnd, NULL, GA_Disabled,
            !shippeople, TAG_DONE);
    if (shippeople)
        currentperson=findperson(shipa, 0, ~0);
}

void transfercargo(struct ship *a, struct ship *b)
{
    UBYTE message[56];
    if (!transfermode)
    {
        if (transfernum==~0)
            return;
        if (freespace(b)<howmuch)
        {
            sprintf(message, "%s hasn't got enough\nspace left! (Only %d)",
                b->name, freespace(b));
            request(TransferWnd, error, message, proceed, NULL);
            return;
        }
        if (a->cargo[transfernum]<howmuch)
        {
            sprintf(message, "%s hasn't got enough\nof it! (Only %d)", a->name,
                a->cargo[transfernum]);
            request(TransferWnd, error, message, proceed, NULL);
            return;
        }
        a->cargo[transfernum]-=howmuch; b->cargo[transfernum]+=howmuch;
        showtransferlist(0);
    }
    else
    {
        if (shipb->crew + shipb->passengers == class[shipb->class].cabins)
        {
            request(TransferWnd, error, "%s has no free cabins!", proceed,
                shipb->name);
            return;
        }
        currentperson->location=shipb;
        if (gettype(currentperson)==CREW)
        {
            shipa->crew--; shipb->crew++;
        }
        else
        {
            shipa->passengers--; shipb->passengers++;
        }
        showtransferlist(1);
        selectfirstperson();
    }
}

void viewpeople(UBYTE mode)
{
    peoplemode=mode;
    PeopleGTags[1]=(ULONG)currentship->name;
    PeopleGTags[11]=(ULONG)currentcity->name;
    createpersonlist(&ShipList8List, currentship, mode?TOURIST:CREW);
    createpersonlist(&CityList8List, currentcity, mode?TOURIST:CREW);
    if (!OpenPeopleWindow())
    {
        cleartext();
        showtext();
        while (HandlePeopleIDCMP());
        ClosePeopleWindow();
    }
}

void addword(STRPTR line, UBYTE i, UBYTE l)
{
    if (textx >= 36-l)
    {
        texty++;
        textx=0;
    }
    CopyMem(line+(i-l), text[texty]+textx, l);
    textx+=l;
    if (textx<35)
    {
        text[texty][textx]=' ';
        textx++;
        text[texty][textx]='\0';
    }
    else
    {
        text[texty][textx]='\0';
        texty++;
        textx=0;
    }
}

void addtext(STRPTR line)
{
    UBYTE i, l;
    l=0;
    for (i=0; line[i]; i++)
        if (line[i]==' ')
        {
            addword(line, i, l);
            l=0;
        }
        else
            l++;
    addword(line, i, l);
}

void cleartext()
{
    UBYTE i;
    textx=texty=0;
    for (i=0; i<4; i++)
        text[i][0]='\0';
}

void showtext()
{
    UBYTE i;
    for (i=0; i<4; i++)
        GT_SetGadgetAttrs(PeopleGadgets[i+5], PeopleWnd, NULL, GTTX_Text,
            text[i], TAG_DONE);
}

int TransferCloseWindow()
{
    return FALSE;
}
int ModeClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(TransferGadgets[0], TransferWnd, NULL, GTCY_Active,
        &which, TAG_DONE);
    if (which!=transfermode)
    {
        transfermode=which;
        showtransferlist(transfermode);
    }
    return TRUE;
}
int ItemsClicked()
{
    ULONG n;
    UBYTE i;
    GT_GetGadgetAttrs(TransferGadgets[1], TransferWnd, NULL, GTLV_Selected,
        &n, TAG_DONE);
    if (!transfermode)
    {
        transfernum=(UBYTE)n;
        showtransfervalues(transfernum);
    }
    else
    {
        for (i=5; i<7; i++)
            GT_SetGadgetAttrs(TransferGadgets[i], TransferWnd, NULL,
                GA_Disabled, n>=shippeople, TAG_DONE);
        if (n<shippeople)
            currentperson=findperson(shipa, n, ~0);
    }
    return TRUE;
}
int ShipClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(TransferGadgets[4], TransferWnd, NULL, GTCY_Active,
        &which, TAG_DONE);
    if (!which)
        if (first!=shipa)
        {
            shipa=first; shipb=second;
            showtransferlist(transfermode);
        }
        else;
    else
        if (first==shipa)
        {
            shipb=first; shipa=second;
            showtransferlist(transfermode);
        }
    return TRUE;
}
int TransferOtherClicked()
{
    transfercargo(shipa, shipb);
    return TRUE;
}
int TransferThisClicked()
{
    transfercargo(shipb, shipa);
    return TRUE;
}
int HowMuchClicked()
{
    ULONG hm;
    GT_GetGadgetAttrs(TransferGadgets[8], TransferWnd, NULL, GTIN_Number, &hm,
        TAG_DONE);
    if (hm>65535)
    {
        hm=0;
        GT_SetGadgetAttrs(TransferGadgets[8], TransferWnd, NULL, GTIN_Number,
            0, TAG_DONE);
    }
    howmuch=hm;
    return TRUE;
}

int SelectClicked()
{
    struct ship *s;
    UWORD i;
    i=0;
    createlist((struct List *)&SelectShip6List);
    for (s=shiplist; s; s=s->next)
        if (s->location[0]==currentcity->location[0] &&
            s->location[1]==currentcity->location[1] &&
            s->location[2]==currentcity->location[2])
            addnode(i++, s->name, (struct List *)&SelectShip6List, FALSE);
    s=selectship();
    if (!s)
        return TRUE;
    if (s!=currentship)
    {
        currentship=s;
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text, s->name,
            TAG_DONE);
        showcargolist();
    }
    GT_SetGadgetAttrs(CityGadgets[6], CityWnd, NULL, GA_Disabled,
        s==&currentcity->store, TAG_DONE);
    return TRUE;
}

int SellClicked()
{
    struct person *p;
    UBYTE message[80];
    UWORD amount;
    UBYTE i;
    sprintf(message, "Selling your %s\nwill pay you %d.\nReally sell it?",
        class[currentship->class].name, (class[currentship->class].price*9)/10);
    if (request(CityWnd, "Confirmation", message, "Yes|No", NULL))
    {
        sprintf(message, ": The class %s ship \"%s\" was sold to %s.\n",
            class[currentship->class].name, currentship->name,
            currentcity->name);
        writelogdate();
        writelog(message);
        /* Try to find a suitable storing place for the cargo on this ship. */
        for (i=0; i<12; i++)
        {
            if (freespace(&currentcity->store) >= currentship->cargo[i])
                /* It fits in the city's storehouse, put it there */
                currentcity->store.cargo[i]+=currentship->cargo[i];
            else
            {
                /* It doesn't fit entirely in the city's storehouse, put as
                   much as possible there, then sell as much as possible, dump
                   the rest */
                currentship->cargo[i]-=freespace(&currentcity->store);
                currentcity->store.cargo[i]+=freespace(&currentcity->store);
                amount=currentcity->demand[i]<currentship->cargo[i] ?
                    currentcity->demand[i] : currentship->cargo[i];
                currentcity->supply[i]+=amount; currentcity->demand[i]-=amount;
                setmoney(money + (amount*currentcity->price[i]*9)/10);
            }
        }
        /* Put all the people onboard the current ship into the city's
           storehouse. BUG: Putting more than 255 crew members or more than 255
           passengers into the storehouse will cause undefined behaviour! Not
           that that is very likely to happen... */
        for (p=personlist; p; p=p->next)
            if (p->location==currentship)
            {
                p->location=&currentcity->store;
                if (gettype(p)==CREW)
                    currentcity->store.crew++;
                else
                    currentcity->store.passengers++;
            }
        currentcity->shipsavailable[currentship->class]++;
        setmoney(money + (class[currentship->class].price*9)/10);
        deleteship(currentship);
        currentship=&currentcity->store;
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text,
            currentship->name, TAG_DONE);
        showcargolist();
        GT_SetGadgetAttrs(CityGadgets[6], CityWnd, NULL, GA_Disabled, TRUE,
            TAG_DONE);
        showcargolist();
    }
    return TRUE;
}
int BuyClicked()
{
    UBYTE message[80];
    UBYTE n;
    n=selectshipclass();
    if (n!=~0)
    {
        currentcity->shipsavailable[n]--;
        setmoney(money-class[n].price);
        if (ship==shiplist)
            shiplist=NULL;
        ship=ship->prev; ship->next=NULL;
        currentship=createship(class[n].name, n);
        sprintf(message, ": A new %s class ship was bought from %s.\n",
            class[n].name, currentcity->name);
        writelogdate();
        writelog(message);
        setshipmoves(speed(currentship)/(15.0*increment));
        GT_SetGadgetAttrs(CityGadgets[3], CityWnd, NULL, GTTX_Text,
            currentship->name, TAG_DONE);
        GT_SetGadgetAttrs(CityGadgets[6], CityWnd, NULL, GA_Disabled, FALSE,
            TAG_DONE);
        CopyMem(currentcity->location, currentship->location, 3);
        showcargolist();
        findslowest();
        setshipmoves(4.0*speed(currentship)/slowest);
        ship->next=&currentcity->store; currentcity->store.prev=ship;
        ship=&currentcity->store;
    }
    return TRUE;
}
int CargoClicked()
{ return TRUE; }
int ViewCrewClicked()
{
    viewpeople(0);
    return TRUE;
}
int ViewPassengersClicked()
{
    viewpeople(1);
    return TRUE;
}
int ExitClicked()
{
    return FALSE;
}
int BuySellClicked()
{
    ULONG cn;
    if (!currentship)
        return;
    GT_GetGadgetAttrs(CityGadgets[8], CityWnd, NULL, GTLV_Selected, &cn,
        TAG_DONE);
    if (cn!=~0 && cn<12)
        tradecargo(cn);
    else
        tradecargo(0);
    return TRUE;
}
int CityTransferClicked()
{
    struct ship *s;
    UWORD i;
    i=0;
    createlist((struct List *)&SelectShip6List);
    for (s=shiplist; s; s=s->next)
        if (s->location[0]==currentcity->location[0] &&
            s->location[1]==currentcity->location[1] &&
            s->location[2]==currentcity->location[2])
            addnode(i++, s->name, (struct List *)&SelectShip6List, TRUE);
    s=selectship();
    if (s)
        transfer(currentship, s);
    return TRUE;
}

int CargoNameClicked()
{
    ULONG cn;
    GT_GetGadgetAttrs(CargoGadgets[0], CargoWnd, NULL, GTCY_Active, &cn,
        TAG_DONE);
    cargonum=cn;
    showcargostatus(currentship->cargo[cargonum], freespace(currentship),
        currentcity->price[cargonum], currentcity->supply[cargonum],
        currentcity->demand[cargonum]);
    return TRUE;
}
int CargoHowMuchClicked()
{
    ULONG hm;
    GT_GetGadgetAttrs(CargoGadgets[8], CargoWnd, NULL, GTIN_Number, &hm,
        TAG_DONE);
    if (hm>65535)
    {
        hm=0;
        GT_SetGadgetAttrs(CargoGadgets[8], CargoWnd, NULL, GTIN_Number, 0,
            TAG_DONE);
    }
    howmuch=hm;
    return TRUE;
}
int CargoBuyClicked()
{
    UBYTE number[11];
    if (money < howmuch*currentcity->price[cargonum])
    {
        sprintf(number, "%d", money);
        request(CargoWnd, error, "You haven't got enough money\n(Only %s)",
            proceed, number);
        return TRUE;
    }
    if (freespace(currentship) < howmuch)
    {
        sprintf(number, "%d", freespace(currentship));
        request(CargoWnd, error, "You haven't got enough space\nfor it "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    if ((ULONG)currentship->cargo[cargonum]+(ULONG)howmuch > 65535)
    {
        sprintf(number, "%d", 65535-currentship->cargo[cargonum]);
        request(CargoWnd, error, "You can't fit enough of that\ncargo "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    if (currentcity->supply[cargonum] < howmuch)
    {
        sprintf(number, "%d", currentcity->supply[cargonum]);
        request(CargoWnd, error, "The city's supply is not large\nenough "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    setmoney(money-howmuch*currentcity->price[cargonum]);
    currentship->cargo[cargonum]+=howmuch;
    currentcity->supply[cargonum]-=howmuch;
    currentcity->demand[cargonum]+=howmuch;
    citydiff[cityn][cargonum]+=howmuch;
    showcargostatus(currentship->cargo[cargonum], freespace(currentship),
        currentcity->price[cargonum], currentcity->supply[cargonum],
        currentcity->demand[cargonum]);
    showcargolist();
    return TRUE;
}
int CargoSellClicked()
{
    UBYTE number[6];
    if (currentship->cargo[cargonum] < howmuch)
    {
        sprintf(number, "%d", currentship->cargo[cargonum]);
        request(CargoWnd, error, "You haven't got enough cargo\n"
            "(Only %s)", proceed, number);
        return TRUE;
    }
    if (currentcity->demand[cargonum] < howmuch)
    {
        sprintf(number, "%d", currentcity->demand[cargonum]);
        request(CargoWnd, error, "The city's demand is not large\nenough "
            "(Only %s)", proceed, number);
        return TRUE;
    }
    /* Selling price is always only 90% of buying price! Taxes, you know. */
    setmoney(money + ((howmuch*currentcity->price[cargonum])*9)/10);
    currentship->cargo[cargonum]-=howmuch;
    currentcity->supply[cargonum]+=howmuch;
    currentcity->demand[cargonum]-=howmuch;
    citydiff[cityn][cargonum]-=howmuch;
    showcargostatus(currentship->cargo[cargonum], freespace(currentship),
        currentcity->price[cargonum], currentcity->supply[cargonum],
        currentcity->demand[cargonum]);
    showcargolist();
    return TRUE;
}
int CargoCloseWindow()
{
    return FALSE;
}

int ShipBuyClicked()
{
    UBYTE message[79];
    sprintf(message,
        "A new %s costs %d.\nMoney left: %d\nAre you sure to buy it?",
        class[shipclass].name, class[shipclass].price, money);
    if (request(BuyShipWnd, "Confirmation", message, "Yes|No", NULL))
    {
        selected=shipclass;
        return FALSE;
    }
    return TRUE;
}
int PreviousClicked()
{
    UBYTE i;
    for (i=shipclass-1; !currentcity->shipsavailable[i]; i--);
    showshipclass(i);
    return TRUE;
}
int NextClicked()
{
    UBYTE i;
    for (i=shipclass+1; !currentcity->shipsavailable[i]; i++);
    showshipclass(i);
    return TRUE;
}
int BuyShipCloseWindow()
{
    return FALSE;
}

int SelectShipClicked()
{
    ULONG number;
    GT_GetGadgetAttrs(SelectGadgets[0], SelectWnd, NULL, GTLV_Selected, &number,
        TAG_DONE);
    selected=number;
    return FALSE;
}
int SelectCloseWindow()
{
    return FALSE;
}

int PeopleCloseWindow()
{
    return FALSE;
}

int ShipListClicked()
{
    UBYTE message[45];
    LONG sel;
    GT_GetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected, &sel,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected, ~0,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[4], PeopleWnd, NULL, GA_Disabled,
        sel>=shippeople, TAG_DONE);
    if (sel<shippeople)
    {
        currentperson=findperson(currentship, sel, peoplemode?TOURIST:CREW);
        showperson(currentperson);
    }
    else
    {
        sprintf(message, "Your ship \"%s\" has %2d free cabins.",
            currentship->name, class[currentship->class].cabins-
            currentship->crew-currentship->passengers);
        cleartext();
        addtext(message);
        showtext();
        currentperson=NULL;
    }
    return TRUE;
}
int CityListClicked()
{
    LONG sel;
    GT_GetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected, &sel,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected, ~0,
        TAG_DONE);
    GT_SetGadgetAttrs(PeopleGadgets[4], PeopleWnd, NULL, GA_Disabled, FALSE,
        TAG_DONE);
    currentperson=findperson(currentcity, sel, peoplemode?TOURIST:CREW);
    showperson(currentperson);
    return TRUE;
}
int MoveClicked()
{
    UBYTE moved=FALSE;
    if (!currentperson)
        return TRUE;
    if (currentperson->location==currentship)
        if (gettype(currentperson)==PASSENGER)
            request(PeopleWnd, error, "You have a contract\nwith %s!", proceed,
                currentperson->name);
        else
        {
            currentperson->location=currentcity;
            if (gettype(currentperson)==CREW)
                currentship->crew--;
            else
            {
                currentship->passengers--;
                settype(currentperson, TOURIST);
            }
            setloc(currentperson, cityn);
            moved=TRUE;
        }
    else
    {
        if (class[currentship->class].cabins == currentship->crew +
            currentship->passengers)
        request(PeopleWnd, error, "You have no free cabins left!", proceed,
            NULL);
        else
        {
            currentperson->location=currentship;
            if (gettype(currentperson)==CREW)
                currentship->crew++;
            else
                currentship->passengers++;
            setloc(currentperson, 128);
            moved=TRUE;
        }
    }
    if (moved)
    {
        GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
        GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Labels,
            (struct List *)~0, TAG_DONE);
        createpersonlist(&ShipList8List, currentship, peoplemode?TOURIST:CREW);
        createpersonlist(&CityList8List, currentcity, peoplemode?TOURIST:CREW);
        GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Labels,
            &ShipList8List, TAG_DONE);
        GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Labels,
            &CityList8List, TAG_DONE);
        if (currentperson->location==currentship)
        {
            GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected,
                rfindperson(currentship, currentperson,
                gettype(currentperson)), TAG_DONE);
            GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected,
                ~0, TAG_DONE);
        }
        else
        {
            GT_SetGadgetAttrs(PeopleGadgets[3], PeopleWnd, NULL, GTLV_Selected,
                rfindperson(currentcity, currentperson,
                gettype(currentperson)), TAG_DONE);
            GT_SetGadgetAttrs(PeopleGadgets[1], PeopleWnd, NULL, GTLV_Selected,
                ~0, TAG_DONE);
        }
    }
    return TRUE;
}
