/* Project and source code (c) Copyright by Joona Palaste */
/* Licenced under GNU GPL 3.0                             */

/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : JIPsoft (Joona I Palaste)
 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <libraries/asl.h>
#include <libraries/dos.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <math.h>

#include "SeaTrade.h"
#include "SeaTrade_extern.h"

struct class class[57] = {
    {"Spider", 200, 30, 1, 350, 0, 0, 20300},
    {"Butterfly", 200, 50, 1, 250, 0, 0, 24500},
    {"Scorpion", 250, 50, 1, 500, 0, 0, 26500},
    {"Sparrow", 350, 40, 1, 1050, 0, 0, 28400},
    {"Tarantula", 200, 70, 1, 150, 0, 0, 28700},
    {"Hornet", 250, 70, 1, 400, 0, 0, 30700},
    {"Dragonfly", 200, 90, 1, 50, 0, 0, 32900},
    {"Kingfisher", 250, 90, 1, 300, 0, 0, 34900},
    {"Raven", 350, 80, 1, 850, 0, 0, 36800},
    {"Hawk", 350, 70, 2, 400, 0, 0, 40700},
    {"Crow", 350, 100, 1, 750, 0, 0, 41000},
    {"Hummingbird", 250, 120, 1, 150, 0, 0, 41200},
    {"Eagle", 350, 80, 2, 350, 0, 0, 42800},
    {"Falcon", 400, 100, 2, 500, 0, 0, 49000},
    {"Viper", 600, 70, 2, 1650, 0, 0, 50700},
    {"Boa", 600, 50, 3, 1250, 0, 0, 52500},
    {"Albatross", 400, 150, 1, 750, 0, 0, 53500},
    {"Cobra", 600, 120, 1, 1900, 0, 0, 55200},
    {"Asp", 500, 100, 2, 1500, 0, 0, 57000},
    {"Wolf", 650, 80, 3, 1350, 0, 0, 60800},
    {"Dingo", 600, 120, 2, 1400, 0, 0, 61200},
    {"Mamba", 600, 150, 1, 1750, 0, 0, 61500},
    {"Cougar", 700, 90, 3, 1550, 0, 0, 64900},
    {"Cheetah", 650, 150, 2, 1500, 0, 0, 69500},
    {"Tiger", 1000, 120, 3, 2500, 1, 250, 96500},
    {"Lion", 1100, 130, 3, 2950, 1, 250, 102600},
    {"Lynx", 1100, 120, 3, 3000, 1, 300, 103000},
    {"Basilisk", 1200, 150, 4, 2850, 1, 300, 119300},
    {"Manticore", 1500, 100, 5, 4100, 1, 300, 126800},
    {"Centaur", 1600, 90, 5, 4650, 1, 320, 129700},
    {"Unicorn", 1600, 100, 5, 4600, 1, 300, 130800},
    {"Griffin", 1600, 100, 5, 4500, 1, 320, 131800},
    {"Sphinx", 1600, 120, 5, 4500, 1, 320, 136000},
    {"Chimaera", 1700, 160, 5, 4800, 1, 320, 148400},
    {"Wyvern", 2000, 160, 7, 5300, 1, 350, 173900},
    {"Dragon", 2000, 200, 8, 4600, 1, 350, 188300},
    {"Supporter", 2200, 200, 8, 5600, 1, 360, 196800},
    {"Navigator", 2200, 220, 8, 5500, 1, 360, 201000},
    {"Courier", 2500, 250, 8, 6450, 2, 250, 227100},
    {"Clipper", 2500, 280, 8, 6300, 2, 250, 233400},
    {"Expeditor", 2700, 250, 10, 6450, 2, 280, 250100},
    {"Cruiser", 2700, 280, 10, 6300, 2, 280, 256400},
    {"Trader", 3000, 250, 10, 7950, 2, 300, 264100},
    {"Merchantman", 3200, 300, 10, 8700, 2, 320, 284600},
    {"Carrier", 3300, 320, 12, 8100, 2, 320, 304800},
    {"Voyager", 3400, 350, 10, 9450, 2, 360, 307100},
    {"Enterprise", 3400, 320, 12, 8600, 2, 350, 311800},
    {"Pluto", 4000, 300, 12, 11300, 3, 300, 342400},
    {"Mercury", 4100, 320, 12, 11700, 3, 320, 353600},
    {"Mars", 4100, 360, 12, 11500, 3, 320, 362000},
    {"Venus", 4200, 360, 12, 12000, 3, 350, 370500},
    {"Neptune", 4500, 320, 14, 12700, 3, 360, 387600},
    {"Uranus", 4800, 320, 12, 15200, 3, 400, 393600},
    {"Saturn", 4500, 360, 14, 12500, 3, 360, 396000},
    {"Jupiter", 4800, 360, 12, 15000, 3, 400, 402000},
    {"Solaris", 4800, 360, 14, 14000, 3, 400, 414000},
    {"", 0, 0, 255, 65535, 0, 0, 0} /* Store - not a real ship class! */
};
/* DICE C does not allow defining more than 32768 bytes of automatic file-scope
   variables. 128 instances of struct city would take up 29952 bytes, not
   leaving enough for all other variables. Therefore we only define 128
   instances of struct citystub, which is basically a city without a ship. This
   only takes up 12032 bytes, leaving plenty of space for the other variables.
*/
struct city *city;
struct citystub citystub[128]= {
    {"Umacka", {15, 8, 21}, 3, {24, 26, 24, 98, 30, 39, 73, 37, 14, 12, 5, 20}, {4, 7, 8, 10, 13, 21, 27, 30, 33, 38, 40, 46, 48, 52}},
    {"Serfrod", {0, 176, 25}, 0, {21, 16, 58, 65, 18, 38, 66, 57, 10, 13, 5, 20}, {1, 9, 12, 15, 18, 20, 21, 27, 28, 40, 47, 49, 51, 54}},
    {"Ialer", {8, 140, 40}, 0, {19, 16, 62, 65, 18, 36, 75, 62, 10, 14, 5, 20}, {8, 11, 13, 15, 16, 23, 30, 33, 34, 39, 40, 43, 47, 48}},
    {"Tornild", {5, 220, 46}, 0, {21, 18, 60, 63, 19, 37, 66, 62, 10, 13, 5, 20}, {1, 5, 6, 16, 17, 25, 28, 31, 34, 44, 47, 50, 51, 53}},
    {"Undiq", {6, 84, 49}, 0, {18, 16, 60, 70, 19, 33, 71, 59, 11, 14, 5, 20}, {3, 4, 16, 18, 22, 23, 27, 31, 38, 46, 49, 52, 54, 55}},
    {"Ineeng", {10, 28, 49}, 0, {20, 18, 56, 64, 18, 35, 74, 65, 9, 12, 5, 20}, {3, 11, 15, 20, 25, 32, 33, 34, 38, 39, 43, 44, 52, 55}},
    {"Aldily", {14, 124, 63}, 3, {24, 27, 29, 90, 27, 35, 65, 36, 14, 14, 5, 20}, {3, 6, 19, 21, 25, 26, 27, 31, 33, 35, 37, 42, 45, 46}},
    {"Aldtory", {10, 124, 68}, 0, {21, 19, 58, 65, 19, 36, 64, 62, 9, 14, 5, 20}, {14, 16, 17, 23, 26, 29, 30, 34, 37, 44, 45, 47, 48, 50}},
    {"Ageold", {5, 188, 71}, 0, {19, 19, 58, 63, 18, 36, 63, 58, 10, 14, 5, 20}, {11, 14, 17, 18, 30, 31, 32, 36, 37, 46, 50, 51, 52, 53}},
    {"Nyenn", {6, 176, 71}, 0, {21, 18, 59, 63, 18, 39, 74, 66, 10, 14, 5, 20}, {2, 4, 8, 18, 20, 23, 25, 30, 31, 32, 37, 40, 45, 48}},
    {"Warem", {10, 0, 71}, 0, {19, 16, 62, 72, 17, 35, 78, 63, 9, 14, 5, 20}, {1, 5, 8, 18, 19, 32, 34, 37, 42, 45, 47, 49, 53, 54}},
    {"Quanas", {10, 52, 84}, 0, {19, 18, 59, 72, 17, 35, 72, 56, 10, 13, 5, 20}, {3, 7, 10, 11, 22, 25, 28, 29, 34, 37, 38, 44, 51, 54}},
    {"Ackunn", {2, 120, 98}, 0, {20, 19, 61, 68, 17, 36, 71, 64, 9, 13, 5, 20}, {4, 5, 9, 10, 24, 26, 32, 35, 40, 46, 47, 50, 52, 53}},
    {"Esslet", {13, 208, 115}, 3, {24, 25, 24, 95, 29, 34, 77, 33, 16, 14, 5, 20}, {4, 7, 9, 24, 27, 28, 35, 38, 39, 40, 44, 45, 50, 55}},
    {"Veslere", {2, 8, 120}, 0, {19, 17, 65, 74, 19, 35, 74, 66, 10, 14, 5, 20}, {3, 4, 8, 19, 27, 31, 32, 33, 35, 37, 39, 43, 44, 50}},
    {"Schyim", {1, 112, 146}, 0, {19, 16, 62, 76, 18, 33, 76, 62, 9, 12, 5, 20}, {7, 10, 20, 21, 31, 32, 33, 34, 35, 37, 46, 47, 48, 55}},
    {"Swolar", {7, 96, 172}, 0, {18, 16, 59, 70, 17, 40, 75, 65, 10, 13, 5, 20}, {2, 5, 6, 12, 16, 17, 20, 22, 23, 25, 28, 39, 51, 55}},
    {"Aughpol", {7, 20, 179}, 0, {20, 19, 56, 67, 17, 39, 66, 64, 9, 13, 5, 20}, {0, 1, 7, 8, 9, 11, 16, 28, 29, 31, 33, 44, 46, 54}},
    {"Essran", {11, 152, 196}, 3, {24, 24, 26, 103, 31, 34, 72, 37, 15, 12, 5, 20}, {0, 1, 2, 6, 7, 15, 21, 32, 36, 38, 45, 46, 53, 55}},
    {"Ineray", {3, 20, 220}, 0, {21, 18, 67, 65, 17, 35, 70, 56, 10, 14, 5, 20}, {0, 1, 5, 14, 17, 21, 27, 29, 34, 35, 38, 45, 47, 48}},
    {"Yaenth", {11, 108, 222}, 3, {27, 26, 28, 91, 26, 38, 66, 35, 15, 12, 5, 20}, {7, 14, 21, 23, 24, 28, 29, 33, 35, 37, 40, 43, 48, 53}},
    {"Emano", {9, 164, 228}, 0, {21, 19, 61, 69, 20, 34, 74, 65, 9, 14, 5, 20}, {5, 8, 14, 16, 27, 30, 32, 40, 44, 46, 50, 53, 54, 55}},
    {"Hatcdar", {9, 12, 236}, 0, {22, 18, 54, 67, 19, 37, 78, 59, 9, 14, 5, 20}, {2, 4, 8, 12, 22, 23, 27, 29, 33, 39, 43, 48, 50, 54}},
    {"Raystai", {11, 56, 236}, 3, {24, 24, 24, 94, 27, 35, 74, 33, 13, 13, 5, 20}, {7, 10, 13, 14, 23, 24, 26, 33, 34, 38, 42, 43, 49, 50}},
    {"Morhat", {5, 212, 237}, 0, {21, 18, 64, 65, 20, 39, 70, 65, 9, 14, 5, 20}, {3, 10, 11, 13, 16, 17, 19, 20, 27, 34, 43, 45, 48, 51}},
    {"Etqua", {10, 208, 244}, 3, {28, 25, 28, 84, 27, 35, 72, 38, 15, 14, 5, 20}, {1, 4, 12, 13, 14, 18, 22, 27, 32, 35, 44, 48, 53, 55}},
    {"Atque", {12, 172, 253}, 3, {27, 27, 25, 103, 28, 37, 68, 32, 14, 14, 5, 20}, {1, 8, 11, 15, 20, 27, 34, 39, 40, 41, 46, 47, 48, 51}},
    {"Hatina", {11, 9, 4}, 3, {26, 26, 29, 97, 26, 35, 76, 37, 13, 14, 5, 20}, {4, 5, 6, 7, 9, 14, 18, 24, 25, 31, 32, 37, 42, 48}},
    {"Queageo", {12, 53, 8}, 3, {23, 26, 25, 93, 30, 39, 66, 35, 15, 14, 5, 20}, {2, 3, 5, 10, 12, 14, 20, 27, 32, 43, 44, 53, 54, 55}},
    {"Daruk", {9, 29, 15}, 2, {18, 19, 43, 99, 46, 22, 50, 42, 9, 16, 5, 20}, {1, 2, 5, 9, 17, 19, 25, 29, 30, 38, 40, 41, 43, 48}},
    {"Ardale", {13, 29, 18}, 3, {28, 27, 25, 96, 26, 38, 66, 35, 15, 14, 5, 20}, {2, 4, 7, 8, 12, 13, 14, 15, 17, 22, 24, 36, 43, 55}},
    {"Alehas", {12, 157, 27}, 3, {27, 24, 26, 91, 26, 35, 75, 36, 16, 14, 5, 20}, {7, 10, 13, 22, 26, 30, 31, 37, 41, 42, 46, 47, 54, 55}},
    {"Tiagar", {14, 253, 40}, 4, {18, 32, 44, 71, 39, 47, 49, 42, 9, 13, 5, 20}, {11, 15, 17, 19, 20, 23, 25, 28, 34, 35, 36, 51, 53, 55}},
    {"Nyray", {8, 201, 45}, 2, {20, 19, 41, 96, 44, 22, 56, 47, 11, 17, 5, 20}, {2, 14, 20, 23, 25, 28, 29, 30, 32, 39, 42, 46, 47, 54}},
    {"Tusam", {9, 25, 52}, 2, {21, 18, 43, 91, 43, 23, 56, 50, 10, 18, 5, 20}, {3, 10, 13, 17, 20, 22, 28, 35, 39, 43, 44, 46, 51, 53}},
    {"Shyaldy", {8, 173, 66}, 2, {20, 19, 44, 94, 42, 25, 54, 47, 10, 17, 5, 20}, {2, 4, 9, 12, 13, 21, 30, 34, 37, 38, 41, 46, 47, 49}},
    {"Teaugh", {9, 253, 77}, 2, {21, 17, 38, 99, 45, 24, 55, 43, 10, 19, 5, 20}, {5, 10, 11, 12, 22, 25, 33, 36, 38, 39, 41, 42, 48, 55}},
    {"Kellye", {12, 97, 77}, 3, {26, 24, 26, 99, 28, 36, 67, 34, 15, 13, 5, 20}, {0, 4, 12, 17, 18, 19, 20, 26, 28, 32, 35, 44, 47, 50}},
    {"Urnaugh", {6, 169, 80}, 0, {20, 18, 61, 67, 19, 34, 76, 64, 10, 14, 5, 20}, {9, 10, 11, 14, 23, 26, 28, 30, 32, 34, 43, 46, 52, 54}},
    {"Joer", {6, 69, 82}, 0, {20, 19, 60, 65, 19, 39, 77, 67, 10, 12, 5, 20}, {0, 1, 14, 15, 17, 19, 22, 31, 33, 40, 47, 49, 52, 55}},
    {"Aughys", {6, 241, 84}, 0, {21, 18, 54, 73, 20, 36, 78, 66, 10, 13, 5, 20}, {0, 8, 10, 16, 19, 23, 26, 27, 36, 37, 38, 45, 54, 55}},
    {"Nysback", {1, 89, 87}, 0, {18, 18, 59, 72, 17, 33, 75, 57, 9, 14, 5, 20}, {1, 10, 16, 19, 22, 30, 32, 36, 40, 46, 47, 48, 50, 53}},
    {"Oughwar", {14, 221, 97}, 4, {22, 31, 39, 74, 47, 51, 43, 43, 10, 14, 5, 20}, {0, 8, 11, 12, 14, 27, 28, 30, 36, 38, 46, 47, 52, 53}},
    {"Ildceri", {8, 145, 98}, 2, {19, 16, 37, 97, 45, 22, 48, 46, 10, 17, 5, 20}, {0, 10, 13, 15, 17, 19, 28, 29, 30, 35, 39, 45, 49, 55}},
    {"Danech", {11, 21, 100}, 3, {28, 27, 24, 100, 29, 36, 76, 33, 14, 15, 5, 20}, {0, 3, 17, 19, 20, 25, 31, 34, 35, 37, 45, 46, 48, 50}},
    {"Lorarr", {12, 37, 107}, 3, {27, 24, 25, 93, 26, 37, 69, 35, 13, 12, 5, 20}, {7, 10, 13, 27, 28, 31, 32, 33, 38, 39, 48, 52, 53, 54}},
    {"Umelma", {15, 101, 117}, 4, {18, 31, 39, 69, 39, 48, 48, 44, 10, 13, 5, 20}, {1, 2, 6, 11, 26, 27, 28, 34, 35, 42, 43, 50, 53, 54}},
    {"Essrald", {6, 193, 120}, 0, {18, 16, 59, 73, 18, 37, 73, 65, 10, 13, 5, 20}, {3, 4, 10, 11, 12, 17, 20, 27, 31, 34, 40, 42, 43, 50}},
    {"Lyehler", {1, 121, 122}, 0, {21, 19, 56, 75, 17, 40, 63, 65, 9, 14, 5, 20}, {6, 8, 9, 13, 14, 16, 25, 26, 27, 28, 44, 45, 47, 48}},
    {"Asrady", {11, 245, 124}, 3, {26, 24, 27, 97, 27, 34, 73, 37, 14, 13, 5, 20}, {0, 4, 7, 8, 13, 15, 22, 25, 26, 37, 43, 45, 46, 54}},
    {"Tanceri", {6, 117, 127}, 0, {18, 18, 62, 64, 17, 37, 67, 64, 10, 13, 5, 20}, {1, 9, 11, 16, 17, 22, 26, 27, 30, 32, 42, 44, 46, 54}},
    {"Nalart", {5, 229, 130}, 0, {18, 16, 66, 72, 19, 34, 70, 56, 9, 15, 5, 20}, {1, 3, 11, 12, 13, 14, 15, 22, 26, 29, 30, 45, 48, 49}},
    {"Darak", {8, 189, 137}, 2, {21, 19, 41, 97, 45, 25, 53, 50, 9, 16, 5, 20}, {2, 3, 8, 12, 13, 17, 24, 27, 32, 33, 45, 46, 51, 55}},
    {"Sulnala", {15, 33, 137}, 4, {20, 34, 42, 77, 44, 52, 47, 48, 9, 13, 5, 20}, {10, 12, 13, 15, 16, 17, 21, 25, 33, 36, 46, 48, 49, 52}},
    {"Esthelm", {0, 213, 139}, 0, {19, 19, 55, 74, 18, 39, 75, 60, 9, 14, 5, 20}, {3, 8, 15, 18, 20, 27, 28, 34, 37, 40, 44, 49, 51, 52}},
    {"Endryn", {6, 17, 141}, 0, {21, 19, 60, 65, 18, 37, 66, 62, 10, 14, 5, 20}, {2, 3, 6, 10, 18, 19, 21, 23, 38, 41, 42, 47, 51, 55}},
    {"Turet", {8, 149, 155}, 2, {18, 16, 42, 85, 39, 23, 48, 42, 10, 17, 5, 20}, {3, 5, 8, 12, 13, 25, 33, 35, 45, 46, 47, 48, 50, 55}},
    {"Worsaye", {15, 57, 168}, 4, {20, 35, 44, 63, 38, 45, 43, 42, 10, 13, 5, 20}, {0, 11, 13, 15, 17, 20, 28, 33, 36, 40, 44, 47, 49, 52}},
    {"Beldhat", {10, 53, 192}, 3, {28, 23, 27, 90, 30, 39, 63, 32, 13, 12, 5, 20}, {0, 6, 18, 19, 20, 23, 26, 28, 29, 31, 34, 38, 43, 54}},
    {"Ackvrod", {15, 93, 201}, 4, {22, 32, 45, 68, 39, 45, 49, 47, 10, 15, 5, 20}, {0, 1, 2, 5, 7, 8, 9, 16, 22, 27, 28, 47, 52, 55}},
    {"Sulinau", {9, 21, 214}, 2, {21, 18, 40, 84, 43, 22, 50, 51, 9, 16, 5, 20}, {15, 16, 17, 21, 23, 27, 33, 38, 42, 43, 45, 46, 47, 48}},
    {"Hinar", {8, 189, 215}, 2, {18, 18, 45, 97, 41, 25, 49, 47, 10, 19, 5, 20}, {0, 5, 11, 13, 16, 25, 28, 30, 34, 38, 39, 40, 42, 52}},
    {"Muyer", {10, 97, 218}, 3, {24, 26, 28, 91, 31, 38, 66, 37, 15, 13, 5, 20}, {2, 5, 7, 12, 36, 37, 39, 40, 41, 46, 47, 50, 51, 52}},
    {"Omtskel", {9, 141, 225}, 2, {21, 16, 39, 84, 40, 26, 57, 46, 9, 19, 5, 20}, {0, 13, 16, 17, 19, 25, 26, 30, 37, 38, 39, 40, 44, 49}},
    {"Worwia", {8, 93, 229}, 2, {20, 17, 40, 96, 39, 24, 49, 44, 10, 19, 5, 20}, {0, 5, 12, 13, 20, 25, 26, 29, 30, 37, 41, 43, 48, 55}},
    {"Shyessi", {12, 93, 234}, 3, {24, 27, 25, 94, 28, 36, 78, 37, 13, 15, 5, 20}, {3, 10, 12, 13, 18, 28, 29, 30, 32, 33, 34, 42, 44, 45}},
    {"Rannild", {13, 97, 239}, 3, {23, 25, 28, 90, 29, 35, 75, 32, 16, 14, 5, 20}, {1, 6, 12, 13, 14, 15, 22, 29, 35, 37, 38, 48, 52, 54}},
    {"Oldiro", {8, 189, 249}, 2, {22, 18, 37, 86, 39, 22, 52, 51, 10, 17, 5, 20}, {2, 3, 4, 8, 16, 19, 24, 25, 28, 31, 35, 37, 49, 52}},
    {"Cerdbur", {9, 66, 8}, 2, {19, 16, 39, 94, 41, 23, 51, 49, 9, 19, 5, 20}, {3, 10, 12, 13, 16, 18, 29, 31, 33, 38, 39, 41, 43, 52}},
    {"Poleldo", {15, 98, 8}, 4, {21, 32, 40, 67, 44, 48, 45, 42, 10, 13, 5, 20}, {9, 15, 16, 21, 27, 28, 30, 33, 34, 43, 46, 47, 48, 49}},
    {"Lohin", {4, 106, 9}, 1, {14, 24, 41, 143, 26, 39, 100, 47, 5, 10, 5, 20}, {4, 9, 15, 17, 21, 23, 25, 27, 28, 29, 39, 44, 48, 51}},
    {"Phyban", {10, 94, 9}, 2, {18, 19, 38, 99, 41, 23, 57, 48, 9, 17, 5, 20}, {1, 6, 8, 10, 19, 24, 31, 34, 41, 43, 51, 53, 54, 55}},
    {"Essray", {8, 74, 10}, 2, {21, 18, 38, 102, 46, 22, 49, 49, 10, 17, 5, 20}, {0, 1, 4, 6, 9, 13, 18, 21, 30, 35, 44, 45, 53, 54}},
    {"Agefund", {7, 18, 17}, 1, {14, 27, 42, 150, 29, 33, 89, 46, 5, 9, 5, 20}, {4, 8, 9, 19, 20, 21, 28, 31, 32, 34, 40, 41, 47, 49}},
    {"Ilddrae", {12, 222, 18}, 3, {25, 24, 27, 85, 31, 35, 74, 31, 15, 14, 5, 20}, {6, 8, 11, 12, 20, 22, 29, 34, 35, 37, 46, 49, 50, 55}},
    {"Kalit", {4, 30, 21}, 1, {15, 24, 39, 142, 26, 39, 103, 44, 6, 9, 5, 20}, {2, 8, 9, 12, 16, 21, 26, 30, 32, 35, 38, 49, 50, 52}},
    {"Chetcha", {8, 106, 23}, 2, {18, 18, 38, 92, 40, 23, 56, 43, 9, 18, 5, 20}, {3, 13, 14, 15, 17, 20, 22, 35, 36, 37, 38, 43, 48, 52}},
    {"Thrad", {7, 74, 29}, 1, {13, 24, 41, 132, 29, 37, 85, 50, 6, 10, 5, 20}, {1, 6, 9, 13, 18, 19, 20, 21, 31, 42, 43, 47, 51, 54}},
    {"Bakel", {8, 190, 29}, 2, {18, 16, 39, 95, 39, 23, 52, 51, 9, 16, 5, 20}, {2, 4, 13, 17, 22, 34, 36, 44, 45, 46, 49, 53, 54, 55}},
    {"Strucha", {9, 238, 39}, 2, {18, 19, 42, 87, 39, 26, 49, 46, 9, 18, 5, 20}, {3, 4, 9, 12, 13, 21, 24, 26, 33, 34, 36, 38, 46, 54}},
    {"Gether", {13, 194, 41}, 3, {24, 27, 24, 92, 27, 36, 63, 32, 15, 14, 5, 20}, {6, 9, 10, 11, 15, 16, 26, 29, 30, 32, 33, 37, 42, 48}},
    {"Shylor", {3, 194, 44}, 1, {13, 25, 44, 139, 26, 38, 94, 51, 5, 9, 5, 20}, {3, 5, 7, 15, 20, 28, 30, 35, 36, 39, 44, 45, 47, 52}},
    {"Quohat", {8, 98, 58}, 2, {18, 18, 40, 88, 43, 23, 55, 44, 9, 17, 5, 20}, {4, 10, 16, 17, 23, 29, 31, 35, 38, 39, 43, 45, 54, 55}},
    {"Agelund", {7, 94, 60}, 1, {15, 24, 44, 136, 29, 39, 103, 47, 5, 9, 5, 20}, {3, 5, 6, 23, 24, 25, 29, 32, 36, 40, 48, 49, 54, 55}},
    {"Agedar", {0, 54, 90}, 0, {18, 19, 62, 74, 17, 35, 66, 62, 9, 15, 5, 20}, {2, 3, 4, 7, 12, 16, 21, 24, 28, 29, 34, 39, 45, 48}},
    {"Nyesto", {7, 46, 93}, 1, {14, 25, 37, 142, 26, 34, 93, 43, 6, 10, 5, 20}, {0, 2, 5, 7, 26, 31, 32, 37, 38, 42, 46, 49, 50, 54}},
    {"Tanunt", {8, 142, 106}, 2, {19, 19, 45, 86, 46, 23, 54, 42, 9, 16, 5, 20}, {6, 7, 8, 10, 12, 14, 19, 21, 22, 26, 34, 35, 36, 37}},
    {"Orblye", {7, 42, 108}, 1, {14, 24, 42, 143, 29, 34, 85, 50, 6, 10, 5, 20}, {1, 17, 21, 22, 23, 25, 31, 34, 36, 39, 43, 44, 50, 51}},
    {"Schunt", {1, 82, 116}, 1, {15, 23, 45, 135, 26, 38, 84, 44, 6, 9, 5, 20}, {1, 5, 11, 15, 19, 25, 29, 30, 35, 38, 48, 49, 50, 52}},
    {"Torhin", {1, 234, 121}, 1, {13, 24, 44, 126, 29, 38, 86, 45, 5, 9, 5, 20}, {1, 15, 18, 19, 21, 25, 33, 35, 36, 40, 41, 45, 46, 54}},
    {"Riskinu", {6, 134, 124}, 1, {14, 27, 42, 143, 29, 33, 103, 48, 6, 9, 5, 20}, {0, 3, 5, 7, 13, 14, 15, 23, 25, 28, 32, 35, 38, 47}},
    {"Nalough", {9, 114, 128}, 2, {21, 18, 44, 99, 46, 25, 54, 51, 10, 16, 5, 20}, {0, 7, 8, 10, 13, 14, 19, 23, 31, 35, 36, 42, 44, 52}},
    {"Rhuit", {11, 158, 128}, 2, {21, 18, 40, 85, 40, 21, 50, 51, 10, 17, 5, 20}, {7, 9, 14, 15, 16, 19, 21, 26, 40, 44, 46, 50, 53, 54}},
    {"Hatynn", {6, 186, 130}, 1, {16, 25, 43, 139, 30, 36, 100, 43, 6, 11, 5, 20}, {2, 3, 6, 7, 8, 11, 15, 19, 25, 30, 33, 34, 47, 54}},
    {"Hinhtai", {13, 122, 144}, 4, {19, 33, 41, 74, 39, 47, 42, 43, 10, 13, 5, 20}, {2, 4, 9, 11, 12, 13, 16, 17, 29, 35, 36, 38, 47, 53}},
    {"Nyshin", {10, 98, 145}, 2, {19, 18, 44, 102, 38, 25, 47, 48, 9, 19, 5, 20}, {0, 3, 8, 12, 18, 27, 30, 42, 43, 46, 47, 48, 49, 55}},
    {"Ineiw", {10, 214, 147}, 2, {20, 19, 43, 84, 47, 23, 49, 48, 10, 17, 5, 20}, {2, 4, 5, 7, 8, 10, 16, 18, 25, 44, 47, 48, 49, 52}},
    {"Garwaru", {9, 206, 149}, 2, {19, 17, 36, 102, 44, 22, 55, 44, 9, 19, 5, 20}, {3, 6, 15, 17, 20, 24, 29, 31, 38, 39, 41, 43, 48, 52}},
    {"Thrisam", {9, 58, 157}, 2, {19, 18, 41, 99, 43, 25, 58, 51, 10, 19, 5, 20}, {0, 3, 6, 10, 11, 24, 25, 26, 28, 29, 33, 37, 43, 47}},
    {"Veseldi", {9, 22, 171}, 2, {21, 16, 43, 93, 38, 24, 57, 51, 9, 18, 5, 20}, {0, 2, 6, 12, 15, 16, 17, 22, 30, 42, 49, 50, 53, 54}},
    {"Enest", {12, 238, 192}, 4, {18, 34, 43, 67, 42, 45, 50, 45, 9, 14, 5, 20}, {2, 4, 15, 16, 20, 23, 26, 35, 39, 40, 42, 45, 47, 49}},
    {"Denas", {7, 102, 200}, 4, {19, 30, 42, 65, 42, 48, 43, 51, 11, 13, 5, 20}, {1, 17, 19, 21, 23, 26, 29, 33, 34, 36, 40, 49, 51, 53}},
    {"Tasurnu", {14, 190, 200}, 4, {20, 35, 36, 69, 46, 44, 46, 46, 9, 15, 5, 20}, {13, 15, 16, 17, 22, 24, 25, 27, 28, 30, 33, 43, 46, 54}},
    {"Tortan", {15, 154, 203}, 4, {21, 32, 39, 63, 43, 51, 46, 49, 9, 12, 5, 20}, {2, 3, 6, 12, 14, 17, 20, 21, 27, 29, 37, 41, 42, 50}},
    {"Endas", {11, 198, 215}, 4, {20, 33, 37, 63, 40, 50, 43, 47, 11, 13, 5, 20}, {8, 9, 12, 18, 23, 24, 25, 29, 36, 37, 41, 43, 49, 53}},
    {"Kinsim", {7, 94, 228}, 4, {20, 32, 45, 69, 44, 47, 46, 42, 9, 14, 5, 20}, {0, 1, 11, 18, 23, 36, 37, 39, 41, 45, 48, 49, 52, 53}},
    {"Ordum", {4, 114, 229}, 1, {15, 22, 40, 141, 26, 34, 90, 44, 5, 9, 5, 20}, {9, 10, 13, 15, 18, 22, 25, 27, 32, 33, 40, 47, 48, 53}},
    {"Wetin", {11, 98, 238}, 4, {20, 34, 44, 76, 44, 45, 42, 42, 10, 13, 5, 20}, {1, 5, 6, 17, 18, 19, 22, 24, 26, 27, 29, 40, 54, 55}},
    {"Achlor", {7, 90, 250}, 4, {21, 30, 42, 65, 43, 48, 47, 46, 9, 15, 5, 20}, {5, 8, 9, 12, 14, 16, 27, 34, 41, 44, 45, 46, 52, 54}},
    {"Adche", {9, 10, 253}, 4, {21, 32, 42, 70, 41, 49, 42, 49, 10, 12, 5, 20}, {3, 16, 21, 24, 25, 28, 31, 32, 34, 40, 43, 48, 50, 52}},
    {"Samtori", {4, 79, 2}, 1, {16, 25, 41, 152, 28, 35, 86, 50, 6, 9, 5, 20}, {3, 4, 9, 10, 16, 19, 21, 24, 27, 33, 46, 49, 50, 54}},
    {"Echnal", {6, 255, 10}, 4, {18, 31, 38, 68, 39, 48, 47, 45, 10, 14, 5, 20}, {1, 7, 12, 15, 16, 18, 25, 27, 30, 38, 39, 44, 47, 55}},
    {"Elmsach", {9, 75, 23}, 4, {21, 30, 43, 77, 38, 48, 44, 42, 10, 14, 5, 20}, {2, 3, 5, 8, 10, 11, 14, 21, 27, 31, 32, 45, 48, 52}},
    {"Ererr", {11, 67, 26}, 4, {18, 29, 43, 71, 42, 49, 45, 49, 10, 13, 5, 20}, {2, 3, 6, 9, 15, 18, 19, 20, 26, 29, 31, 51, 52, 55}},
    {"Undaz", {2, 87, 38}, 1, {14, 23, 39, 135, 28, 36, 87, 46, 5, 10, 5, 20}, {2, 4, 7, 11, 13, 20, 25, 28, 41, 46, 49, 50, 54, 55}},
    {"Deale", {10, 243, 39}, 4, {21, 34, 44, 63, 38, 53, 51, 46, 10, 13, 5, 20}, {5, 14, 16, 20, 24, 26, 29, 34, 35, 38, 40, 45, 50, 51}},
    {"Slear", {9, 75, 43}, 4, {21, 31, 38, 65, 43, 50, 45, 43, 10, 13, 5, 20}, {7, 9, 15, 16, 20, 24, 26, 31, 33, 34, 37, 39, 40, 45}},
    {"Achiv", {9, 247, 117}, 4, {21, 30, 37, 70, 43, 45, 47, 50, 10, 13, 5, 20}, {3, 6, 9, 17, 20, 21, 22, 27, 30, 41, 42, 46, 54, 55}},
    {"Ightmas", {10, 59, 125}, 4, {19, 34, 44, 66, 40, 52, 45, 44, 10, 13, 5, 20}, {2, 7, 8, 9, 16, 24, 25, 27, 30, 40, 43, 46, 53, 55}},
    {"Enas", {6, 147, 150}, 1, {15, 26, 43, 128, 31, 39, 88, 51, 6, 9, 5, 20}, {3, 7, 21, 24, 29, 31, 32, 33, 34, 36, 39, 47, 53, 54}},
    {"Echold", {6, 107, 173}, 1, {13, 25, 39, 132, 31, 38, 96, 45, 5, 9, 5, 20}, {0, 3, 12, 16, 17, 30, 34, 35, 36, 40, 43, 46, 52, 54}},
    {"Ascheri", {1, 75, 177}, 1, {13, 24, 41, 153, 30, 34, 87, 47, 6, 10, 5, 20}, {0, 16, 21, 26, 32, 33, 39, 43, 46, 47, 48, 49, 50, 55}},
    {"Mosyp", {12, 175, 178}, 4, {21, 32, 40, 70, 43, 52, 42, 50, 9, 14, 5, 20}, {8, 15, 23, 25, 28, 33, 36, 38, 41, 42, 48, 49, 50, 51}},
    {"Garwar", {1, 27, 201}, 1, {15, 23, 44, 129, 30, 38, 101, 51, 5, 10, 5, 20}, {6, 9, 11, 20, 21, 25, 26, 28, 36, 40, 46, 48, 49, 54}},
    {"Saysir", {1, 191, 207}, 1, {13, 26, 45, 138, 26, 38, 96, 50, 6, 9, 5, 20}, {2, 6, 10, 13, 14, 27, 31, 32, 33, 37, 45, 48, 53, 55}},
    {"Nyang", {8, 199, 209}, 1, {14, 23, 44, 150, 31, 35, 91, 47, 6, 9, 5, 20}, {1, 2, 5, 18, 19, 20, 25, 28, 29, 40, 44, 46, 51, 52}},
    {"Sulun", {14, 231, 215}, 4, {19, 33, 43, 70, 46, 53, 48, 47, 11, 15, 5, 20}, {1, 2, 3, 5, 6, 10, 11, 12, 21, 32, 33, 35, 38, 45}},
    {"Vibur", {1, 75, 220}, 1, {14, 26, 40, 141, 27, 40, 98, 47, 5, 9, 5, 20}, {3, 14, 17, 19, 20, 25, 40, 41, 44, 45, 46, 48, 49, 55}}
};
STRPTR months[12]={
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
    "Dec"
};
STRPTR firstnames[80]={
    "Al", "Alice", "Andy", "Angus", "Anna", "Anni", "Betty", "Bill", "Bob",
    "Bruce", "Carly", "Chloe", "Chuck", "Clara", "Cybil", "Dana", "David",
    "Dora", "Ed", "Emma", "Ethan", "Fred", "Gary", "Greg", "Hanna", "Harry",
    "Hugh", "Iggy", "Ike", "Jake", "James", "Jane", "Jason", "Jeff", "Jenny",
    "Joe", "John", "Julia", "Kate", "Kim", "Lara", "Larry", "Lars", "Linda",
    "Lisa", "Lois", "Louis", "Lucy", "Maria", "Marge", "Mary", "Mia", "Mike",
    "Mona", "Nancy", "Neil", "Nick", "Nora", "Pat", "Paul", "Peter", "Phil",
    "Pia", "Rob", "Roger", "Ron", "Ruth", "Sarah", "Selma", "Simon", "Spike",
    "Steve", "Susan", "Tanya", "Tim", "Tom", "Vera", "Wendy", "Zack", "Zoe"
};
STRPTR lastnames[80]={
    "Andrews", "Baker", "Barker", "Baube", "Bemis", "Blofeld", "Bond",
    "Braben", "Brogden", "Bush", "Carter", "Clinton", "Cokes", "Cullen",
    "Dalton", "Davies", "Delbo", "Drake", "Drougge", "Edwards", "Ferree",
    "Fillis", "Flynt", "Ford", "Froholt", "Furman", "Galan", "Gates", "Gordon",
    "Gore", "Grayson", "Green", "Guerra", "Haddock", "Hare", "Hefner",
    "Hickman", "Hill", "Hunt", "Jameson", "Johnson", "Jung", "Jurasik", "Lane",
    "Larsson", "Lennon", "Leno", "Lovejoy", "Loving", "Lowe", "Major", "Matz",
    "Miner", "Monroe", "Moore", "Morency", "Mulder", "Nash", "Nixon", "Peake",
    "Pilato", "Powers", "Quayle", "Ramshaw", "Reagan", "Rue", "Sawkins",
    "Schwarz", "Scully", "Sellers", "Senior", "Sepelak", "Smith", "Stanz",
    "Tennant", "Turner", "Venkman", "Wayne", "Welker", "Wildman"
};
STRPTR types[4]={"Crew", "Pass", "Pass", "Fail"};
STRPTR error="Error", proceed="Proceed", information="Information";
struct Image *image[423], *shipimage[8];
struct Image *panelimage, *citypanelimage, *shipviewimage, *classimage;
struct RastPort hidden_rp;
struct BitMap *hidden_bm=NULL;
struct Node *nodelist=NULL;
struct Node dockednodes[3];
struct Node freecabinsnode;
struct ship *shiplist, *ship, *currentship, *first, *second, *shipa, *shipb;
struct person *personlist, *person, *currentperson;
struct city *currentcity=NULL;
ULONG gametime, money, hour=1;
UWORD namesavailable[6400];
UWORD ships=0, howmuch, shipnum, selected, shipclass, namesleft=6400, persons=0;
WORD citydiff[128][12];
UBYTE text[4][36];
BYTE cargotype[5][12]={
    {0, -1, 2, -1, -2, 0, 0, 1, 0, 0, 0, 0},
    {-1, 0, 0, 2, 0, 0, 1, 0, -2, -1, 0, 0},
    {0, -1, 0, 0, 2, -2, -1, 0, 0, 1, 0, 0},
    {1, 0, -2, 0, 0, 0, 0, -1, 2, 0, 0, 0},
    {0, 1, 0, -1, 2, 1, -2, 0, 0, 0, 0, 0}
};
UBYTE latitude[8], longitude[8], datestr[21], shipnums[256], dockstring[11],
    freecabinstext[15], citiesknown[128];
UBYTE price[12] = {20, 25, 41, 94, 29, 37, 71, 47, 10, 14, 5, 20};
UBYTE *map;
WORD mapleft, maptop, reputation;
UBYTE autocenter=2, cargonum, transfermode=0, transfernum, peoplemode, textx,
    texty, shippeople, cityn, shipturn=0, infomode=0, skipflag=TRUE,
    cheatmode=FALSE, timeisfrozen=FALSE, fastautopilot=FALSE;
BYTE currentdockedship;
double increment, slowest;
APTR logfile=NULL;

struct Image *readimage(BPTR, UWORD, UWORD, UBYTE);
void freeimage(struct Image *);
void cleanup();
void coordinatestrings(STRPTR, STRPTR, UWORD, UWORD);
void showcargostatus(UWORD, UWORD, UBYTE, UWORD, UWORD);
void makecargolist();
void showcargolist();
void showtransfervalues(UBYTE);
void hourly();
void cleartext();
void addtext(STRPTR);
void showtext();
void datestring(STRPTR, ULONG);
void selectfirstperson();
void setmoney(ULONG);

/* Loads the graphics in the accompanying data files into struct Images. */
int loadgraphics()
{
    BPTR file;
    UWORD i;
    for (i=0; i<423; i++)
        image[i]=NULL;
    file=Open("SeaTrade.gfx", MODE_OLDFILE);
    if (!file)
        return NULL;
    for (i=0; i<423; i++)
        if (!(image[i]=readimage(file, 16, 16, 8)))
        {
            Close(file);
            cleanup();
            return NULL;
        }
    if (!(panelimage=readimage(file, 320, 256, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    if (!(citypanelimage=readimage(file, 320, 256, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    if (!(shipviewimage=readimage(file, 64, 64, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    for (i=0; i<8; i++)
        if (!(shipimage[i]=readimage(file, 32, 32, 8)))
        {
            Close(file);
            cleanup();
            return NULL;
        }
    if (!(classimage=readimage(file, 64, 112, 8)))
    {
        Close(file);
        cleanup();
        return NULL;
    }
    Close(file);
    InitRastPort(&hidden_rp);
    hidden_bm=AllocBitMap(320, 256, 8, BMF_CLEAR, NULL);
    hidden_rp.BitMap=hidden_bm;
    return TRUE;
}

/* Loads the palette in the accompanying data files into the screen's ViewPort.
*/
int loadpalette()
{
    BPTR file;
    UBYTE *data=NULL;
    if (!(data=AllocVec(3080, MEMF_CLEAR)))
        return NULL;
    file=Open("SeaTrade.pal", MODE_OLDFILE);
    if (!file)
    {
        FreeVec(data);
        return NULL;
    }
    if (Read(file, data, 3080)<3080)
    {
        Close(file);
        FreeVec(data);
        return NULL;
    }
    LoadRGB32(&(Scr->ViewPort), data);
    Close(file);
    FreeVec(data);
    return TRUE;
}

int allocstuff()
{
    BPTR file;
    map=NULL;
    city=NULL;
    UBYTE i;
    if (!(map=AllocVec(393216, MEMF_CLEAR)))
        return FALSE;
    if (!(file=Open("IslandMap.dat", MODE_OLDFILE)))
    {
        FreeVec(map); map=NULL;
        return FALSE;
    }
    Read(file, map, 393216);
    Close(file);
    if (!(city=AllocVec(128*sizeof(struct city), MEMF_CLEAR)))
    {
        FreeVec(map); map=NULL;
        return FALSE;
    }
    for (i=0; i<128; i++)
        CopyMem(&citystub[i], city+i, sizeof(struct citystub));
    return TRUE;
}

void cleanup()
{
    UWORD i;
    for (i=0; i<423; i++)
        freeimage(image[i]);
    freeimage(panelimage);
    freeimage(citypanelimage);
    freeimage(shipviewimage);
    for (i=0; i<8; i++)
        freeimage(shipimage[i]);
    freeimage(classimage);
    if (map)
        FreeVec(map);
    freeships();
    freepersons();
    if (hidden_bm)
    {
        FreeBitMap(hidden_bm);
        hidden_bm=NULL;
    }
    if (city)
        FreeVec(city);
}

/* Reads a fully usable struct Image from the specified filehandle. Specify
   image dimensions and depth. After use, first FreeVec(image->ImageData),
   then FreeVec(image). */
struct Image *readimage(BPTR file, UWORD width, UWORD height, UBYTE depth)
{
    struct Image *image;
    UWORD *imagedata;
    ULONG size;
    if (!(image=AllocVec((ULONG)sizeof(struct Image), MEMF_CHIP)))
        return NULL;
    if ((width&15)==0)
        size=width*height*depth/8;
    else
        size=((width&1008)+16)*height*depth/8;
    if (!(imagedata=AllocVec(size, MEMF_CHIP)))
    {
        FreeVec(image);
        return NULL;
    }
    if (!Read(file, imagedata, size))
    {
        FreeVec(image); FreeVec(imagedata);
        return NULL;
    }
    image->LeftEdge=0; image->TopEdge=0; image->Width=width;
    image->Height=height;
    image->Depth=depth; image->ImageData=(UWORD *)imagedata;
    image->PlanePick=(1<<depth)-1; image->PlaneOnOff=0; image->NextImage=NULL;
    return image;
}

/* Safely frees the given struct Image. If called with a nonexistent image
   (NULL pointer), does nothing. */
void freeimage(struct Image *image)
{
    if (image)
    {
        FreeVec(image->ImageData); image->ImageData=NULL;
        FreeVec(image);
    }
}

/* Displays any given request with Intution EasyRequesters. */
UBYTE request(struct Window *window, STRPTR title, STRPTR text, STRPTR buttons,
    APTR arg)
{
    struct EasyStruct req;
    req.es_StructSize=sizeof(struct EasyStruct);
    req.es_Flags=0; req.es_Title=title;
    req.es_TextFormat=text; req.es_GadgetFormat=buttons;
    return EasyRequest(window, &req, NULL, arg);
}

/* Allocates and shows an ASL request, and allows the user to choose a file.
   Returns the chosen filename in the UBYTE * buffer supplied in the second
   parameter. */
int aslreq(UBYTE savemode, UBYTE *namebuffer)
{
    STRPTR blurb, label;
    UBYTE *p;
    UBYTE result, c=0;
    struct FileRequester *fr=NULL;
    switch (savemode)
    {
        case FALSE:
        blurb="Choose a file to load:"; label="Load";
        break;
        case TRUE:
        blurb="Choose a file to save:"; label="Save";
        break;
        case 2:
        blurb="Choose a log file:"; label="OK";
        break;
    }
    if (fr=AllocAslRequestTags(ASL_FileRequest,
        ASLFR_Window, SeaTradeWnd,
        ASLFR_TitleText, blurb,
        ASLFR_PositiveText, label,
        ASLFR_NegativeText, (STRPTR)"Cancel",
        ASLFR_InitialHeight, 224,
        ASLFR_InitialWidth, 240,
        ASLFR_InitialLeftEdge, 40,
        ASLFR_InitialTopEdge, 20,
        ASLFR_DoSaveMode, (BOOL)!!savemode,
        TAG_DONE))
    {
        if (result=AslRequest(fr, NULL))
        {
            for (p=fr->rf_Dir; *p; p++);
                if (p>fr->rf_Dir)
                    c=*(p-1);
                if (c==':' || !c)
                    sprintf(namebuffer,"%s%s", fr->rf_Dir, fr->rf_File);
                else
                    sprintf(namebuffer,"%s/%s", fr->rf_Dir, fr->rf_File);
        }
        FreeAslRequest(fr);
    }
    return result;
}

/* Finds out the size of the file associated with the given handle. Uses an
   AmigaDOS FileInfoBlock as a measuring device. */
ULONG sizeoffile(BPTR file)
{
    struct FileInfoBlock fib;
    ULONG size=0L;
    ExamineFH(file, &fib);
    size=(ULONG)fib.fib_Size;
    return size;
}

/* Changes the state of a menuitem. Supply the index numbers of the menu and the
   item (NOT the actual pointers!) and a boolean state (disabled/enabled). */
void menuonoff(UBYTE menu, UBYTE item, UBYTE state)
{
    if (state)
        OnMenu(SeaTradeWnd, FULLMENUNUM(menu, item, NOSUB));
    else
        OffMenu(SeaTradeWnd,FULLMENUNUM(menu, item, NOSUB));
}

/* Changes the state of a submenuitem. Supply the index number of the menu, the
   item and the subitem (NOT the actual pointers!) and a boolean state
   (disabled/enabled). */
void submenuonoff(UBYTE menu, UBYTE item, UBYTE sub, UBYTE state)
{
    if (state)
        OnMenu(SeaTradeWnd, FULLMENUNUM(menu, item, sub));
    else
        OffMenu(SeaTradeWnd, FULLMENUNUM(menu, item, sub));
}

/* Returns a pseudo-random number from 0 to (maxvalue-1). */
long rnd(long maxvalue)
{
    static int seed=0;
    if (!seed)
    {
        seed=(int)time(NULL);
        srand(seed);
    }
    return rand()%maxvalue;
}

/* Returns the raw block type from the given coordinates. A raw block type will
   only identify what the block actually "does": i.e. whether it is sea or land,
   and what its depth is. The map file only contains raw block types because
   they fit into 3 bits rather than 9 for the "cooked" block types. */
UBYTE getrawblocktype(UWORD x, UWORD y)
{
    ULONG *address;
    ULONG n, value;
    UBYTE o;
    n=((y+1024*x)/8)*3;
    o=7 - (y & 7);
    address=(ULONG *)(map+n);
    /* The bit-triplets containing the block types are stored in byte-triplets,
       each byte-triplet containing 8 bit-triplets. The pointer "address" now
       points at the first byte of one such byte-triplet. When we read a ULONG
       starting from that byte, the least significant byte of the ULONG will, in
       fact, belong to the _next_ byte-triplet. So we right-shift the ULONG by 8
       to get rid of the least significant byte. */
    value=*address >> 8;
    return (value >> (o*3)) & 7;
}

/* Calculates the "cooked" block type from the raw block types of the given
   coordinates and its 4-neighbours. By knowing the raw block types of the 4-
   neighbours we can "smooth" the block type to give us an index to our array of
   struct Images. */
UWORD getblocktype(UWORD x, UWORD y)
{
    UBYTE p=0, u=0, r=0, d=0, l=0, i;
    UWORD block, xx, yy;
    p=getrawblocktype(x, y);
    if (y>0)
        u=getrawblocktype(x, y-1);
    if (x<1023)
        r=getrawblocktype(x+1, y);
    if (y<1023)
        d=getrawblocktype(x, y+1);
    if (x>0)
        l=getrawblocktype(x-1, y);
    switch (p)
    {
        case 0: /* Deep sea, or anything else */
        default:
        return 385;
        case 1: /* Medium sea */
        block=369;
        if (!u)
            block+=1;
        if (!r)
            block+=2;
        if (!d)
            block+=4;
        if (!l)
            block+=8;
        return block;
        case 2: /* Shallow sea */
        block=353;
        if (u==1)
            block+=1;
        if (r==1)
            block+=2;
        if (d==1)
            block+=4;
        if (l==1)
            block+=8;
        return block;
        case 3: /* Shallow forest */
        block=337;
        if (u==2)
            block+=1;
        if (r==2)
            block+=2;
        if (d==2)
            block+=4;
        if (l==2)
            block+=8;
        return block;
        case 4: /* Medium forest */
        block=256;
        switch (u)
        {
            case 2:
            case 1:
            case 0:
            block+=2;
            break;
            case 3:
            case 6:
            block+=1;
            break;
            default:
        }
        switch (r)
        {
            case 2:
            case 1:
            case 0:
            block+=6;
            break;
            case 3:
            case 6:
            block+=3;
            break;
            default:
        }
        switch (d)
        {
            case 2:
            case 1:
            case 0:
            block+=18;
            break;
            case 3:
            case 6:
            block+=9;
            break;
            default:
        }
        switch (l)
        {
            case 2:
            case 1:
            case 0:
            block+=54;
            break;
            case 3:
            case 6:
            block+=27;
            break;
            default:
        }
        return block;
        case 5: /* Deep forest */
        block=0;
        switch (u)
        {
            case 2:
            case 1:
            case 0:
            block+=3;
            break;
            case 4:
            block+=1;
            break;
            case 3:
            case 6:
            block+=2;
            break;
            default:
        }
        switch (r)
        {
            case 2:
            case 1:
            case 0:
            block+=12;
            break;
            case 4:
            block+=4;
            break;
            case 3:
            case 6:
            block+=8;
            break;
            default:
        }
        switch (d)
        {
            case 2:
            case 1:
            case 0:
            block+=48;
            break;
            case 4:
            block+=16;
            break;
            case 3:
            case 6:
            block+=32;
            break;
            default:
        }
        switch (l)
        {
            case 2:
            case 1:
            case 0:
            block+=192;
            break;
            case 4:
            block+=64;
            break;
            case 3:
            case 6:
            block+=128;
            break;
            default:
        }
        return block;
        case 6: /* City */
        for (i=0; i<128; i++)
        {
            getcitylocation(getcity(i), &xx, &yy);
            if (xx==x && yy==y)
                break;
        }
        return 386+getcity(i)->type;
    }
}

/* Draws the given Image to the given RastPort. Supply RastPort, index number of
   Image, and block (not pixel) coordinates. */
void drawimage(struct RastPort *rp, UWORD num, UBYTE px, UBYTE py)
{
    DrawImage(rp, image[num], 8+px*16, 8+py*16);
}

/* Superimposes the given Image onto the one currently ready to be copied at
   hidden_rp. First ANDs the block with the given Image's "mask", then ORs the
   block with the Image itself. */
void superimpose(struct RastPort *rp, UWORD num, UBYTE px, UBYTE py)
{
    UWORD mask;
    if (num>=391 && num<395) /* facing right, lights on */
        mask=num+16;
    if (num>=395 && num<403) /* facing right, lights off or facing left, lights
                                on */
        mask=num+12;
    if (num>=403 && num<411) /* facing left, lights off or facing right, lights
                                on, selected */
        mask=num+8;
    if (num>=411 && num<419) /* facing right, lights off, selected or facing
                                left, lights on, selected */
        mask=num+4;
    if (num>=419 && num<423) /* facing left, lights off, selected */
        mask=num;
    if (num>=407) /* if ship is selected, it uses same image as non-selected
                     ship */
        num-=16;
    drawimage(&hidden_rp, mask, 0, 11);
    ClipBlit(&hidden_rp, 8, 184, rp, 8+px*16, 8+py*16, 16, 16, 0x80);
    drawimage(&hidden_rp, num, 0, 11);
    ClipBlit(&hidden_rp, 8, 184, rp, 8+px*16, 8+py*16, 16, 16, 0xE0);
}

void writelog(STRPTR text)
{
    if (!logfile)
        return;
    Write(logfile, text, strlen(text));
}

void writelogdate()
{
    UBYTE logdatestr[21];
    datestring(logdatestr, gametime);
    writelog(logdatestr);
}

void drawmap(WORD left, WORD top)
{
    UWORD sx, sy, currentx, currenty;
    UBYTE x, y, direction, movesleft, iscurrent;
    struct ship *s, *found;
    if (left<0)
        mapleft=left=0;
    if (top<0)
        maptop=top=0;
    if (left>1012)
        mapleft=left=1012;
    if (top>1012)
        maptop=top=1012;
    getshiplocation(currentship, &currentx, &currenty);
    for (x=0; x<11; x++)
        for (y=0; y<11; y++)
        {
            drawimage(&hidden_rp, getblocktype(left+x, top+y), x, y);
            found=NULL;
            for (s=shiplist; s; s=s->next)
            {
                getshiplocation(s, &sx, &sy);
                if (sx==left+x && sy==top+y)
                {
                    direction=(s->flags&4)/4;
                    movesleft=s->moves>=1.0;
                    iscurrent=s==currentship;
                    found=s;
                    if (iscurrent || sx!=currentx || sy!=currenty)
                        break;
                }
            }
            if (found)
                superimpose(&hidden_rp, getshipimage(found->class/14, direction,
                    movesleft, iscurrent), x, y);
        }
    ClipBlit(&hidden_rp, 8, 8, SeaTradeWnd->RPort, 8, 8, 176, 176, 0xC0);
}

/* Creates a new struct Node and names it with the given name. Automatically
   adds the new struct Node to the given struct List. */
struct Node *createnode(STRPTR name, struct List *list)
{
    struct Node *newnode;
    UBYTE *label;
    if (!(newnode=AllocVec(sizeof(struct Node), MEMF_CLEAR)))
        return NULL;
    if (!(label=AllocVec(13, MEMF_CLEAR)))
    {
        FreeVec(newnode);
        return NULL;
    }
    CopyMem(name, label, 13);
    newnode->ln_Name=label;
    AddTail(/*&SelectShip6List*/ list, newnode);
    return newnode;
}

/* Frees all the struct Nodes we have allocated. */
void freenodes()
{
    struct Node *node, *oldnode;
    UWORD i;
    i=0;
    oldnode=nodelist;
    while (i<shipnum)
    {
        node=oldnode->ln_Succ;
        FreeVec(oldnode->ln_Name);
        FreeVec(oldnode);
        oldnode=node;
        i++;
    }
    nodelist=NULL;
}

/* Initialises a list. This must be called before addnode() or selectship(). */
void createlist(struct List *list)
{
    NewList(/*&SelectShip6List*/ list);
    nodelist=NULL;
    shipnum=0;
}

/* Adds a new ship as a struct Node. First parameter is the index number of the
   ship in the "real" shiplist. Second parameter is the ship's name. Third
   parameter is a pointer to the struct List the node should be added to. Fourth
   parameter is FALSE for a normal selection list or TRUE for a selection list
   that should not include the current ship. */
UBYTE addnode(UBYTE number, STRPTR name, struct List *list, UBYTE ignorecurrent)
{
    struct Node *newnode;
    struct ship *s=shiplist;
    UWORD i=0;
    for (i=0; i<number; i++)
        s=s->next;
    if (ignorecurrent && s==currentship)
        return TRUE;
    if (!(newnode=createnode(name, list)))
        return FALSE;
    if (!nodelist)
        nodelist=newnode;
    shipnums[shipnum++]=number;
    return TRUE;
}

/* Writes a human-readable date to the given string, based on the given amount
   of elapsed seconds. Ranges from 0 ( 1.Jan 2048 00:00:00) to 4294967295
   ( 1.Feb 2186 06:28:15), a total of 138 years, 1 month, 6 hours 28 minutes and
   15 seconds. */
void datestring(STRPTR string, ULONG date)
{
    UBYTE year, month, day, hour, minute, second;
    second=date%60; date/=60;
    minute=date%60; date/=60;
    hour=date%24; date/=24;
    day=date%30; date/=30;
    month=date%12; date/=12;
    year=date;
    sprintf(string, "%2d.%s %d %2d:%2d:%2d", day+1, months[month], year+2048,
        hour, minute, second);
}

/* Writes human-readable map coordinates to the given strings, based on the
   given block coordinates. Ranges from (0,0) (85\B010'N 85\B010'W) to (1023,1023)
   (85\B020'S 85\B020'E). */
void coordinatestrings(STRPTR lat, STRPTR lon, UWORD x, UWORD y)
{
    UBYTE degree, minute, ns, we;
    if (y<512)
    {
        ns='N';
        y=512-y;
    }
    else
    {
        ns='S';
        y-=512;
    }
    degree=y/6; minute=y%6;
    sprintf(lat, "%2d\B0%2d'%c", degree, minute*10, ns);
    if (x<512)
    {
        we='W';
        x=512-x;
    }
    else
    {
        we='E';
        x-=512;
    }
    degree=x/6; minute=x%6;
    sprintf(lon, "%2d\B0%2d'%c", degree, minute*10, we);
}

void clearpersonmarks()
{
    struct person *p;
    for (p=personlist; p; p=p->next)
        setmark(p, 0);
}

void setdate(ULONG seconds)
{
    struct person *p, *pp;
    struct ship *s;
    UBYTE title[27], message[94], shiptext[25];
    UBYTE flag, comma;
    gametime=seconds;
    datestring(datestr, seconds);
    GT_SetGadgetAttrs(SeaTradeGadgets[16], SeaTradeWnd, NULL, GTTX_Text,
        datestr, TAG_DONE);
    /* Time is frozen if we're loading a previously saved game, but unfrozen if
       we are actually playing the game. Because when loading a game, the time
       is set straight to the point when the game was saved, keeping the time
       unfrozen would relive the whole passage of time from the game's starting
       point to the point where it was last saved. Obviously we don't want that!
    */
    if (timeisfrozen)
    {
        hour=gametime/3600;
        return;
    }
    while (gametime > hour*3600)
        hourly();
    p=personlist;
    flag=0;
    while (p)
    {
        pp=p; p=p->next;
        /* All TOURISTs (transferable back to city) onboard a ship become
           PASSENGERs (not transferable back to city) */
        if (gettype(pp)==TOURIST && getloc(pp)>=128)
        {
            settype(pp, PASSENGER);
            setmark(pp, CONTRACTMARK);
            flag|=1;
        }
        /* Free all persons which satisfy these requirements:
           1. Person's deadline has expired
           2. Person's type is TOURIST -or- person's type is CREW and he/she is
              in a city, not on board a ship */
        if (gametime > pp->deadline)
        {
            if (gettype(pp)==TOURIST || (gettype(pp)==CREW && getloc(pp)<128))
                freeperson(pp);
            if (gettype(pp)==PASSENGER)
            {
                sprintf(title, "Message from %s", pp->name);
                sprintf(shiptext, "(Aboard \"%s\")\n",
                    ((struct ship *)pp->location)->name);
                sprintf(message, "%sI was supposed to be in %s\nby now! You "
                    "can forget about\npayment!", (pp->location==currentship ?
                    "" : shiptext), getcity(pp->destination)->name);
                request(SeaTradeWnd, title, message, proceed, NULL);
                if (reputation>-32768)
                    reputation--;
                /* Persons having exceeded their deadline without getting to
                   their destination vanish immediately if they are in a city
                   store ship, but hang around if they're on a real ship. */
                if (((struct ship *)pp->location)->class < 56)
                {
                    settype(pp, FAILED);
                    setmark(pp, FAILMARK);
                    flag|=2;
                }
                else
                {
                    ((struct ship *)p->location)->passengers--;
                    freeperson(pp);
                }
            }
        }
    }
    if (logfile && (flag & 1))
    {
        writelogdate();
        writelog(": The following people were taken on ship voyages:\n");
        comma=FALSE;
        for (p=personlist; p; p=p->next)
            if (getmark(p)==CONTRACTMARK)
            {
                sprintf(message, "%s%s from %s to %s", (comma ? ", " : ""),
                    p->name, getcity(p->source)->name,
                    getcity(p->destination)->name);
                comma=TRUE;
                writelog(message);
            }
        writelog("\n");
    }
    if (logfile && (flag & 2))
    {
        writelogdate();
        writelog(": The following people failed to reach their destinations\n"
            "on time:\n");
        comma=FALSE;
        for (p=personlist; p; p=p->next)
            if (getmark(p)==FAILMARK)
            {
                sprintf(message, "%s%s to %s", (comma ? ", " : ""), p->name,
                    getcity(p->destination)->name);
                comma=TRUE;
                writelog(message);
            }
        writelog("\n");
    }
    clearpersonmarks();
    /* If any ships are on strike, and the player has got enough money to pay
       them, then pay them and put them to work again. */
    for (s=shiplist; s; s=s->next)
        if (money>=getpay(s) && s->flags&8)
        {
            request(SeaTradeWnd, information, "The crew of \"%s\"\nstart "
                "working again.", proceed, s->name);
            setmoney(money-getpay(s));
            s->flags&=~8;
        }
}

void setmoney(ULONG cash)
{
    money=cash;
    GT_SetGadgetAttrs(SeaTradeGadgets[17], SeaTradeWnd, NULL, GTNM_Number, cash,
        TAG_DONE);
    if (CityWnd)
        GT_SetGadgetAttrs(CityGadgets[5], CityWnd, NULL, GTNM_Number, cash,
            TAG_DONE);
}

void calculatemoney(ULONG *shipmoney, ULONG *cargomoney, ULONG *maxcargo)
{
    struct ship *s;
    UBYTE i;
    *shipmoney=*cargomoney=*maxcargo=0;
    for (s=shiplist; s; s=s->next)
    {
        *shipmoney+=class[s->class].price;
        for (i=0; i<12; i++)
        {
            *cargomoney+=s->cargo[i]*price[i];
            *maxcargo+=s->cargo[i];
        }
    }
}

void daily()
{
    struct ship *s;
    UBYTE message[140];
    ULONG shipmoney, cargomoney, maxcargo;
    UBYTE i, j, day;
    BYTE d, diff;
    /* All ship crews either get paid (if there's enough money left) or go on
       strike (if there isn't). */
    for (s=shiplist; s; s=s->next)
        if (money>=getpay(s))
            setmoney(money-getpay(s));
        else
        {
            if (!(s->flags&8))
                request(SeaTradeWnd, information, "The crew of \"%s\"\n"
                    "refuse to work without pay.", proceed, s->name);
            s->flags|=8;
        }
    /* All the supplies and demands in the cities change randomly. The ranges
       for changing are [-2, 2] for normal goods, [-4, 0] for major imports,
       [-3, 1] for minor imports, [0, 4] for major exports and [-1, 3] for minor
       exports. The demands change to reflect the supplies, and further change
       by a random amount in the range [-1, 1]. */
    for (i=0; i<128; i++)
        for (j=0; j<12; j++)
        {
            d=-2-cargotype[getcity(i)->type][j];
            diff=rnd(5)+d;
            if ((LONG)getcity(i)->supply[j] + diff < 0 ||
                (LONG)getcity(i)->supply[j] + diff > 65535)
                diff=0;
            getcity(i)->supply[j]+=diff;
            if ((LONG)getcity(i)->demand[j] - diff < 0 ||
                (LONG)getcity(i)->demand[j] - diff > 65535)
                diff=0;
            getcity(i)->demand[j]-=diff;
            diff=rnd(3)-1;
            if ((LONG)getcity(i)->demand[j] - diff < 0 ||
                (LONG)getcity(i)->demand[j] - diff > 65535)
                diff=0;
            getcity(i)->demand[j]-=diff;
        }
    day=gametime/86400;
    if (!(day%5))
    {
        writelogdate();
        writelog(": Periodical money report:\n");
        calculatemoney(&shipmoney, &cargomoney, &maxcargo);
        sprintf(message, "%10d in %3d ships.\n%10d in %8d kg of cargo.\n"
            "%10d in cash.\n------------------------------------\n"
            "%10d in total.\n", shipmoney, ships, cargomoney, maxcargo, money,
            shipmoney+cargomoney+money);
        writelog(message);
    }
}

void monthly()
{
    UBYTE i;
    for (i=0; i<128; i++)
        getcity(i)->shipsavailable[getcity(i)->shipsmade[shipturn]]++;
    shipturn++;
    if (shipturn==14)
        shipturn=0;
}

void hourly()
{
    UBYTE i;
    if (!(hour % 24))
        daily();
    if (!(hour % 720))
        monthly();
    consumefood();
    hour++;
    for (i=0; i<8; i++)
    {
        createpassenger();
        createcrew();
    }
}

WORD abs(WORD n)
{
    if (n>=0)
        return n;
    else
        return -n;
}

/* Finds all the ships that are capable of carrying the current ship in the
   location given. The ships' addresses will be written into the array
   shipspresent and their number will be returned as the return value of this
   function. */
BYTE finddockableships(UWORD x, UWORD y, struct ship **shipspresent,
    UBYTE *shipnums)
{
    struct ship *s=shiplist;
    UWORD sx, sy, myweight;
    WORD i=0, j=0, k=0;
    UBYTE carrying;
    myweight=weight(currentship);
    for (i=0; i<ships && i<256; i++)
    {
        /* No ship is big enough to carry itself, so there's no need to check
           whether we are investigating the currently selected ship. */
        getshiplocation(s, &sx, &sy);
        /* Check that the ship in question is in the same place as our current
           ship and is not itself being carried by another ship, and that its
           docks are big enough to hold the current ship */
        if (x==sx && y==sy)
            if (s->class==56)
            {
                shipspresent[j]=s;
                shipnums[j++]=i;
            }
            else
                if (!s->carriedby && myweight<=class[s->class].docksize)
                {
                    /* Check that the ship isn't already carrying all it can */
                    carrying=0;
                    for (k=0; k<3; k++)
                        carrying+=!!s->carrying[k];
                    if (carrying < class[s->class].docks)
                    {
                        shipspresent[j]=s;
                        shipnums[j++]=i;
                    }
                }
        s=s->next;
    }
    return j;
}

/* Enables the currently selected ship to dock with cities or other ships. */
void dock()
{
    struct ship *shipspresent[256], *shiptouse;
    UBYTE shipnums[256];
    UWORD x, y;
    WORD i, n=-1, shipsfound;
    getshiplocation(currentship, &x, &y);
    if (getrawblocktype(x, y)==6)
    {
        for (i=0; i<128; i++)
            if (currentship->location[0]==getcity(i)->location[0] &&
                currentship->location[1]==getcity(i)->location[1] &&
                currentship->location[2]==getcity(i)->location[2])
            {
                n=i;
                break;
            }
        if (n>=0)
        {
            /* Temporarily add the "store" ship of the city we just found to our
               shiplist. */
            getcity(n)->store.prev=ship;
            ship->next=&getcity(n)->store;
            ship=&getcity(n)->store;
            ships++;
        }
    }
    shipsfound=finddockableships(x, y, shipspresent, shipnums);
    if (!shipsfound)
        return; /* Nothing to dock with! */
    /* If there's only one ship available to dock it, dock with it without any
       further questions */
    if (shipsfound==1)
    {
        shiptouse=shipspresent[0];
        if (n>=0)
        {
            ship=ship->prev;
            ship->next->prev=NULL;
            ship->next=NULL;
            ships--;
        }
    }
    else
    {
        createlist((struct List *)&SelectShip6List);
        for (i=0; i<shipsfound; i++)
            addnode(shipnums[i], shipspresent[i]->name,
                (struct List *)&SelectShip6List, TRUE);
        shiptouse=selectship();
        if (n>=0)
        {
            ship=ship->prev;
            ship->next->prev=NULL;
            ship->next=NULL;
            ships--;
        }
        if (!shiptouse)
            return;
    }
    /* If we selected a real ship, dock with it. If we selected the "store" ship
       of some city, go to that city instead. */
    if (shiptouse->class<56)
    {
        /* This ship enters the selected ship's docks, causing the selected ship
           to be selected as our current ship instead. */
        for (i=0; shiptouse->carrying[i]; i++);
        shiptouse->carrying[i]=currentship;
        currentship->carriedby=shiptouse;
        select(shiptouse);
    }
    else
        if (n>=0)
            gotocity(n);
}

void showmap()
{
    UWORD x, y;
    getshiplocation(currentship, &x, &y);
    if (!OpenMapWindow())
    {
        citymap(MapWnd->RPort, x-17, y-17, 35, 35, 2, 1);
        GT_SetGadgetAttrs(MapGadgets[0], MapWnd, NULL, GTTX_Text, latitude,
            TAG_DONE);
        GT_SetGadgetAttrs(MapGadgets[1], MapWnd, NULL, GTTX_Text, longitude,
            TAG_DONE);
        while (HandleMapIDCMP());
        CloseMapWindow();
    }
}

void savegame(UBYTE *filename)
{
    BPTR file;
    UBYTE *buffer;
    struct ship *s, *shipbegin;
    struct person *p, *personbegin;
    ULONG size;
    UWORD i, j, a;
    UBYTE b;
    if (file=Open(filename, MODE_OLDFILE))
    {
        Close(file);
        if (!request(SeaTradeWnd, "Confirmation", "The file\n\"%s\"\nalready "
            "exists. Overwrite?", "Yes|No", filename))
            return;
    }
    size = 26450 + ships*sizeof(struct ship) + persons*sizeof(struct person);
    if (!(buffer=AllocVec(size, MEMF_CLEAR)))
    {
        request(SeaTradeWnd, error, "Not enough memory for temporary buffer.",
            proceed, NULL);
        return;
    }
    shipbegin = (struct ship *)(buffer+26448);
    personbegin = (struct person *)(buffer+26448 + ships*sizeof(struct ship));
    if (!(file=Open(filename, MODE_NEWFILE)))
    {
        FreeVec(buffer);
        request(SeaTradeWnd, error, "Could not open file\n\"%s\".", proceed,
            filename);
        return;
    }
    *(ULONG *)buffer=0x25101976; /* My birthday! */
    *(ULONG *)(buffer+8)=gametime;
    *(ULONG *)(buffer+12)=money;
    *(double *)(buffer+16)=slowest;
    *(double *)(buffer+24)=increment;
    *(WORD *)(buffer+32)=mapleft;
    *(WORD *)(buffer+34)=maptop;
    *(UWORD *)(buffer+36)=ships;
    *(UWORD *)(buffer+40)=persons;
    *(UWORD *)(buffer+42)=namesleft;
    *(WORD *)(buffer+44)=reputation;
    for (i=0; i<namesleft; i++)
    {
        a=namesavailable[i]/8; b=namesavailable[i]&7;
        buffer[48+a]|=(1<<b);
    }
    for (i=0; i<128; i++)
    {
        for (j=0; j<56; j++)
            buffer[848+i*200+j]=getcity(i)->shipsavailable[j];
        for (j=0; j<12; j++)
        {
            ((UWORD *)(buffer+904+i*200))[j]=getcity(i)->supply[j];
            ((UWORD *)(buffer+928+i*200))[j]=getcity(i)->demand[j];
        }
        CopyMem(&getcity(i)->store, buffer+952+i*200, sizeof(struct ship));
    }
    /* Write the list of the ships as a consecutive array of ships. Since the
       pointers "carrying" and "carriedby" lose their meaning when written to
       the file, we must first enumerate each ship in the list, and then replace
       each pointer by the number we gave the ship it points to. This requires
       two passes over the list, but Amigas should be fast enough to handle
       that. */
    i=1; /* Serial numbers start at 1 instead of 0, since 0 is also a null
            pointer */
    for (s=shiplist; s; s=s->next)
        s->serialnumber=i++;
    *(UWORD *)(buffer+38)=currentship->serialnumber;
    i=0;
    for (s=shiplist; s; s=s->next, i++)
    {
        CopyMem(s, shipbegin+i, sizeof(struct ship));
        for (j=0; j<3; j++)
            if (s->carrying[j])
                shipbegin[i].carrying[j]=(struct ship *)s->carrying[j]->
                    serialnumber;
        if (s->carriedby)
            shipbegin[i].carriedby=(struct ship *)s->carriedby->serialnumber;
    }
    i=0;
    for (p=personlist; p; p=p->next, i++)
    {
        if (getloc(p)>=128)
            setloc(p, 127+((struct ship *)p->location)->serialnumber);
        CopyMem(p, personbegin+i, sizeof(struct person));
    }
    Write(file, buffer, size);
    Close(file);
    FreeVec(buffer);
}

UBYTE loadgame(STRPTR filename)
{
    BPTR file;
    UBYTE *buffer;
    ULONG size;
    UWORD numships, numpersons, i, j, a;
    UBYTE b;
    struct ship **shippointers;
    struct ship *shiparray, *s;
    struct person *personarray, *p;
    shiplist=ship=NULL;
    personlist=person=NULL;
    if (!(file=Open(filename, MODE_OLDFILE)))
    {
        request(SeaTradeWnd, error, "The file\n\"%s\"\ndoes not exist.",
            proceed, filename);
        return FALSE;
    }
    size=sizeoffile(file);
    if (!(buffer=AllocVec(size, MEMF_CLEAR)))
    {
        Close(file);
        request(SeaTradeWnd, error, "Not enough memory for temporary buffer.",
            proceed, NULL);
        return FALSE;
    }
    Read(file, buffer, size);
    Close(file);
    if (*(ULONG *)buffer!=0x25101976)
    {
        FreeVec(buffer);
        request(SeaTradeWnd, error, "This is not a Sea Trade saved game.",
            proceed, NULL);
        return FALSE;
    }
    timeisfrozen=TRUE;
    setdate(*(ULONG *)(buffer+8));
    timeisfrozen=FALSE;
    setmoney(*(ULONG *)(buffer+12));
    slowest=*(double *)(buffer+16);
    increment=*(double *)(buffer+24);
    mapleft=*(UWORD *)(buffer+32);
    maptop=*(UWORD *)(buffer+34);
    numships=*(UWORD *)(buffer+36);
    numpersons=*(UWORD *)(buffer+40);
    namesleft=*(UWORD *)(buffer+42);
    reputation=*(WORD *)(buffer+44);
    j=0;
    for (i=0; i<6400; i++)
    {
        a=i/8; b=i&7;
        if (buffer[48+a]&(1<<b))
        {
            namesavailable[j]=i;
            j++;
        }
    }
    for (i=0; i<128; i++)
    {
        for (j=0; j<56; j++)
            getcity(i)->shipsavailable[j]=buffer[848+i*200+j];
        for (j=0; j<12; j++)
        {
            getcity(i)->supply[j]=((UWORD *)(buffer+904+i*200))[j];
            getcity(i)->demand[j]=((UWORD *)(buffer+928+i*200))[j];
        }
        CopyMem(buffer+952+i*200, &getcity(i)->store, sizeof(struct ship));
    }
    shiparray=(struct ship *)(buffer+26448);
    shippointers=AllocVec(ships*sizeof(struct ship *), MEMF_CLEAR);
    for (i=0; i<numships; i++)
    {
        if (s=createship(shiparray[i].name, shiparray[i].class))
        {
            for (j=0; j<3; j++)
                s->location[j]=shiparray[i].location[j];
            s->flags=shiparray[i].flags;
            for (j=0; j<12; j++)
                s->cargo[j]=shiparray[i].cargo[j];
            s->crew=shiparray[i].crew;
            s->passengers=shiparray[i].passengers;
            s->moves=shiparray[i].moves;
            s->serialnumber=shiparray[i].serialnumber;
            shippointers[i]=s;
        }
    }
    for (s=shiplist; s; s=s->next)
    {
        for (i=0; i<3; i++)
            if (s->carrying[i])
                s->carrying[i]=shippointers[(ULONG)(s->carrying[i])-1];
        if (s->carriedby)
            s->carriedby=shippointers[(ULONG)(s->carriedby)-1];
    }
    currentship=shippointers[*(UWORD *)(buffer+38)-1];
    personarray=(struct person *)(buffer+26448+ships*sizeof(struct ship));
    for (i=0; i<numpersons; i++)
    {
        if (p=AllocVec(sizeof(struct person), MEMF_CLEAR))
        {
            CopyMem(personarray+i, p, sizeof(struct person));
            p->prev=p->next=NULL;
            /* The ln_Name pointer in the person's struct Node is quite likely
               pointing to garbage. Change it to point to the person's name. */
            p->node.ln_Name=p->name;
            if (getloc(p)>=128)
                p->location=shippointers[getloc(p)-128];
            else
                p->location=getcity(getloc(p));
            addperson(p);
        }
    }
    persons=numpersons;
    FreeVec(shippointers);
    FreeVec(buffer);
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected,
        currentship->serialnumber-1, TAG_DONE);
    setshipmoves(currentship->moves);
    setshipfuel(currentship->cargo[10]);
    setshipfood(currentship->cargo[11]);
    drawmap(mapleft, maptop);
    return TRUE;
}

void newgame()
{
    struct person *firstperson;
    UWORD i, j, total;
    double pricerel;
    for (i=0; i<128; i++)
    {
        citiesknown[i]=FALSE;
        for (j=0; j<12; j++)
        {
            if (j>=10)
            {
                getcity(i)->supply[j]=1023;
                getcity(i)->demand[j]=255;
            }
            else
            {
                pricerel=(double)getcity(i)->price[j]/(double)price[j];
                getcity(i)->supply[j]=10000/getcity(i)->price[j];
                total=getcity(i)->supply[j] * (pricerel + 0.5);
                getcity(i)->demand[j]=total-getcity(i)->supply[j];
            }
        }
        for (j=0; j<14; j++)
            getcity(i)->shipsavailable[getcity(i)->shipsmade[j]]=1;
        getcity(i)->store.class=56;
        sprintf(getcity(i)->store.name, "\AB%s\BB", getcity(i)->name);
        getcity(i)->store.next=getcity(i)->store.prev=NULL;
        for (j=0; j<3; j++)
            getcity(i)->store.location[j]=getcity(i)->location[j];
    }
    shiplist=ship=NULL;
    personlist=person=NULL;
    for (i=0; i<6400; i++)
        namesavailable[i]=i;
    for (i=0; i<192; i++)
    {
        createpassenger();
        createcrew();
    }
    setdate(0); setmoney(cheatmode ? 500000 : 100);
    clearcitydiffs();
    currentship=createship("Spider", 0);
    firstperson=createperson(25, 0, (struct city *)currentship, 128, 0);
    if (firstperson)
    {
        addperson(firstperson);
        settype(firstperson, CREW);
        setloc(firstperson, 128);
    }
    currentship->crew=1;
    setshiplocation(currentship, 517, 517);
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected, 0,
        TAG_DONE);
    setshipmoves(4.0);
    setshipfuel(100);
    setshipfood(20);
    findslowest();
    increment=60.0/slowest;
    mapleft=512; maptop=512; reputation=0;
    drawmap(mapleft, maptop);
}

int SeaTradeRawKey()
{
    switch (SeaTradeMsg.Code)
    {
        case 0xBD:
        moveship(-1, -1);
        break;
        case 0xBE:
        case 0xCC:
        moveship(0, -1);
        break;
        case 0xBF:
        moveship(1, -1);
        break;
        case 0xAD:
        case 0xCF:
        moveship(-1, 0);
        break;
        case 0xAE:
        CenterClicked();
        break;
        case 0xAF:
        case 0xCE:
        moveship(1, 0);
        break;
        case 0x9D:
        moveship(-1, 1);
        break;
        case 0x9E:
        case 0xCD:
        moveship(0, 1);
        break;
        case 0x9F:
        moveship(1, 1);
        break;
        case 0xA2:
        return DockClicked();
        break;
        case 0x97:
        return InfoClicked();
        break;
        case 0xB7:
        showmap();
        break;
        case 0xC0:
        setshipmoves(0.0);
        checkships();
        break;
    }
    return TRUE;
}
void describecity(UBYTE i)
{
    UBYTE message[337], helper[39];
    struct person *p;
    UWORD passengers;
    UBYTE j;
    citiesknown[i]=TRUE;
    strcpy(message, "Imports:\n");
    for (j=0; j<10; j++)
        if (3*getcity(i)->price[j] >= 4*price[j])
        {
            sprintf(helper, "  %s\n", CargoName4Labels[j]);
            strcat(message, helper);
        }
    strcat(message, "Exports:\n");
    for (j=0; j<10; j++)
        if (4*getcity(i)->price[j] <= 3*price[j])
        {
            sprintf(helper, "  %s\n", CargoName4Labels[j]);
            strcat(message, helper);
        }
    passengers=0;
    for (p=personlist; p; p=p->next)
        if (gettype(p)==PASSENGER && p->destination==i && getloc(p)>=128)
            passengers++;
    if (passengers)
    {
        sprintf(helper, "You have %d\npassenger%s to\ntake here.\n", passengers,
            passengers>1 ? "s" : "");
        strcat(message, helper);
    }
    request(SeaTradeWnd, getcity(i)->name, message, proceed, NULL);
}
int SeaTradeMouseButtons()
{
    UBYTE code, px, py, i, j, shipsfound, cityfound, reply;
    UWORD x, y, xx, yy, totalcargo;
    UBYTE message[76];
    STRPTR buttons;
    struct ship *s, *lastship;
    struct ship *foundships[256];
    code=SeaTradeMsg.Code; x=SeaTradeMsg.MouseX; y=SeaTradeMsg.MouseY;
    if (code&128)
        return TRUE;
    if (x>=8 && y>=8 && x<184 && y<184)
    {
        px=(x-8)/16; py=(y-8)/16; i=0; cityfound=~0;
        for (s=shiplist; s; s=s->next)
        {
            getshiplocation(s, &xx, &yy);
            if (xx==mapleft+px && yy==maptop+py)
                foundships[i++]=lastship=s;
        }
        foundships[i]=NULL;
        shipsfound=i;
        if (getrawblocktype(mapleft+px, maptop+py)==6)
        {
            for (i=0; i<128; i++)
            {
                getcitylocation(getcity(i), &xx, &yy);
                if (xx==mapleft+px && yy==maptop+py)
                    break;
            }
            if (i<128)
                cityfound=i;
        }
        if (!shipsfound)
            if (cityfound!=~0)
                describecity(cityfound);
            else;
        else
        {
            i=0;
            do
            {
                s=foundships[i++];
                totalcargo=0;
                for (j=0; j<12; j++)
                    totalcargo+=s->cargo[j];
                sprintf(message, "Fuel: %d Food: %d\n%d kg of cargo\n%d crew, "
                    "%d passenger%s\n", s->cargo[10], s->cargo[11], totalcargo,
                    s->crew, s->passengers, s->passengers!=1 ? "s" : "");
                if (s->flags & 8)
                    strcat(message, "ON STRIKE");
                if (cityfound!=~0)
                    if (s!=lastship)
                        buttons="Next ship|City|Done";
                    else
                        buttons="City|Done";
                else
                    if (s!=lastship)
                        buttons="Next ship|Done";
                    else
                        buttons="Done";
                reply=request(SeaTradeWnd, s->name, message, buttons, NULL);
                if (cityfound!=~0 && (s!=lastship && reply==2) ||
                    (s==lastship && reply==1))
                {
                    describecity(cityfound);
                    break;
                }
            }
            while (reply);
        }
    }
    return TRUE;
}
int ULClicked()
{
    moveship(-1, -1);
    return TRUE;
}
int UClicked()
{
    moveship(0, -1);
    return TRUE;
}
int URClicked()
{
    moveship(1, -1);
    return TRUE;
}
int LClicked()
{
    moveship(-1, 0);
    return TRUE;
}
int CenterClicked()
{
    UBYTE oldautocenter;
    oldautocenter=autocenter;
    setautocenter(2);
    setautocenter(oldautocenter);
    return TRUE;
}
int RClicked()
{
    moveship(1, 0);
    return TRUE;
}
int DLClicked()
{
    moveship(-1, 1);
    return TRUE;
}
int DClicked()
{
    moveship(0, 1);
    return TRUE;
}
int DRClicked()
{
    moveship(1, 1);
    return TRUE;
}
int InfoClicked()
{
    info(currentship);
    return TRUE;
}
int DockClicked()
{
    dock();
    return TRUE;
}
int ShipsClicked()
{
    struct ship *s;
    ULONG n, i;
    GT_GetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected, &n,
        TAG_DONE);
    s=shiplist;
    for (i=0; i<n; i++)
        s=s->next;
    if (s!=currentship)
        select(s);
    return TRUE;
}
int SeaTradeSave()
{
    UBYTE filename[32];
    if (aslreq(TRUE, filename))
        savegame(filename);
    return TRUE;
}
int SeaTradeAbout()
{ return TRUE; }
int SeaTradeQuit()
{
    if (logfile)
        Close(logfile);
    return FALSE;
}
int SeaTradeNext()
{
    struct ship *s;
    if (!skipflag)
        s=currentship->next;
    else
    {
        for (s=currentship->next; s && s->moves>=1.0; s=s->next);
        if (!s)
        {
            request(SeaTradeWnd, error, "Could not find a next ship.", proceed,
                NULL);
            return TRUE;
        }
    }
    select(s);
    return TRUE;
}
int SeaTradePrevious()
{
    struct ship *s;
    if (!skipflag)
        s=currentship->prev;
    else
    {
        for (s=currentship->prev; s && s->moves>=1.0; s=s->prev);
        if (!s)
        {
            request(SeaTradeWnd, error, "Could not find a previous ship.",
                proceed, NULL);
            return TRUE;
        }
    }
    select(s);
    return TRUE;
}
int SeaTradeReleaseall()
{
    UBYTE i;
    for (i=0; i<3 && currentship->carrying[i]; i++)
    {
        currentship->carrying[i]->carriedby=NULL;
        currentship->carrying[i]=NULL;
    }
    submenuonoff(1, 3, 0, FALSE);
    submenuonoff(1, 3, 1, FALSE);
    return TRUE;
}
int SeaTradeReleaseselect()
{
    struct ship *s;
    UBYTE i, j;
    if (!currentship->carrying[1])
        return SeaTradeReleaseall();
    createlist((struct List *)&SelectShip6List);
    i=0;
    for (s=shiplist; s; s=s->next)
    {
        if (s==currentship->carrying[0] ||
            s==currentship->carrying[1] ||
            s==currentship->carrying[2])
            addnode(i, s->name, (struct List *)&SelectShip6List, TRUE);
        i++;
    }
    s=selectship();
    if (!s)
        return TRUE;
    for (i=0; i<3 && s!=currentship->carrying[i]; i++);
    s->carriedby=NULL;
    for (j=i; j<3; j++)
        if (j==2)
            currentship->carrying[j]=NULL;
        else
            currentship->carrying[j]=currentship->carrying[j+1];
    if (!currentship->carrying[0])
    {
        submenuonoff(1, 3, 0, FALSE);
        submenuonoff(1, 3, 1, FALSE);
    }
    return TRUE;
}
int SeaTradeNone()
{
    setautocenter(0);
    return TRUE;
}
int SeaTradeOffline()
{
    setautocenter(1);
    return TRUE;
}
int SeaTradeOnline()
{
    setautocenter(2);
    return TRUE;
}
int SeaTradeSkip()
{
    struct MenuItem *n;
    n=ItemAddress(SeaTradeMenus, FULLMENUNUM(2, 1, NOSUB));
    skipflag=(n->Flags&CHECKED)/CHECKED;
    return TRUE;
}
int SeaTradeAlarms()
{ return TRUE; }
int SeaTradeFastAutopilot()
{
    struct MenuItem *n;
    n=ItemAddress(SeaTradeMenus, FULLMENUNUM(2, 5, NOSUB));
    fastautopilot=(n->Flags&CHECKED)/CHECKED;
    return TRUE;
}
int SeaTradeAutopilot()
{
    autopilot();
    return TRUE;
}
int SeaTradeLog()
{
    APTR file;
    UBYTE filename[32];
    UBYTE response=2;
    if (aslreq(2, filename))
    {
        file=Open(filename, MODE_OLDFILE);
        if (file)
        {
            Close(file);
            response=request(SeaTradeWnd, "Request",
                "File \"%s\" already\nexists. What should I do?",
                "Append|Overwrite|Cancel", filename);
            if (!response)
                return TRUE;
        }
        if (logfile)
        {
            Close(logfile);
            logfile=NULL;
        }
        if (response==1)
        {
            file=Open(filename, MODE_READWRITE);
            if (file)
                Seek(file, 0, OFFSET_END);
        }
        else
            file=Open(filename, MODE_NEWFILE);
        if (!file)
            request(SeaTradeWnd, error, "Error opening file\n\"%s\".", proceed,
                filename);
        else
            logfile=file;
        menuonoff(2, 4, !!file);
    }
    return TRUE;
}
int SeaTradeCloseLog()
{
    if (logfile)
        Close(logfile);
    logfile=NULL;
    menuonoff(2, 4, FALSE);
    return TRUE;
}

int MapCloseWindow()
{
    return FALSE;
}
int MapMouseButtons()
{
    UBYTE lat[8], lon[8];
    UWORD x, y, shipx, shipy;
    UBYTE code, px, py;
    code=MapMsg.Code;
    x=MapMsg.MouseX-MapWnd->BorderLeft; y=MapMsg.MouseY-MapWnd->BorderTop;
    if (code&128)
        return TRUE;
    if (x<2 || y<1 || x>71 || y>70)
        return TRUE;
    px=(x-2)/2; py=(y-1)/2;
    getshiplocation(currentship, &shipx, &shipy);
    coordinatestrings(lat, lon, shipx-17+px, shipy-17+py);
    GT_SetGadgetAttrs(MapGadgets[0], MapWnd, NULL, GTTX_Text, lat, TAG_DONE);
    GT_SetGadgetAttrs(MapGadgets[1], MapWnd, NULL, GTTX_Text, lon, TAG_DONE);
    return TRUE;
}
int MapRawKey()
{
    return MapMsg.Code!=0xB7;
}

int main(int argc, char *argv[])
{
/*    UBYTE i, j;
    for (i=0; i<128; i++)
    {
        for (j=0; j<10; j++)
            printf("%4.2f ", (double)citystub[i].price[j]/price[j]);
        printf("\n");
    }
    return 0; */
    if (!SetupScreen())
    {
        if (loadgraphics() && loadpalette() && allocstuff())
        {
            if (!OpenSeaTradeWindow())
            {
                if (argc>=2 && !strcmp(argv[1], "--cheat"))
                {
                    cheatmode=1;
                    argc--;
                    argv[1]=argv[2];
                }
                if (argc<2 || !loadgame(argv[1]))
                    newgame();
                while (HandleSeaTradeIDCMP());
                CloseSeaTradeWindow();
            }
            cleanup();
        }
        CloseDownScreen();
    }
    return 0;
}
