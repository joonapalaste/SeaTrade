/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : JIPsoft (Joona I Palaste)
 */

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <libraries/asl.h>
#include <libraries/dos.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <math.h>

#include "SeaTrade.h"
#include "SeaTrade_extern.h"

UWORD latdeg, latmin, londeg, lonmin;
UBYTE ns, we;
STRPTR cityname;

void setshiplocation(struct ship *s, UWORD x, UWORD y)
{
    ULONG loc;
    loc=x+1024*y;
    s->location[0]=loc>>16;
    s->location[1]=loc>>8&255;
    s->location[2]=loc&255;
}

void getshiplocation(struct ship *s, UWORD *x, UWORD *y)
{
    ULONG loc;
    loc = (s->location[0]<<16) + (s->location[1]<<8) + s->location[2];
    *x=loc%1024; *y=loc/1024;
}

/* Returns the image index (not the struct Image *) for a ship based on size
   class and three flags. First flag is 0 for left-facing ships, 1 for right-
   facing ships. Second flag is 0 for inactive ships, 1 for active ships. Third
   flag is 0 for non-selected ships, 1 for selected ships. */
UWORD getshipimage(UBYTE size, UBYTE face, UBYTE active, UBYTE selected)
{
    UWORD im;
    im=391+size;
    if (!face)
        im+=8;
    if (!active)
        im+=4;
    if (selected)
        im+=16;
    return im;
}

/* Adds a new ship to our list. The variable "ship" will point to the list's
   tail. Returns a pointer to the new ship. Supplied parameters: ship name,
   index number of ship class. */
struct ship *createship(STRPTR name, UBYTE class)
{
    struct ship *newship;
    if (!(newship=AllocVec(sizeof(struct ship), MEMF_CLEAR)))
        return NULL;
    CopyMem(name, newship->name, 13);
    newship->class=class;
    if (!shiplist)
        shiplist=ship=newship;
    else
    {
        ship->next=newship;
        newship->prev=ship;
        ship=newship;
    }
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    AddTail(&Ships0List, &newship->node);
    newship->node.ln_Name=newship->name;
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        &Ships0List, TAG_DONE);
    ships++;
    return newship;
}

/* Renames the given ship. Since thisship->node->ln_Name already points to the
   same memory location as thisship->name, all we need to update the ship
   ListViewgadget is to detach and reattach the list. */
void renameship(struct ship *thisship, STRPTR name)
{
    UBYTE message[80];
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    sprintf(message, ": The %s class ship \"%s\" was renamed \"%s\".\n",
        class[thisship->class].name, thisship->name, name);
    writelogdate();
    writelog(message);
    CopyMem(name, thisship->name, 13);
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        &Ships0List, TAG_DONE);
}

/* Deletes the given ship from the list. */
void deleteship(struct ship *oldship)
{
    if (!oldship)
        return;
    if (oldship==shiplist)
        shiplist=oldship->next;
    if (oldship==ship)
        ship=oldship->prev;
    if (oldship->prev)
        oldship->prev->next=oldship->next;
    if (oldship->next)
        oldship->next->prev=oldship->prev;
   /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    Remove(&oldship->node);
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Labels,
        &Ships0List, TAG_DONE);
    FreeVec(oldship);
    ships--;
}

/* Deletes all the ships from the list. */
void freeships()
{
    struct ship *ship1, *ship2;
    ship1=shiplist;
    while (ship1)
    {
        ship2=ship1->next;
        FreeVec(ship1);
        ship1=ship2;
    }
}

/* Creates a new person. Supplied parameters are: Person type and name (array
   index), amount of pay person demands or offers, deadline before which person
   must be handled, pointer to city where person appears, array index of city
   where person wants to go. */
struct person *createperson(UWORD pay, ULONG deadline, struct city *location,
    UBYTE source, UBYTE destination)
{
    struct person *newperson;
    UWORD nameno, gotname, i;
    if (!namesleft)
    {
        namesleft=6400;
        for (i=0; i<6400; i++)
            namesavailable[i]=i;
    }
    nameno=rnd(namesleft);
    gotname=namesavailable[nameno];
    if (nameno<namesleft-1)
        for (i=nameno; i<namesleft-1; i++)
            namesavailable[i]=namesavailable[i+1];
    namesleft--;
    if (!(newperson=AllocVec(sizeof(struct person), MEMF_CLEAR)))
        return NULL;
    sprintf(newperson->name, "%s %s", firstnames[gotname%80],
        lastnames[gotname/80]);
    newperson->node.ln_Name=newperson->name;
    newperson->pay=pay; newperson->deadline=deadline;
    newperson->location=location;
    newperson->source=source; newperson->destination=destination;
    persons++;
    return newperson;
}

void settype(struct person *p, UBYTE type)
{
    p->flags=(p->flags & TYPEMASK) | ((type & 3) << 9);
}

UBYTE gettype(struct person *p)
{
    return (p->flags >> 9) & 3;
}

void setloc(struct person *p, UWORD loc)
{
    p->flags=(p->flags & LOCMASK) | (loc & 0x1FF);
}

UWORD getmark(struct person *p)
{
    return p->flags & (CONTRACTMARK | FAILMARK);
}

void setmark(struct person *p, UWORD mark)
{
    p->flags = (p->flags & MARKMASK) | mark;
}

UWORD getloc(struct person *p)
{
    return p->flags & 0x1FF;
}

/* Adds the given person to the list. Persons are sorted in order of deadline,
   earliest deadline first. */
void addperson(struct person *thisperson)
{
    struct person *pointer;
    if (!personlist)
    {
        personlist=person=thisperson;
        thisperson->prev=thisperson->next=NULL;
    }
    else
    {
        pointer=person;
        while (pointer && pointer->deadline > thisperson->deadline)
            pointer=pointer->prev;
        if (!pointer)
        {
            thisperson->next=personlist;
            thisperson->prev=NULL;
            personlist->prev=thisperson;
            personlist=thisperson;
        }
        else
        {
            thisperson->prev=pointer;
            thisperson->next=pointer->next;
            if (pointer->next)
                pointer->next->prev=thisperson;
            pointer->next=thisperson;
            if (pointer==person)
                person=thisperson;
        }
    }
}

/* Creates a new passenger to one of the 128 cities. The passenger will have a
   random destination, deadline, and payment offer. */
void createpassenger()
{
    struct person *newperson;
    LONG hurry;
    WORD x1, y1, x2, y2, dx, dy;
    UWORD pay;
    UBYTE fromcity, tocity, attempts;
    double d, dmodifier, hurrymodifier, rmodifier, repmodifier;
    fromcity=rnd(128);
    getcitylocation(getcity(fromcity), &x1, &y1);
    attempts=0;
    do
    {
        tocity=rnd(128);
        if (fromcity!=tocity)
        {
            getcitylocation(getcity(tocity), &x2, &y2);
            dx=x1-x2; dy=y1-y2;
            d=sqrt(dx*dx + dy*dy);
        }
        else
            d=0.0;
        attempts++;
    }
    while ((d<60.0 || d>=300.0) && attempts<200);
    if (attempts==200)
        return; /* Give up after 200 attempts, to prevent infinite loops */
    /* How much of a hurry the passenger is in? The times the passenger has to
       travel range from 6 to 21 hours. A time of 6 hours will cause a
       modifier of 1.25, a time of 21 hours a modifier of 0.625. */
    hurry=rnd(54000);
    hurrymodifier=1.0+(21600-hurry)/86400.0;
    /* How far the passenger wants to go? The distances range from 60 to 300
       squares. A distance of 60 squares will cause a modifier of 0.5, a
       distance of 300 squares a modifier of 1.8333. */
    dmodifier=1.0+(d-150.0)/180.0;
    /* And to spice it up, a random modifier from 0.9 to 1.1. */
    rmodifier=1.0+(rnd(20)-10)/100.0;
    /* Reputation modifier. The base modifier is 1.0 but 0.01 is added for every
       successful passenger and substracted for every failed passenger. */
    repmodifier=1.0+(reputation/100.0);
    if (repmodifier<0.01)
        repmodifier=0.01; /* Modifiers are always positive! */
    pay=400*dmodifier*hurrymodifier*rmodifier*repmodifier;
    newperson=createperson(pay, gametime+21600+hurry, getcity(fromcity),
        fromcity, tocity);
    if (newperson)
    {
        addperson(newperson);
        settype(newperson, TOURIST);
        setloc(newperson, fromcity);
    }
}

/* Creates a new potential crew member (ie. a person looking for work) in one of
   the 128 cities. The person will have a random deadline and salary demand. */
void createcrew()
{
    struct person *newperson;
    UBYTE incity;
    incity=rnd(128);
    newperson=createperson(rnd(20)+25, gametime+21600+rnd(43200),
        getcity(incity), incity, 0);
    if (newperson)
    {
        addperson(newperson);
        settype(newperson, CREW);
        setloc(newperson, incity);
    }
}

/* Deletes the given person from the list. */
void freeperson(struct person *oldperson)
{
    if (oldperson==personlist)
        personlist=oldperson->next;
    else
        oldperson->prev->next=oldperson->next;
    if (oldperson==person)
        person=oldperson->prev;
    else
        oldperson->next->prev=oldperson->prev;
    FreeVec(oldperson);
    persons--;
}

void freepersons()
{
    struct person *p, *pp;
    p=personlist;
    while (p)
    {
        pp=p->next;
        freeperson(p);
        p=pp;
    }
}

/* Makes a list of the persons in a given place (whether it's a city or a ship).
   Since one person can be only in one place at a time, there's no need to store
   the nodes in multiple lists, and the list can be cleared at the start of this
   function. Supplied parameters: pointer to list to create, pointer to city or
   ship where the persons are. */
void createpersonlist(struct MinList *list, void *location, UBYTE type)
{
    struct person *p;
    UBYTE flag;
    NewList(list);
    if (list!=&CityList8List)
        shippeople=0;
    for (p=personlist; p; p=p->next)
        if (p->location == location)
        {
            flag=FALSE;
            switch (type)
            {
                case CREW:
                flag=(gettype(p)==CREW); break;
                case (UBYTE)~0:
                flag=TRUE; break;
                default:
                flag=(gettype(p)!=CREW); break;
            }
            if (flag)
            {
                if (list!=&List1List && list!=&Items2List)
                    AddTail(list, &p->node);
                else
                {
                    sprintf(labels[shippeople], "%13s (%s)", p->name,
                        types[gettype(p)]);
                    AddTail(list, &List1Nodes[shippeople]);
                }
                if (list!=&CityList8List)
                    shippeople++;
            }
        }
    if (location!=&currentcity->store)
        if (list!=&List1List && list!=&Items2List)
        {
            sprintf(freecabinstext, "%2d free cabins",
                class[currentship->class].cabins - currentship->crew -
                currentship->passengers);
            freecabinsnode.ln_Name=freecabinstext;
            if (list!=&CityList8List)
                AddTail(list, &freecabinsnode);
        }
        else
        {
            sprintf(labels[shippeople], "Free cabins left: %2d",
                class[currentship->class].cabins - currentship->crew -
                currentship->passengers);
            AddTail(list, &List1Nodes[shippeople]);
        }
}

/* Returns the (index+1)th person whose location is the one specified. For
   instance, use findperson(currentcity, 0) to find the first person in the
   current city. */
struct person *findperson(void *location, LONG index, UBYTE type)
{
    struct person *p;
    LONG i=-1;
    UBYTE flag;
    p=personlist;
    do
    {
        flag=FALSE;
        if (p->location==location)
        {
            switch (type)
            {
                case CREW:
                flag=(gettype(p)==CREW);
                break;
                case (UBYTE)~0:
                flag=TRUE;
                break;
                default:
                flag=(gettype(p)!=CREW);
                break;
            }
            if (flag)
                i++;
        }
        if (i<index)
            p=p->next;
    }
    while (i!=index);
    return p;
}

/* The inverse of the above function: Returns the (0-based) index of the
   given person. */
ULONG rfindperson(void *location, struct person *who, UBYTE type)
{
    struct person *p;
    LONG i=-1;
    UBYTE found=FALSE, flag;
    p=personlist;
    do
    {
        flag=FALSE;
        if (p->location==location)
        {
            switch (type)
            {
                case CREW:
                flag=(gettype(p)==CREW);
                break;
                case (UBYTE)~0:
                flag=TRUE;
                break:
                default:
                flag=(gettype(p)!=CREW);
                break;
            }
            if (flag)
                i++;
        }
        if (p==who)
            found=TRUE;
        else
            p=p->next;
    }
    while (!found);
    return i;
}

void showperson(struct person *p)
{
    UBYTE d[21], lat[8], lon[8], message[116];
    UWORD x, y;
    datestring(d, p->deadline);
    getcitylocation(getcity(p->destination), &x, &y);
    coordinatestrings(lat, lon, x, y);
    cleartext();
    if (peoplemode)
    {
        sprintf(message, "Hi, I'm %s and I want to go to %s (%s %s) by %s. I "
        "will pay %d.", p->name, getcity(p->destination)->name, lat, lon, d,
        p->pay);
        citiesknown[p->destination]=TRUE;
    }
    else
        sprintf(message, "Hi, I'm %s and I want a job on a ship by %s. I would "
        "like a salary of %d per day.", p->name, d, p->pay);
    addtext(message);
    showtext();
}

/* Selects the given ship as the current ship. The ship's attributes will be
   displayed and it will be centerd on screen (with autocenter on). Passing a
   NULL pointer will cause the first ship in the fleet, wherever it is, to be
   selected. */
void select(struct ship *thisship)
{
    struct ship *s;
    UWORD i;
    if (!thisship)
        thisship=shiplist;
    if (!thisship)
    {
        request(SeaTradeWnd, information, "You have no ships left!",
            proceed, NULL);
        menuonoff(1, 0, FALSE);
        menuonoff(1, 1, FALSE);
        submenuonoff(1, 3, 0, FALSE);
        submenuonoff(1, 3, 1, FALSE);
        return;
    }
    menuonoff(1, 0, !!thisship->next);
    menuonoff(1, 1, !!thisship->prev);
    menuonoff(1, 3, !!thisship->carrying[0]);
    submenuonoff(1, 3, 0, !!thisship->carrying[0]);
    submenuonoff(1, 3, 1, !!thisship->carrying[0]);
    currentship=thisship;
    setshipmoves(thisship->moves);
    setshipfuel(thisship->cargo[10]);
    setshipfood(thisship->cargo[11]);
    i=0;
    for (s=shiplist; s!=thisship; s=s->next)
        i++;
    GT_SetGadgetAttrs(SeaTradeGadgets[11], SeaTradeWnd, NULL, GTLV_Selected, i,
        TAG_DONE);
    moveship(0, 0);
}

/* Displays the "Select a ship" window and returns a pointer to the selected
   ship. Returns NULL if the user closed the window without selecting any ship.
   createlist() and addnode() must be called before this. */
struct ship *selectship()
{
    struct ship *s;
    UWORD i;
    if (!nodelist)
        return NULL;
    selected=(UWORD)~0;
    /* If there is only one ship to be selected, select it and don't bother
       even displaying the selection window. Otherwise display the selection
       window and allow the user to select a ship. */
    if (shipnum==1)
        selected=0;
    else
        if (!OpenSelectWindow())
        {
            while (HandleSelectIDCMP());
            CloseSelectWindow();
        }
    freenodes();
    if (selected==~0)
        return NULL;
    s=shiplist;
    for (i=0; i<shipnums[selected]; i++)
        s=s->next;
    return s;
}

/* Displays Info window for the given ship, to allow viewing or modifying of
   ship attributes. */
void info(struct ship *thisship)
{
    UBYTE i;
    infomode=0;
    currentdockedship=-1;
    sprintf(InfoWdt, "Info for ship \"%s\"", thisship->name);
    InfoGTags[1]=(ULONG)thisship->name;
    InfoGTags[6]=(ULONG)class[thisship->class].name;
    NewList(&Docked1List);
    for (i=0; i<3; i++)
        if (thisship->carrying[i])
        {
            dockednodes[i].ln_Name=thisship->carrying[i]->name;
            AddTail(&Docked1List, &dockednodes[i]);
        }
    if (!OpenInfoWindow())
    {
        showcargolist();
        while (HandleInfoIDCMP());
        CloseInfoWindow();
    }
}

void showinfo(UBYTE mode)
{
    GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    if (!mode)
        makecargolist();
    else
        createpersonlist(&List1List, currentship, ~0);
    GT_SetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Labels,
        &List1List, TAG_DONE);
}

/* Returns the current total weight of the given ship. Smaller ships being
   carried (ships of class Tiger and above can carry ships of class Albatross
   and below) are calculated recursively with this function. */
UWORD weight(struct ship *thisship)
{
    UWORD wt;
    UBYTE i;
    wt=class[thisship->class].weight;
    for (i=0; i<12; i++)
        wt+=thisship->cargo[i];
    if (class[thisship->class].docks)
        for (i=0; i<class[thisship->class].docks; i++)
            if (thisship->carrying[i])
                wt+=weight(thisship->carrying[i]);
    return wt;
}

/* Calculates the amount of free space available on the given ship. */
UWORD freespace(struct ship *thisship)
{
    UWORD wt;
    UBYTE i;
    wt=class[thisship->class].maxcargo;
    for (i=0; i<12; i++)
        wt-=thisship->cargo[i];
    return wt;
}

/* Returns the current speed factor of the given ship. Theoretical maximum is 1
   (ship is nothing but a big engine), but in practice the values range from
   0.0137 (maximally laden Centaur) to 0.48 (unladen Hummingbird). */
double speed(struct ship *thisship)
{
    return (double)class[thisship->class].engine/(double)weight(thisship);
}

/* Finds the ship with the slowest current speed and sets the variable slowest
   to equal its speed. */
void findslowest()
{
    struct ship *s;
    slowest=1.0;
    for (s=shiplist; s; s=s->next)
        if (speed(s)<slowest)
            slowest=speed(s);
}

/* Calculates the minimum amount of crew a ship of the given class takes to be
   able to operate. */
UBYTE getcrew(UBYTE classn)
{
    if (classn<=23)
        return 1;
    if (classn<=33)
        return 2;
    if (classn<=39)
        return 3;
    if (classn<=46)
        return 4;
    return 5;
}

void setshipmoves(double moves)
{
    currentship->moves=moves;
    GT_SetGadgetAttrs(SeaTradeGadgets[12], SeaTradeWnd, NULL, GTNM_Number,
        (LONG)moves, TAG_DONE);
}

void setshipfuel(UWORD fuel)
{
    currentship->cargo[10]=fuel;
    GT_SetGadgetAttrs(SeaTradeGadgets[13], SeaTradeWnd, NULL, GTNM_Number,
        (LONG)fuel, TAG_DONE);
}

void setshipfood(UWORD food)
{
    currentship->cargo[11]=food;
    GT_SetGadgetAttrs(SeaTradeGadgets[15], SeaTradeWnd, NULL, GTNM_Number,
        (LONG)food, TAG_DONE);
}

void consumefood()
{
    struct ship *s;
    for (s=shiplist; s; s=s->next)
        if (s->cargo[11] >= s->crew+s->passengers)
            s->cargo[11]-=s->crew+s->passengers;
        else
        {
            s->cargo[11]=0;
            request(SeaTradeWnd, "Alarm", "Ship \"%s\" has no\nfood left!",
                proceed, s->name);
        }
    setshipfood(currentship->cargo[11]);
}

UWORD getpay(struct ship *s)
{
    UWORD pay=0;
    struct person *p;
    for (p=personlist; p; p=p->next)
        if (p->location==s && gettype(p)==CREW)
            pay += p->pay;
    return pay;
}

/* Check if any ship still has moves left. If one has, select it, otherwise
   start a new round with all ships getting new moves. */
void checkships()
{
    struct ship *s;
    UBYTE message[80];
    UBYTE finished, i, j, flag;
    /* is there a ship (not being carried by another ship) that still has at
       least 1 move left? */
    finished=TRUE;
    for (s=shiplist; s; s=s->next)
        if (s->moves>=1.0 && !s->carriedby)
        {
            finished=FALSE;
            break;
        }
    if (finished)
    {
        /* start a new round */
        setdate(gametime+(ULONG)increment);
        flag=FALSE;
        for (i=0; i<128; i++)
        {
            for (j=0; j<12; j++)
                if (citydiff[i][j] != 0)
                {
                    flag=TRUE;
                    break;
                }
            if (flag)
                break;
        }
        if (logfile && flag)
        {
            writelogdate();
            writelog(": The following transactions took place:\n");
            for (i=0; i<128; i++)
                for (j=0; j<12; j++)
                    if (citydiff[i][j] != 0)
                    {
                        sprintf(message, "%s %d %11s %s %s.\n",
                            (citydiff[i][j]>0 ? "Bought" : "Sold  "),
                            abs(citydiff[i][j]), CargoName4Labels[j],
                            (citydiff[i][j]>0 ? "from" : "to  "),
                            getcity(i)->name);
                        writelog(message);
                    }
        }
        clearcitydiffs();
        findslowest();
        increment=60.0/slowest;
        for (s=shiplist; s; s=s->next)
            s->moves+=4.0*speed(s)/slowest;
        /* find the first ship which isn't being carried by another ship */
        for (s=shiplist; s->carriedby; s=s->next);
        select(s);
        setshipmoves(currentship->moves);
    }
    else
        if (currentship->moves<1.0)
            /* s is already pointing to the first ship that still has at least
               1 move left and isn't being carried by another ship */
            select(s);
}

/* Moves the current ship by the given delta coordinates. Delta coordinates must
   be either -1, 0 or 1. */
void moveship(BYTE dx, BYTE dy)
{
    UWORD x, y;
    UBYTE stage, i;
    double maxmoves, newmoves;
    /* the amount of moves this ship started with in this round */
    maxmoves=4.0/slowest*speed(currentship);
    if (currentship->moves<1.0)
        return;
    if (!currentship->cargo[10])
        return;
    if (currentship->carriedby)
    {
        request(SeaTradeWnd, error, "This ship is being carried by the\n"
            "ship \"%s\". Release\nit first.", proceed,
            currentship->carriedby->name);
        return;
    }
    getshiplocation(currentship, &x, &y);
    if (getblocktype(x+dx, y+dy)<353)
        return;
    if (dx!=0 || dy!=0)
    {
        if (currentship->flags&8)
            return;
        if (currentship->crew < getcrew(currentship->class) && !cheatmode)
        {
            request(SeaTradeWnd, error, "You don't have enough crew to\n"
                "operate the ship \"%s\".", proceed, currentship->name);
            return;
        }
        stage=currentship->flags&3;
        if (stage<3)
            currentship->flags=(currentship->flags&~3)|(stage+1);
        else
        {
            currentship->flags&=~3;
            setshipfuel(currentship->cargo[10]-1);
        }
        if (dx==-1)
            currentship->flags&=~4;
        if (dx==1)
            currentship->flags|=4;
        /* the amount of moves this ship would now have if we were to start a
           new round */
        newmoves=4.0/slowest*speed(currentship);
        setshipmoves(newmoves-maxmoves+currentship->moves);
    }
    x+=dx; y+=dy;
    setshiplocation(currentship, x, y);
    for (i=0; i<3; i++)
        if (currentship->carrying[i])
            setshiplocation(currentship->carrying[i], x, y);
    switch (autocenter)
    {
        case 0:
        /* Autocenter "None": Never center on ship at all */
        break;
        case 1:
        /* Autocenter "Off-line": Center on ship only if it's moving off-screen
        */
        if (x<mapleft || x>mapleft+10 || y<maptop || y>maptop+10)
        {
            mapleft=x-5; maptop=y-5;
        }
        break;
        case 2:
        /* Autocenter "On-line": Always center on a moving ship */
        mapleft=x-5; maptop=y-5;
        break;
    }
    drawmap(mapleft, maptop);
    coordinatestrings(latitude, longitude, x, y);
    GT_SetGadgetAttrs(SeaTradeGadgets[18], SeaTradeWnd, NULL, GTTX_Text,
        latitude, TAG_DONE);
    GT_SetGadgetAttrs(SeaTradeGadgets[19], SeaTradeWnd, NULL, GTTX_Text,
        longitude, TAG_DONE);
    if (dx!=0 || dy!=0)
    {
        /* ship has now moved, so it has 1 move less */
        setshipmoves(currentship->moves-1.0);
        checkships();
    }
}

/* Sets the autocenter mode to "None" (never center on ship), "Off-line" (center
   on ships moving off-screen) or "On-line" (always center on ship). Calls
   moveship(0, 0); to make sure ship is centered, if it needs to be. */
void setautocenter(UBYTE mode)
{
    autocenter=mode;
    moveship(0, 0);
}

void autopilot()
{
    if (!OpenAutopilotWindow()) {
        while (HandleAutopilotIDCMP());
        CloseAutopilotWindow();
    }
}

UBYTE compare(STRPTR this, STRPTR that)
{
    UBYTE thisa[9], thata[9];
    UBYTE i;
    strcpy(thisa, this);
    strcpy(thata, that);
    for (i=0; thisa[i]; i++)
        thisa[i]=tolower(thisa[i]);
    for (i=0; thata[i]; i++)
        thata[i]=tolower(thata[i]);
    return strcmp(thisa, thata);
}

int NameClicked()
{
    ULONG name;
    GT_GetGadgetAttrs(InfoGadgets[0], InfoWnd, NULL, GTST_String, &name,
        TAG_DONE);
    renameship(currentship, (STRPTR)name);
    sprintf(InfoWdt, "Info for ship \"%s\"", name);
    SetWindowTitles(InfoWnd, InfoWdt, Sct);
    return TRUE;
}
int ListClicked()
{
    UBYTE message[97], dstr[21], lat[8], lon[8];
    ULONG which;
    UWORD x, y;
    if (infomode)
    {
        GT_GetGadgetAttrs(InfoGadgets[2], InfoWnd, NULL, GTLV_Selected, &which,
            TAG_DONE);
        if (which<shippeople)
        {
            currentperson=findperson(currentship, which, ~0);
            getcitylocation(getcity(currentperson->destination), &x, &y);
            coordinatestrings(lat, lon, x, y);
            switch (gettype(currentperson))
            {
                case CREW:
                sprintf(message, "Type: crew member\nDaily salary: %d",
                    currentperson->pay);
                break;
                case TOURIST:
                case PASSENGER:
                datestring(dstr, currentperson->deadline);
                sprintf(message, "Type: passenger\nDestination: %s\n(%s %s)\n"
                    "Deadline:\n%s\nPay: %d",
                    getcity(currentperson->destination)->name, lat, lon, dstr,
                    currentperson->pay);
                break;
                case FAILED:
                sprintf(message, "Type: passenger\nDestination: %s\n(%s %s)\n"
                    "Deadline:\n*EXPIRED*",
                    getcity(currentperson->destination)->name, lat, lon);
                break;
            }
            request(InfoWnd, currentperson->name, message, proceed, NULL);
        }
    }
    return TRUE;
}
int DockedClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(InfoGadgets[3], InfoWnd, NULL, GTLV_Selected, &which,
        TAG_DONE);
    if (which==~0)
        currentdockedship=-1;
    else
        currentdockedship=which;
    return TRUE;
}
int ViewClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(InfoGadgets[4], InfoWnd, NULL, GTCY_Active, &which,
        TAG_DONE);
    if (which!=infomode)
    {
        infomode=which;
        showinfo(infomode);
    }
    return TRUE;
}
int TransferClicked()
{
    if (currentdockedship==-1)
        return TRUE;
    transfer(currentship, currentship->carrying[currentdockedship]);
    return TRUE;
}
int ReleaseClicked()
{
    struct ship *releasedship;
    UBYTE i;
    if (currentdockedship==-1)
        return TRUE;
    /* Mark the ship being released as free of any carrying ship */
    releasedship=currentship->carrying[currentdockedship];
    releasedship->carriedby=NULL;
    /* detach list from ListView gadget to allow editing */
    GT_SetGadgetAttrs(InfoGadgets[3], InfoWnd, NULL, GTLV_Labels,
        (struct List *)~0, TAG_DONE);
    Remove(&dockednodes[currentdockedship]);
    /* reattach list to ListView gadget to update display */
    GT_SetGadgetAttrs(InfoGadgets[3], InfoWnd, NULL, GTLV_Labels, &Docked1List,
        TAG_DONE);
    /* Update both the dockednodes array and the current ship's carrying list to
       mark that it is no longer carrying the ship we just released */
    for (i=currentdockedship; i<3; i++)
        if (i==2)
            currentship->carrying[i]=NULL;
        else
        {
            currentship->carrying[i]=currentship->carrying[i+1];
            dockednodes[i].ln_Name=dockednodes[i+1].ln_Name;
        }
    return TRUE;
}
int InfoCloseWindow()
{
    return FALSE;
}

int LatDegreesClicked()
{
    ULONG ld;
    GT_GetGadgetAttrs(AutopilotGadgets[0], AutopilotWnd, NULL, GTIN_Number,
        &ld, TAG_DONE);
    latdeg=(UWORD)ld;
    return TRUE;
}
int LatMinutesClicked()
{
    ULONG lm;
    GT_GetGadgetAttrs(AutopilotGadgets[1], AutopilotWnd, NULL, GTIN_Number,
        &lm, TAG_DONE);
    latmin=(UWORD)lm;
    return TRUE;
}
int NorthSouthClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(AutopilotGadgets[2], AutopilotWnd, NULL, GTCY_Active,
        &which, TAG_DONE);
    ns=which;
    return TRUE;
}
int LonDegreesClicked()
{
    ULONG ld;
    GT_GetGadgetAttrs(AutopilotGadgets[3], AutopilotWnd, NULL, GTIN_Number,
        &ld, TAG_DONE);
    londeg=(UWORD)ld;
    return TRUE;
}
int LonMinutesClicked()
{
    ULONG lm;
    GT_GetGadgetAttrs(AutopilotGadgets[4], AutopilotWnd, NULL, GTIN_Number,
        &lm, TAG_DONE);
    lonmin=(UWORD)lm;
    return TRUE;
}
int WestEastClicked()
{
    ULONG which;
    GT_GetGadgetAttrs(AutopilotGadgets[5], AutopilotWnd, NULL, GTCY_Active,
        &which, TAG_DONE);
    we=which;
    return TRUE;
}
int CityClicked()
{
    ULONG name;
    UWORD x, y;
    WORD cx, cy;
    UBYTE i, cn=~0;
    GT_GetGadgetAttrs(AutopilotGadgets[6], AutopilotWnd, NULL, GTST_String,
        &name, TAG_DONE);
    for (i=0; i<128; i++)
        if (!compare((STRPTR)name, city[i].name))
        {
            cn=i;
            break;
        }
    if (cn==~0 || !citiesknown[cn])
        request(AutopilotWnd, error, "The city \"%s\" is unknown.", proceed,
            name);
    else
    {
        getcitylocation(&city[cn], &x, &y);
        cx=(WORD)x-512; cy=(WORD)y-512;
        latdeg=abs(cy)/6; latmin=10*(abs(cy)%6);
        londeg=abs(cx)/6; lonmin=10*(abs(cx)%6);
        GT_SetGadgetAttrs(AutopilotGadgets[0], AutopilotWnd, NULL, GTIN_Number,
            (ULONG)latdeg, TAG_DONE);
        GT_SetGadgetAttrs(AutopilotGadgets[1], AutopilotWnd, NULL, GTIN_Number,
            (ULONG)latmin, TAG_DONE);
        GT_SetGadgetAttrs(AutopilotGadgets[2], AutopilotWnd, NULL, GTCY_Active,
            (ULONG)(cy>=0), TAG_DONE);
        GT_SetGadgetAttrs(AutopilotGadgets[3], AutopilotWnd, NULL, GTIN_Number,
            (ULONG)londeg, TAG_DONE);
        GT_SetGadgetAttrs(AutopilotGadgets[4], AutopilotWnd, NULL, GTIN_Number,
            (ULONG)lonmin, TAG_DONE);
        GT_SetGadgetAttrs(AutopilotGadgets[5], AutopilotWnd, NULL, GTCY_Active,
            (ULONG)(cx>=0), TAG_DONE);
    }
    return TRUE;
}
int OKClicked()
{
    return FALSE;
}
int AutopilotCloseWindow()
{
    return FALSE;
}
